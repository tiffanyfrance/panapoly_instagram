{"version":3,"sources":["../../../src/lib/model-utils.js"],"names":["Buffer","assert","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","getBuffersFromGeometry","gl","geometry","options","buffers","name","attributes","attribute","remappedName","mapAttributeName","constant","value","typedArray","accessor","inferAttributeAccessor","indices","data","target","attributeMap","attributeName","category","size","isIndexed","undefined","Uint16Array","Uint32Array","Number","isFinite"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (geometry.indices) {\n    buffers.indices = new Buffer(gl, {\n      data: geometry.indices.value || geometry.indices,\n      target: GL.ELEMENT_ARRAY_BUFFER\n    });\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'indices':\n      category = category || 'indices';\n      break;\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    case 'indices':\n      attribute.size = attribute.size || 1;\n      attribute.isIndexed = attribute.isIndexed === undefined ? true : attribute.isIndexed;\n      assert(\n        attribute.value instanceof Uint16Array || attribute.value instanceof Uint32Array,\n        'attribute array for \"indices\" must be of integer type'\n      );\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n"],"file":"model-utils.js"}