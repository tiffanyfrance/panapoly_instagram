{"version":3,"sources":["../../../src/classes/texture-cube.js"],"names":["Texture","assertWebGLContext","log","FACES","TextureCube","constructor","gl","props","Object","assign","target","initialize","seal","mipmaps","parameters","opts","setCubeMapImageData","then","loaded","generateMipmap","setParameters","subImage","face","data","x","y","mipmapLevel","_subImage","width","height","pixels","border","format","type","imageDataMap","resolvedFaces","Promise","all","map","facePixels","Array","isArray","bind","forEach","index","length","warn","id","image","lodLevel","texImage2D","unbind","setImageDataForFace","options","imageData","resolvedImageData"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Texture from './texture';\nimport {assertWebGLContext} from '../webgl-utils';\nimport {log} from '../utils';\n\nconst FACES = [\n  GL.TEXTURE_CUBE_MAP_POSITIVE_X,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_X,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Y,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Z,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Z\n];\n\nexport default class TextureCube extends Texture {\n  constructor(gl, props = {}) {\n    assertWebGLContext(gl);\n\n    super(gl, Object.assign({}, props, {target: GL.TEXTURE_CUBE_MAP}));\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(props = {}) {\n    const {/* format = GL.RGBA, */ mipmaps = true, parameters = {}} = props;\n\n    // let {width = 1, height = 1, type = GL.UNSIGNED_BYTE, dataFormat} = props;\n\n    // Deduce width and height based on one of the faces\n    // ({type, dataFormat} = this._deduceParameters({format, type, dataFormat}));\n    // ({width, height} = this._deduceImageSize({\n    //   data: props[GL.TEXTURE_CUBE_MAP_POSITIVE_X],\n    //   width,\n    //   height\n    // }));\n\n    // Enforce cube\n    // assert(width === height);\n\n    // Temporarily apply any pixel store paramaters and build textures\n    // withParameters(this.gl, props, () => {\n    //   for (const face of CUBE_MAP_FACES) {\n    //     this.setImageData({\n    //       target: face,\n    //       data: props[face],\n    //       width, height, format, type, dataFormat, border, mipmaps\n    //     });\n    //   }\n    // });\n\n    // Store props for accessors\n    this.opts = props;\n\n    this.setCubeMapImageData(props).then(() => {\n      this.loaded = true;\n\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n      // TODO - without generateMipmap() cube textures do not work at all!!! Why?\n      if (mipmaps) {\n        this.generateMipmap(props);\n      }\n\n      this.setParameters(parameters);\n    });\n  }\n\n  subImage({face, data, x = 0, y = 0, mipmapLevel = 0}) {\n    return this._subImage({target: face, data, x, y, mipmapLevel});\n  }\n\n  /* eslint-disable max-statements, max-len */\n  async setCubeMapImageData({\n    width,\n    height,\n    pixels,\n    data,\n    border = 0,\n    format = GL.RGBA,\n    type = GL.UNSIGNED_BYTE\n  }) {\n    const {gl} = this;\n    const imageDataMap = pixels || data;\n\n    // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n    // For example:\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n    // ... }\n    // To provide multiple level-of-details (LODs) this can be Face to Array\n    // of Image or Promise, like this\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // ... }\n\n    const resolvedFaces = await Promise.all(\n      FACES.map(face => {\n        const facePixels = imageDataMap[face];\n        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n      })\n    );\n\n    this.bind();\n\n    FACES.forEach((face, index) => {\n      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {\n        // If the user provides multiple LODs, then automatic mipmap\n        // generation generateMipmap() should be disabled to avoid overwritting them.\n        log.warn(`${this.id} has mipmap and multiple LODs.`)();\n      }\n      resolvedFaces[index].forEach((image, lodLevel) => {\n        // TODO: adjust width & height for LOD!\n        if (width && height) {\n          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n        } else {\n          gl.texImage2D(face, lodLevel, format, format, type, image);\n        }\n      });\n    });\n\n    this.unbind();\n  }\n\n  // TODO: update this method to accept LODs\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE\n      // generateMipmap = false // TODO\n    } = options;\n\n    const {gl} = this;\n\n    const imageData = pixels || data;\n\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData =>\n        this.setImageDataForFace(\n          Object.assign({}, options, {\n            face,\n            data: resolvedImageData,\n            pixels: resolvedImageData\n          })\n        )\n      );\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n\n    return this;\n  }\n}\n\nTextureCube.FACES = FACES;\n"],"file":"texture-cube.js"}