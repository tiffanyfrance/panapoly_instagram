{"version":3,"sources":["../../../../../src/modules/picking/test/picking.spec.js"],"names":["Buffer","Transform","picking","test","fixture","gl","gl2","TEST_DATA","vertexColorData","Float32Array","TEST_CASES","pickingSelectedColor","isPicked","pickingThreshold","t","isSupported","comment","end","VS","elementCount","length","vertexColor","byteLength","transform","sourceBuffers","feedbackBuffers","vs","varyings","modules","forEach","testCase","uniforms","getUniforms","run","expectedData","outData","getBuffer","getData","deepEqual","COLOR_SCALE","EPSILON","rgbColorASelected","reduce","result","element","index","pickingColor","slice","map","e","push","out","Math","abs","ok"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer, Transform} from '@luma.gl/core';\nimport {picking} from '@luma.gl/shadertools';\nimport test from 'tape-catch';\nimport {fixture} from 'test/setup';\n\n// TODO: test WebGL1 when Transform class is ready\nconst gl = fixture.gl2;\n\nconst TEST_DATA = {\n  vertexColorData: new Float32Array([\n    0,\n    0,\n    0,\n    255,\n    100,\n    150,\n    50,\n    50,\n    50,\n    251,\n    103,\n    153, // is picked only when threshold is 5\n    150,\n    100,\n    255,\n    254.5,\n    100,\n    150, // is picked with default threshold (1)\n    100,\n    150,\n    255,\n    255,\n    255,\n    255,\n    255,\n    100,\n    149.5 // // is picked with default threshold (1)\n  ])\n};\n\nconst TEST_CASES = [\n  {\n    pickingSelectedColor: null,\n    isPicked: [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  },\n  {\n    pickingSelectedColor: [255, 255, 255],\n    isPicked: [0, 0, 0, 0, 0, 0, 0, 1, 0]\n  },\n  {\n    pickingSelectedColor: [255, 100, 150],\n    isPicked: [0, 1, 0, 0, 0, 1, 0, 0, 1]\n  },\n  {\n    pickingSelectedColor: [255, 100, 150],\n    pickingThreshold: 5,\n    isPicked: [0, 1, 0, 1, 0, 1, 0, 0, 1]\n  }\n];\n\ntest('picking#isVertexPicked(pickingSelectedColor invalid)', t => {\n  if (!Transform.isSupported(gl)) {\n    t.comment('Transform not available, skipping tests');\n    t.end();\n    return;\n  }\n\n  const VS = `\\\n  attribute vec3 vertexColor;\n  varying float isPicked;\n\n  void main()\n  {\n    isPicked = float(isVertexPicked(vertexColor));\n  }\n  `;\n  const vertexColorData = TEST_DATA.vertexColorData;\n\n  const elementCount = vertexColorData.length / 3;\n  const vertexColor = new Buffer(gl, vertexColorData);\n  const isPicked = new Buffer(gl, {byteLength: elementCount * 4});\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      vertexColor\n    },\n    feedbackBuffers: {\n      isPicked\n    },\n    vs: VS,\n    varyings: ['isPicked'],\n    modules: [picking],\n    elementCount\n  });\n\n  TEST_CASES.forEach(testCase => {\n    const uniforms = picking.getUniforms({\n      pickingSelectedColor: testCase.pickingSelectedColor,\n      pickingThreshold: testCase.pickingThreshold\n    });\n\n    transform.run({uniforms});\n\n    const expectedData = testCase.isPicked;\n    const outData = transform.getBuffer('isPicked').getData();\n\n    t.deepEqual(outData, expectedData, 'Vertex should correctly get picked');\n  });\n\n  t.end();\n});\n\n/* eslint-disable max-nested-callbacks */\ntest('picking#picking_setPickingColor', t => {\n  if (!Transform.isSupported(gl)) {\n    t.comment('Transform not available, skipping tests');\n    t.end();\n    return;\n  }\n  const VS = `\\\n  attribute vec3 vertexColor;\n  varying vec4 rgbColorASelected;\n\n  void main()\n  {\n    picking_setPickingColor(vertexColor);\n    rgbColorASelected = picking_vRGBcolor_Aselected;\n  }\n  `;\n\n  const COLOR_SCALE = 1 / 255;\n  const EPSILON = 0.00001;\n  const vertexColorData = TEST_DATA.vertexColorData;\n\n  const elementCount = vertexColorData.length / 3;\n  const vertexColor = new Buffer(gl, vertexColorData);\n  const rgbColorASelected = new Buffer(gl, {byteLength: elementCount * 4 * 4});\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      vertexColor\n    },\n    feedbackBuffers: {\n      rgbColorASelected\n    },\n    vs: VS,\n    varyings: ['rgbColorASelected'],\n    modules: [picking],\n    elementCount\n  });\n\n  TEST_CASES.forEach(testCase => {\n    const uniforms = picking.getUniforms({\n      pickingSelectedColor: testCase.pickingSelectedColor,\n      pickingThreshold: testCase.pickingThreshold\n    });\n\n    transform.run({uniforms});\n\n    const expectedData = testCase.isPicked.reduce((result, element, index) => {\n      const pickingColor = TEST_DATA.vertexColorData\n        .slice(index * 3, index * 3 + 3)\n        .map(e => e * COLOR_SCALE);\n      result.push(pickingColor[0], pickingColor[1], pickingColor[2], element);\n      return result;\n    }, []);\n    const outData = transform.getBuffer('rgbColorASelected').getData();\n\n    outData.forEach((out, index) => {\n      if (Math.abs(out - expectedData[index]) > EPSILON) {\n        t.ok(false, 'Vertex should correctly get picked');\n      }\n    });\n  });\n  t.ok(true, 'picking_setPickingColor successful');\n\n  t.end();\n});\n/* eslint-enable max-nested-callbacks */\n"],"file":"picking.spec.js"}