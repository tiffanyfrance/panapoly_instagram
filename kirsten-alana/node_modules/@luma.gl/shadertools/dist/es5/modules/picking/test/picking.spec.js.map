{"version":3,"sources":["../../../../../src/modules/picking/test/picking.spec.js"],"names":["gl","fixture","gl2","TEST_DATA","vertexColorData","Float32Array","TEST_CASES","pickingSelectedColor","isPicked","pickingThreshold","t","Transform","isSupported","comment","end","VS","elementCount","length","vertexColor","Buffer","byteLength","transform","sourceBuffers","feedbackBuffers","vs","varyings","modules","picking","forEach","testCase","uniforms","getUniforms","run","expectedData","outData","getBuffer","getData","deepEqual","COLOR_SCALE","EPSILON","rgbColorASelected","reduce","result","element","index","pickingColor","slice","map","e","push","out","Math","abs","ok"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Buffer, Transform} from '@luma.gl/core';\nimport {picking} from '@luma.gl/shadertools';\nimport test from 'tape-catch';\nimport {fixture} from 'test/setup';\n\n// TODO: test WebGL1 when Transform class is ready\nconst gl = fixture.gl2;\n\nconst TEST_DATA = {\n  vertexColorData: new Float32Array([\n    0,\n    0,\n    0,\n    255,\n    100,\n    150,\n    50,\n    50,\n    50,\n    251,\n    103,\n    153, // is picked only when threshold is 5\n    150,\n    100,\n    255,\n    254.5,\n    100,\n    150, // is picked with default threshold (1)\n    100,\n    150,\n    255,\n    255,\n    255,\n    255,\n    255,\n    100,\n    149.5 // // is picked with default threshold (1)\n  ])\n};\n\nconst TEST_CASES = [\n  {\n    pickingSelectedColor: null,\n    isPicked: [0, 0, 0, 0, 0, 0, 0, 0, 0]\n  },\n  {\n    pickingSelectedColor: [255, 255, 255],\n    isPicked: [0, 0, 0, 0, 0, 0, 0, 1, 0]\n  },\n  {\n    pickingSelectedColor: [255, 100, 150],\n    isPicked: [0, 1, 0, 0, 0, 1, 0, 0, 1]\n  },\n  {\n    pickingSelectedColor: [255, 100, 150],\n    pickingThreshold: 5,\n    isPicked: [0, 1, 0, 1, 0, 1, 0, 0, 1]\n  }\n];\n\ntest('picking#isVertexPicked(pickingSelectedColor invalid)', t => {\n  if (!Transform.isSupported(gl)) {\n    t.comment('Transform not available, skipping tests');\n    t.end();\n    return;\n  }\n\n  const VS = `\\\n  attribute vec3 vertexColor;\n  varying float isPicked;\n\n  void main()\n  {\n    isPicked = float(isVertexPicked(vertexColor));\n  }\n  `;\n  const vertexColorData = TEST_DATA.vertexColorData;\n\n  const elementCount = vertexColorData.length / 3;\n  const vertexColor = new Buffer(gl, vertexColorData);\n  const isPicked = new Buffer(gl, {byteLength: elementCount * 4});\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      vertexColor\n    },\n    feedbackBuffers: {\n      isPicked\n    },\n    vs: VS,\n    varyings: ['isPicked'],\n    modules: [picking],\n    elementCount\n  });\n\n  TEST_CASES.forEach(testCase => {\n    const uniforms = picking.getUniforms({\n      pickingSelectedColor: testCase.pickingSelectedColor,\n      pickingThreshold: testCase.pickingThreshold\n    });\n\n    transform.run({uniforms});\n\n    const expectedData = testCase.isPicked;\n    const outData = transform.getBuffer('isPicked').getData();\n\n    t.deepEqual(outData, expectedData, 'Vertex should correctly get picked');\n  });\n\n  t.end();\n});\n\n/* eslint-disable max-nested-callbacks */\ntest('picking#picking_setPickingColor', t => {\n  if (!Transform.isSupported(gl)) {\n    t.comment('Transform not available, skipping tests');\n    t.end();\n    return;\n  }\n  const VS = `\\\n  attribute vec3 vertexColor;\n  varying vec4 rgbColorASelected;\n\n  void main()\n  {\n    picking_setPickingColor(vertexColor);\n    rgbColorASelected = picking_vRGBcolor_Aselected;\n  }\n  `;\n\n  const COLOR_SCALE = 1 / 255;\n  const EPSILON = 0.00001;\n  const vertexColorData = TEST_DATA.vertexColorData;\n\n  const elementCount = vertexColorData.length / 3;\n  const vertexColor = new Buffer(gl, vertexColorData);\n  const rgbColorASelected = new Buffer(gl, {byteLength: elementCount * 4 * 4});\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      vertexColor\n    },\n    feedbackBuffers: {\n      rgbColorASelected\n    },\n    vs: VS,\n    varyings: ['rgbColorASelected'],\n    modules: [picking],\n    elementCount\n  });\n\n  TEST_CASES.forEach(testCase => {\n    const uniforms = picking.getUniforms({\n      pickingSelectedColor: testCase.pickingSelectedColor,\n      pickingThreshold: testCase.pickingThreshold\n    });\n\n    transform.run({uniforms});\n\n    const expectedData = testCase.isPicked.reduce((result, element, index) => {\n      const pickingColor = TEST_DATA.vertexColorData\n        .slice(index * 3, index * 3 + 3)\n        .map(e => e * COLOR_SCALE);\n      result.push(pickingColor[0], pickingColor[1], pickingColor[2], element);\n      return result;\n    }, []);\n    const outData = transform.getBuffer('rgbColorASelected').getData();\n\n    outData.forEach((out, index) => {\n      if (Math.abs(out - expectedData[index]) > EPSILON) {\n        t.ok(false, 'Vertex should correctly get picked');\n      }\n    });\n  });\n  t.ok(true, 'picking_setPickingColor successful');\n\n  t.end();\n});\n/* eslint-enable max-nested-callbacks */\n"],"file":"picking.spec.js"}