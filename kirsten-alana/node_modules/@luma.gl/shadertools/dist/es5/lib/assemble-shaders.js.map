{"version":3,"sources":["../../../src/lib/assemble-shaders.js"],"names":["SHADER_TYPE","VERTEX_SHADER","FRAGMENT_SHADER","FRAGMENT_SHADER_PROLOGUE","assembleShaders","gl","opts","vs","fs","modules","assembleShader","Object","assign","source","type","getUniforms","assembleGetUniforms","assembleModuleMap","id","defines","inject","prologue","log","isVertex","sourceLines","split","glslVersion","versionLine","coreSource","indexOf","slice","join","allDefines","forEach","module","getDefines","assembledSource","getShaderName","getShaderType","getApplicationDefines","injectStandardStubs","name","checkDeprecations","moduleSource","getModuleSource","uniforms","moduleUniforms","result","moduleName","shaderModule","toUpperCase","injectShaderName","count","sourceText","define","value","Number","isFinite"],"mappings":"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","sourcesContent":["import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules, getShaderModule} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader from './inject-shader';\nimport {assert} from '../utils';\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts = {}) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {id, source, type, modules = [], defines = {}, inject = {}, prologue = true, log}\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  // Add source of dependent modules in resolved order\n  let injectStandardStubs = false;\n  for (const module of modules) {\n    switch (module.name) {\n      case 'inject':\n        injectStandardStubs = true;\n        break;\n\n      default:\n        module.checkDeprecations(coreSource, log);\n        const moduleSource = module.getModuleSource(type, glslVersion);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n    }\n  }\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, inject, injectStandardStubs);\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\n// Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\nfunction assembleModuleMap(modules) {\n  const result = {};\n  for (const moduleName of modules) {\n    const shaderModule = getShaderModule(moduleName);\n    result[moduleName] = shaderModule;\n  }\n  return result;\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n"],"file":"assemble-shaders.js"}