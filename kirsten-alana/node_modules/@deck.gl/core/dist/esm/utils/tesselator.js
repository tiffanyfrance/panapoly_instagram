import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { fillArray } from './flatten';
import { createIterable } from './iterable-utils';

var TypedArrayManager = function () {
  function TypedArrayManager() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$overAlloc = _ref.overAlloc,
        overAlloc = _ref$overAlloc === void 0 ? 1 : _ref$overAlloc;

    _classCallCheck(this, TypedArrayManager);

    this.overAlloc = overAlloc;
  }

  _createClass(TypedArrayManager, [{
    key: "allocate",
    value: function allocate(typedArray, count, _ref2) {
      var size = _ref2.size,
          type = _ref2.type,
          _ref2$copy = _ref2.copy,
          copy = _ref2$copy === void 0 ? false : _ref2$copy;
      var newSize = count * size;

      if (typedArray && newSize <= typedArray.length) {
        return typedArray;
      }

      var allocSize = Math.max(Math.ceil(newSize * this.overAlloc), 1);

      var newArray = this._allocate(type, allocSize);

      if (typedArray && copy) {
        newArray.set(typedArray);
      }

      this._release(typedArray);

      return newArray;
    }
  }, {
    key: "_allocate",
    value: function _allocate() {
      var Type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Float32Array;
      var size = arguments.length > 1 ? arguments[1] : undefined;
      return new Type(size);
    }
  }, {
    key: "_release",
    value: function _release(typedArray) {}
  }]);

  return TypedArrayManager;
}();

var Tesselator = function () {
  function Tesselator() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Tesselator);

    var _opts$attributes = opts.attributes,
        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
    this.typedArrayManager = new TypedArrayManager();
    this.indexLayout = null;
    this.bufferLayout = null;
    this.vertexCount = 0;
    this.instanceCount = 0;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.updateGeometry(opts);
    Object.seal(this);
  }

  _createClass(Tesselator, [{
    key: "updateGeometry",
    value: function updateGeometry(_ref3) {
      var data = _ref3.data,
          getGeometry = _ref3.getGeometry,
          positionFormat = _ref3.positionFormat,
          fp64 = _ref3.fp64;
      this.data = data;
      this.getGeometry = getGeometry;
      this.fp64 = fp64;
      this.positionSize = positionFormat === 'XY' ? 2 : 3;

      this._rebuildGeometry();
    }
  }, {
    key: "updatePartialGeometry",
    value: function updatePartialGeometry(_ref4) {
      var start = _ref4.start,
          count = _ref4.count,
          objects = _ref4.objects;
    }
  }, {
    key: "updateGeometryAttributes",
    value: function updateGeometryAttributes(geometry, startIndex, size) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getGeometrySize",
    value: function getGeometrySize(geometry) {
      throw new Error('Not implemented');
    }
  }, {
    key: "_forEachGeometry",
    value: function _forEachGeometry(visitor) {
      var data = this.data,
          getGeometry = this.getGeometry;

      var _createIterable = createIterable(data),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var geometry = getGeometry(object, objectInfo);
          visitor(geometry, objectInfo.index);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "_updateAttribute",
    value: function _updateAttribute(_ref5) {
      var target = _ref5.target,
          size = _ref5.size,
          getValue = _ref5.getValue;
      var data = this.data,
          bufferLayout = this.bufferLayout;
      var i = 0;

      var _createIterable2 = createIterable(data),
          iterable = _createIterable2.iterable,
          objectInfo = _createIterable2.objectInfo;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var object = _step2.value;
          objectInfo.index++;
          var value = getValue(object, objectInfo);
          var numVertices = bufferLayout[objectInfo.index];
          fillArray({
            target: target,
            source: value,
            start: i,
            count: numVertices
          });
          i += numVertices * size;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return target;
    }
  }, {
    key: "_rebuildGeometry",
    value: function _rebuildGeometry() {
      var _this = this;

      if (!this.data || !this.getGeometry) {
        return;
      }

      var indexLayout = [];
      var bufferLayout = [];
      var instanceCount = 0;

      this._forEachGeometry(function (geometry, dataIndex) {
        var count = _this.getGeometrySize(geometry);

        instanceCount += count;
        bufferLayout[dataIndex] = count;
      });

      var attributes = this.attributes,
          _attributeDefs = this._attributeDefs,
          typedArrayManager = this.typedArrayManager,
          fp64 = this.fp64;

      for (var name in _attributeDefs) {
        var def = _attributeDefs[name];

        if (!def.fp64Only || fp64) {
          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
        }
      }

      this.indexLayout = indexLayout;
      this.bufferLayout = bufferLayout;
      this.instanceCount = instanceCount;
      var context = {
        vertexStart: 0,
        indexStart: 0
      };

      this._forEachGeometry(function (geometry, dataIndex) {
        var geometrySize = bufferLayout[dataIndex];
        context.geometryIndex = dataIndex;
        context.geometrySize = geometrySize;

        _this.updateGeometryAttributes(geometry, context);

        context.vertexStart += geometrySize;
        context.indexStart += indexLayout[dataIndex] || 0;
      });

      this.vertexCount = context.indexStart;
    }
  }]);

  return Tesselator;
}();

export { Tesselator as default };
//# sourceMappingURL=tesselator.js.map