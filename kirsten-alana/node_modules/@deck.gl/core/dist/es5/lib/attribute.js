"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _iterableUtils = require("../utils/iterable-utils");

var _log = _interopRequireDefault(require("../utils/log"));

var _baseAttribute = _interopRequireDefault(require("./base-attribute"));

var DEFAULT_STATE = {
  isExternalBuffer: false,
  needsUpdate: true,
  needsRedraw: false,
  allocedInstances: -1
};

var Attribute = function (_BaseAttribute) {
  (0, _inherits2.default)(Attribute, _BaseAttribute);

  function Attribute(gl) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, Attribute);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Attribute).call(this, gl, opts));
    var _opts$transition = opts.transition,
        transition = _opts$transition === void 0 ? false : _opts$transition,
        _opts$noAlloc = opts.noAlloc,
        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,
        _opts$update = opts.update,
        update = _opts$update === void 0 ? null : _opts$update,
        _opts$accessor = opts.accessor,
        accessor = _opts$accessor === void 0 ? null : _opts$accessor,
        _opts$bufferLayout = opts.bufferLayout,
        bufferLayout = _opts$bufferLayout === void 0 ? null : _opts$bufferLayout;
    var _opts$defaultValue = opts.defaultValue,
        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;
    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
    _this.shaderAttributes = {};
    _this.hasShaderAttributes = false;

    if (opts.shaderAttributes) {
      var shaderAttributes = opts.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        _this.shaderAttributes[shaderAttributeName] = new Attribute(_this.gl, Object.assign({}, shaderAttribute, {
          id: shaderAttributeName,
          constant: shaderAttribute.constant || false,
          isIndexed: shaderAttribute.isIndexed || shaderAttribute.elements,
          size: shaderAttribute.elements && 1 || shaderAttribute.size || _this.size,
          value: shaderAttribute.value || null,
          divisor: shaderAttribute.instanced || shaderAttribute.divisor || _this.divisor,
          buffer: _this.getBuffer(),
          noAlloc: true
        }));
        _this.hasShaderAttributes = true;
      }
    }

    Object.assign(_this.userData, DEFAULT_STATE, opts, {
      transition: transition,
      noAlloc: noAlloc,
      update: update,
      accessor: accessor,
      defaultValue: defaultValue,
      bufferLayout: bufferLayout
    });
    Object.seal(_this.userData);

    _this._validateAttributeUpdaters();

    return _this;
  }

  (0, _createClass2.default)(Attribute, [{
    key: "needsUpdate",
    value: function needsUpdate() {
      return this.userData.needsUpdate;
    }
  }, {
    key: "needsRedraw",
    value: function needsRedraw() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$clearChangedFlag = _ref.clearChangedFlags,
          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;

      var needsRedraw = this.userData.needsRedraw;
      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
  }, {
    key: "getInstanceCount",
    value: function getInstanceCount() {
      return this.value !== null ? this.value.length / this.size : 0;
    }
  }, {
    key: "getUpdateTriggers",
    value: function getUpdateTriggers() {
      var accessor = this.userData.accessor;
      return [this.id].concat(accessor || []);
    }
  }, {
    key: "getAccessor",
    value: function getAccessor() {
      return this.userData.accessor;
    }
  }, {
    key: "getShaderAttributes",
    value: function getShaderAttributes() {
      var shaderAttributes = {};

      if (this.hasShaderAttributes) {
        Object.assign(shaderAttributes, this.shaderAttributes);
      } else {
        shaderAttributes[this.id] = this;
      }

      return shaderAttributes;
    }
  }, {
    key: "supportsTransition",
    value: function supportsTransition() {
      return this.userData.transition;
    }
  }, {
    key: "getTransitionSetting",
    value: function getTransitionSetting(opts) {
      var _this$userData = this.userData,
          transition = _this$userData.transition,
          accessor = _this$userData.accessor;

      if (!transition) {
        return null;
      }

      var settings = Array.isArray(accessor) ? opts[accessor.find(function (a) {
        return opts[a];
      })] : opts[accessor];

      if (Number.isFinite(settings)) {
        settings = {
          duration: settings
        };
      }

      if (settings && settings.duration > 0) {
        return Object.assign({}, transition, settings);
      }

      return null;
    }
  }, {
    key: "setNeedsUpdate",
    value: function setNeedsUpdate() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.userData.needsUpdate = this.userData.needsUpdate || reason;
    }
  }, {
    key: "setNeedsRedraw",
    value: function setNeedsRedraw() {
      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
      this.userData.needsRedraw = this.userData.needsRedraw || reason;
    }
  }, {
    key: "allocate",
    value: function allocate(numInstances) {
      var state = this.userData;

      if (state.isExternalBuffer || state.noAlloc) {
        return false;
      }

      var instanceCount = this.getInstanceCount();
      var needsAlloc = instanceCount === 0 || instanceCount < numInstances;

      if (needsAlloc && (state.update || state.accessor)) {
        (0, _assert.default)(Number.isFinite(numInstances));
        var allocCount = Math.max(numInstances, 1);
        var ArrayType = glArrayFromType(this.type || 5126);
        this.constant = false;
        this.value = new ArrayType(this.size * allocCount);
        state.needsUpdate = true;
        state.allocedInstances = allocCount;
        return true;
      }

      return false;
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(_ref2) {
      var numInstances = _ref2.numInstances,
          data = _ref2.data,
          props = _ref2.props,
          context = _ref2.context;

      if (!this.needsUpdate()) {
        return false;
      }

      var state = this.userData;
      var update = state.update,
          accessor = state.accessor;
      var updated = true;

      if (update) {
        update.call(context, this, {
          data: data,
          props: props,
          numInstances: numInstances
        });
        this.update({
          value: this.value,
          constant: this.constant
        });

        this._checkAttributeArray();
      } else if (accessor) {
        this._updateBufferViaStandardAccessor(data, props);

        this._checkAttributeArray();
      } else {
        updated = false;
      }

      this._updateShaderAttributes();

      state.needsUpdate = false;
      state.needsRedraw = true;
      return updated;
    }
  }, {
    key: "update",
    value: function update(props) {
      (0, _get2.default)((0, _getPrototypeOf2.default)(Attribute.prototype), "update", this).call(this, props);

      this._updateShaderAttributes();
    }
  }, {
    key: "setGenericValue",
    value: function setGenericValue(value) {
      var state = this.userData;

      if (value === undefined || typeof value === 'function') {
        state.isExternalBuffer = false;
        return false;
      }

      value = this._normalizeValue(value);
      var hasChanged = !this.constant || !this._areValuesEqual(value, this.value);

      if (hasChanged) {
        this.update({
          constant: true,
          value: value
        });
      }

      state.needsRedraw = state.needsUpdate || hasChanged;
      state.needsUpdate = false;
      state.isExternalBuffer = true;

      this._updateShaderAttributes();

      return true;
    }
  }, {
    key: "setExternalBuffer",
    value: function setExternalBuffer(buffer, numInstances) {
      var state = this.userData;

      if (buffer) {
        state.isExternalBuffer = true;
        state.needsUpdate = false;

        if (buffer instanceof _core.Buffer) {
          if (this.externalBuffer !== buffer) {
            this.update({
              constant: false,
              buffer: buffer
            });
            state.needsRedraw = true;
          }
        } else if (this.value !== buffer) {
          if (!ArrayBuffer.isView(buffer)) {
            throw new Error('Attribute prop must be typed array');
          }

          if (state.auto && buffer.length <= numInstances * this.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          var ArrayType = glArrayFromType(this.type || 5126);

          if (buffer instanceof ArrayType) {
            this.update({
              constant: false,
              value: buffer
            });
          } else {
            _log.default.warn("Attribute prop ".concat(this.id, " is casted to ").concat(ArrayType.name))();

            this.update({
              constant: false,
              value: new ArrayType(buffer)
            });
          }

          this.value = buffer;
          state.needsRedraw = true;
        }

        this._updateShaderAttributes();

        return true;
      }

      state.isExternalBuffer = false;
      return false;
    }
  }, {
    key: "_normalizeValue",
    value: function _normalizeValue(value) {
      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var defaultValue = this.userData.defaultValue;

      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {
        out[start] = Number.isFinite(value) ? value : defaultValue[0];
        return out;
      }

      switch (this.size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
      }

      return out;
    }
  }, {
    key: "_areValuesEqual",
    value: function _areValuesEqual(value1, value2) {
      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;

      for (var i = 0; i < size; i++) {
        if (value1[i] !== value2[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_updateBufferViaStandardAccessor",
    value: function _updateBufferViaStandardAccessor(data, props) {
      var state = this.userData;
      var accessor = state.accessor;
      var value = this.value,
          size = this.size;
      var accessorFunc = props[accessor];
      (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
      var i = 0;

      var _createIterable = (0, _iterableUtils.createIterable)(data),
          iterable = _createIterable.iterable,
          objectInfo = _createIterable.objectInfo;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          objectInfo.index++;
          var objectValue = accessorFunc(object, objectInfo);

          this._normalizeValue(objectValue, value, i);

          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.update({
        value: value
      });
    }
  }, {
    key: "_validateAttributeUpdaters",
    value: function _validateAttributeUpdaters() {
      var state = this.userData;
      var hasUpdater = state.noAlloc || typeof state.update === 'function' || typeof state.accessor === 'string';

      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
  }, {
    key: "_checkAttributeArray",
    value: function _checkAttributeArray() {
      var value = this.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);

        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  }, {
    key: "_updateShaderAttributes",
    value: function _updateShaderAttributes() {
      var shaderAttributes = this.shaderAttributes;

      for (var shaderAttributeName in shaderAttributes) {
        var shaderAttribute = shaderAttributes[shaderAttributeName];
        shaderAttribute.update({
          buffer: this.getBuffer(),
          value: this.value,
          constant: this.constant
        });
      }
    }
  }, {
    key: "bufferLayout",
    get: function get() {
      return this.userData.bufferLayout;
    },
    set: function set(layout) {
      this.userData.bufferLayout = layout;
    }
  }]);
  return Attribute;
}(_baseAttribute.default);

exports.default = Attribute;

function glArrayFromType(glType) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$clamped = _ref3.clamped,
      clamped = _ref3$clamped === void 0 ? true : _ref3$clamped;

  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce type from array');
  }
}
//# sourceMappingURL=attribute.js.map