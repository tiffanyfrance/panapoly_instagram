!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("deck"),require("h3"),require("S2"),require("luma"));else if("function"==typeof define&&define.amd)define(["deck","h3","S2","luma"],t);else{var n="object"==typeof exports?t(require("deck"),require("h3"),require("S2"),require("luma")):t(e.deck,e.h3,e.S2,e.luma);for(var i in n)("object"==typeof exports?exports:e)[i]=n[i]}}(window,function(e,t,n,i){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(i,r,function(t){return e[t]}.bind(null,r));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=4)}([function(t,n){t.exports=e},function(e,n){e.exports=t},function(e,t){e.exports=n},function(e,t){e.exports=i},function(e,t,n){(function(t){const i=n(6),r=("undefined"==typeof window?t:window).deck||{};if(!r.LineLayer)throw new Error("@deck.gl/layers is not found");e.exports=Object.assign(r,i)}).call(this,n(5))},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";n.r(t);var i=n(0),r="#define SHADER_NAME great-circle-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\n// get angular distance in radian\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 delta = source - target;\n  vec2 sin_half_delta = sin(delta / 2.0);\n  float a =\n    sin_half_delta.y * sin_half_delta.y +\n    cos(source.y) * cos(target.y) *\n    sin_half_delta.x * sin_half_delta.x;\n  return 2.0 * atan(sqrt(a), sqrt(1.0 - a));\n}\n\nvec2 interpolate (vec2 source, vec2 target, float angularDist, float t) {\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  if(abs(angularDist - PI) < 0.001) {\n    return (1.0 - t) * source + t * target;\n  }\n\n  float a = sin((1.0 - t) * angularDist) / sin(angularDist);\n  float b = sin(t * angularDist) / sin(angularDist);\n  vec2 sin_source = sin(source);\n  vec2 cos_source = cos(source);\n  vec2 sin_target = sin(target);\n  vec2 cos_target = cos(target);\n\n  float x = a * cos_source.y * cos_source.x + b * cos_target.y * cos_target.x;\n  float y = a * cos_source.y * sin_source.x + b * cos_target.y * sin_target.x;\n  float z = a * sin_source.y + b * sin_target.y;\n  return vec2(atan(y, x), atan(z, sqrt(x * x + y * y)));\n}\n\nvoid main(void) {\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  \n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n  \n  vec2 source = radians(instancePositions.xy);\n  vec2 target = radians(instancePositions.zw);\n  \n  float angularDist = getAngularDist(source, target);\n\n  vec3 currPos = vec3(degrees(interpolate(source, target, angularDist, segmentRatio)), 0.0);\n  vec3 nextPos = vec3(degrees(interpolate(source, target, angularDist, nextSegmentRatio)), 0.0);\n\n  vec2 currPos64Low = mix(instancePositions64Low.xy, instancePositions64Low.zw, segmentRatio);\n  vec2 nextPos64Low = mix(instancePositions64Low.xy, instancePositions64Low.zw, nextSegmentRatio);\n\n  vec4 curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0));\n  vec4 next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n\n  // Multiply out width and clamp to limits\n  // mercator pixels are interpreted as screen pixels\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  // extrude\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.0;\n  vColor = vec4(color.rgb, color.a * opacity);\n  \n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n";class o extends i.ArcLayer{getShaders(){return Object.assign({},super.getShaders(),{vs:r,modules:["picking","project32"]})}}o.layerName="GreatCircleLayer";var a=n(2);const s=180/Math.PI,l=100;function c([e,t,n]){const i=Math.atan2(n,Math.sqrt(e*e+t*t));return[Math.atan2(t,e)*s,i*s]}function u(e){const t=function(e){const t=e.padEnd(16,"0");return String(parseInt(t,16))}(e),n=function(e){const t=e.substr(e.length-1);return 2*(e.length-1)-(0==(1&t))}(e);return function({face:e,ij:t,level:n}){const i=[],r=[[0,0],[0,1],[1,1],[1,0],[0,0]],o=Math.max(1,l*Math.pow(2,-n));for(let s=0;s<4;s++){const l=r[s].slice(0),u=r[s+1],d=(u[0]-l[0])/o,g=(u[1]-l[1])/o;for(let r=0;r<o;r++){l[0]+=d,l[1]+=g;const r=a.S2.IJToST(t,n,l),o=a.S2.STToUV(r),s=a.S2.FaceUVToXYZ(e,o);i.push(c(s))}}return i}(a.S2.S2Cell.FromLatLng(a.S2.idToLatLng(t),n))}const d=Object.assign({getS2Token:{type:"accessor",value:e=>e.token}},i.PolygonLayer.defaultProps);class g extends i.CompositeLayer{renderLayers(){const{data:e,getS2Token:t}=this.props,{elevationScale:n,extruded:r,wireframe:o,filled:a,stroked:s,lineWidthUnits:l,lineWidthScale:c,lineWidthMinPixels:d,lineWidthMaxPixels:g,lineJointRounded:h,lineMiterLimit:f,lineDashJustified:p,fp64:m,getElevation:y,getFillColor:x,getLineColor:v,getLineWidth:L,getLineDashArray:_}=this.props,{updateTriggers:b,material:P}=this.props;return new(this.getSubLayerClass("cell",i.PolygonLayer))({fp64:m,filled:a,wireframe:o,extruded:r,elevationScale:n,stroked:s,lineWidthUnits:l,lineWidthScale:c,lineWidthMinPixels:d,lineWidthMaxPixels:g,lineJointRounded:h,lineMiterLimit:f,lineDashJustified:p,material:P,getElevation:y,getFillColor:x,getLineColor:v,getLineWidth:L,getLineDashArray:_},this.getSubLayerProps({id:"cell",updateTriggers:{getElevation:b.getElevation,getFillColor:b.getFillColor,getLineColor:b.getLineColor,getLineWidth:b.getLineWidth,getLineDashArray:b.getLineDashArray}}),{data:e,getPolygon:e=>u(t(e))})}}function h(e,t,n){const i=e/Math.pow(2,n)*360-180,r=Math.PI-2*Math.PI*t/Math.pow(2,n);return[i,180/Math.PI*Math.atan(.5*(Math.exp(r)-Math.exp(-r)))]}g.layerName="S2Layer",g.defaultProps=d;class f{constructor({getTileData:e,x:t,y:n,z:i,onTileError:r}){this.x=t,this.y=n,this.z=i,this.bbox=function(e,t,n){const[i,r]=h(e,t,n),[o,a]=h(e+1,t+1,n);return{west:i,north:r,east:o,south:a}}(this.x,this.y,this.z),this.isVisible=!0,this.getTileData=e,this._data=null,this._isLoaded=!1,this._loader=this._loadData(),this.onTileError=r}get data(){return this._data?Promise.resolve(this._data):this._loader}get isLoaded(){return this._isLoaded}_loadData(){const{x:e,y:t,z:n}=this;return this.getTileData?this.getTileData({x:e,y:t,z:n}).then(e=>(this._data=e,this._isLoaded=!0,e)).catch(e=>{this._isLoaded=!0,this.onTileError(e)}):null}isOverlapped(e){const{x:t,y:n,z:i}=this,r=Math.pow(2,e.z-i);return Math.floor(e.x/r)===t&&Math.floor(e.y/r)===n}}function p(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],i=!0,r=!1,o=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){r=!0,o=e}finally{try{i||null==s.return||s.return()}finally{if(r)throw o}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var m="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;Math.PI;var y,x;y=new m(4),m!=Float32Array&&(y[0]=0,y[1]=0,y[2]=0,y[3]=0),x=y;!function(){var e,t=(e=new m(2),m!=Float32Array&&(e[0]=0,e[1]=0),e)}();!function(){var e,t=(e=new m(3),m!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e)}();function v(e,t){if(!e)throw new Error(t||"viewport-mercator-project: assertion failed.")}var L=Math.PI,_=L/4,b=L/180,P=512;function S(e,t){var n=p(e,2),i=n[0],r=n[1];v(Number.isFinite(i)&&Number.isFinite(t)),v(Number.isFinite(r)&&r>=-90&&r<=90,"invalid latitude");var o=r*b;return[(t*=P)*(i*b+L)/(2*L),t*(L-Math.log(Math.tan(_+.5*o)))/(2*L)]}const T=512;function w(e){return Math.floor(e/T)}function C({x:e,y:t,z:n},i){const r=Math.pow(2,n-i);return{x:Math.floor(e/r),y:Math.floor(t/r),z:i}}class j{constructor({getTileData:e,maxSize:t,maxZoom:n,minZoom:i,onTileError:r}){this._getTileData=e,this._maxSize=t,this.onTileError=r,this._cache=new Map,n&&parseInt(n,10)===n&&(this._maxZoom=n),i&&parseInt(i,10)===i&&(this._minZoom=i)}finalize(){this._cache.clear()}update(e,t){const{_cache:n,_getTileData:i,_maxSize:r,_maxZoom:o,_minZoom:a}=this;this._markOldTiles();const s=function(e,t,n){const i=Math.floor(e.zoom);if(n&&i<n)return[];const r=function(e){const t=[e.unproject([0,0]),e.unproject([e.width,0]),e.unproject([0,e.height]),e.unproject([e.width,e.height])];return[t.reduce((e,t)=>e<t[0]?e:t[0],180),t.reduce((e,t)=>e<t[1]?e:t[1],90),t.reduce((e,t)=>e>t[0]?e:t[0],-180),t.reduce((e,t)=>e>t[1]?e:t[1],-90)]}(e=new e.constructor(Object.assign({},e,{zoom:i}))),[o,a]=S([r[0],r[3]],e.scale).map(w),[s,l]=S([r[2],r[1]],e.scale).map(w),c=[];for(let e=o;e<=s;e++)for(let n=a;n<=l;n++)t&&i>t?c.push(C({x:e,y:n,z:i},t)):c.push({x:e,y:n,z:i});return c}(e,o,a);if(!s||0===s.length)return void t(s);const l=new Set;n.forEach(e=>{s.some(t=>e.isOverlapped(t))&&(e.isVisible=!0,l.add(e))});for(let e=0;e<s.length;e++){const t=s[e],{x:r,y:o,z:a}=t;let c=this._getTile(r,o,a);c||(c=new f({getTileData:i,x:r,y:o,z:a,onTileError:this.onTileError}));const u=this._getTileId(r,o,a);n.set(u,c),l.add(c)}this._resizeCache(r||5*s.length),t(Array.from(l).sort((e,t)=>e.z-t.z))}_resizeCache(e){const{_cache:t}=this;if(t.size>e){const n=t[Symbol.iterator]();for(const i of n){if(t.size<=e)break;const n=i[0];i[1].isVisible||t.delete(n)}}}_markOldTiles(){this._cache.forEach(e=>{e.isVisible=!1})}_getTile(e,t,n){const i=this._getTileId(e,t,n);return this._cache.get(i)}_getTileId(e,t,n){return`${n}-${e}-${t}`}}const M={renderSubLayers:{type:"function",value:e=>new i.GeoJsonLayer(e)},getTileData:{type:"function",value:({x:e,y:t,z:n})=>Promise.resolve(null)},onViewportLoaded:{type:"function",value:()=>{}},onTileError:{type:"function",value:e=>console.error(e)},maxZoom:null,minZoom:0,maxCacheSize:null};class z extends i.CompositeLayer{initializeState(){const{maxZoom:e,minZoom:t,getTileData:n,onTileError:i}=this.props;this.state={tiles:[],tileCache:new j({getTileData:n,maxZoom:e,minZoom:t,onTileError:i}),isLoaded:!1}}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState({props:e,oldProps:t,context:n,changeFlags:i}){const{onViewportLoaded:r,onTileError:o}=e;if(i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getTileData)){const{getTileData:t,maxZoom:n,minZoom:i,maxCacheSize:r}=e;this.state.tileCache.finalize(),this.setState({tileCache:new j({getTileData:t,maxSize:r,maxZoom:n,minZoom:i,onTileError:o})})}if(i.viewportChanged){const{viewport:e}=n,t=this.getLayerZoomLevel();"DEFAULT-INITIAL-VIEWPORT"!==e.id&&this.state.tileCache.update(e,e=>{const n=e.filter(e=>e.z===t),i=n.every(e=>e.isLoaded);this.setState({tiles:e,isLoaded:i}),i?r(n.filter(e=>e._data).map(e=>e._data)):Promise.all(n.map(e=>e.data)).then(()=>{this.setState({isLoaded:!0}),r(n.filter(e=>e._data).map(e=>e._data))})})}}getPickingInfo({info:e,sourceLayer:t}){return e.sourceLayer=t,e.tile=t.props.tile,e}getLayerZoomLevel(){const e=Math.floor(this.context.viewport.zoom),{maxZoom:t,minZoom:n}=this.props;return t&&parseInt(t,10)===t&&e>t?t:n&&parseInt(n,10)===n&&e<n?n:e}renderLayers(){const{renderSubLayers:e,visible:t}=this.props,n=this.getLayerZoomLevel();return this.state.tiles.map(i=>e(Object.assign({},this.props,{id:`${this.id}-${i.x}-${i.y}-${i.z}`,data:i.data,visible:t&&(!this.state.isLoaded||i.z===n),tile:i})))}}z.layerName="TileLayer",z.defaultProps=M;class D extends i.PathLayer{getShaders(){const e=super.getShaders();return e.inject={"vs:#decl":"uniform float trailLength;\nvarying float vTime;\n","vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);":"pos.z = 0.0;","vs:#main-end":"float shiftZ = mod(instanceEndPositions.z, trailLength) * 1e-4;\ngl_Position.z += shiftZ;\nvTime = instanceStartPositions.z + (instanceEndPositions.z - instanceStartPositions.z) * vPathPosition.y / vPathLength;\n","fs:#decl":"uniform float trailLength;\nuniform float currentTime;\nvarying float vTime;\n","fs:#main-start":"if(vTime > currentTime || vTime < currentTime - trailLength) {\n  discard;\n}\n","gl_FragColor = vColor;":"gl_FragColor.a *= 1.0 - (currentTime - vTime) / trailLength;"},e}draw(e){const{trailLength:t,currentTime:n}=this.props;e.uniforms=Object.assign({},e.uniforms,{trailLength:t,currentTime:n}),super.draw(e)}}D.layerName="TripsLayer",D.defaultProps={trailLength:{type:"number",value:120,min:0},currentTime:{type:"number",value:0,min:0}};var E=n(1);const I=Object.assign({getHexagons:{type:"accessor",value:e=>e.hexagons}},i.PolygonLayer.defaultProps);class O extends i.CompositeLayer{updateState({props:e,oldProps:t,changeFlags:n}){if(n.dataChanged||n.updateTriggers&&n.updateTriggers.getHexagons){const{data:t,getHexagons:n}=e,r=[],{iterable:o,objectInfo:a}=Object(i.createIterable)(t);for(const e of o){a.index++;const t=n(e,a),i=Object(E.h3SetToMultiPolygon)(t,!0);for(const t of i)r.push({polygon:t,object:e,index:a.index})}this.setState({polygons:r})}}getPickingInfo({info:e}){return Object.assign(e,{object:e.object&&e.object.object,index:e.object&&e.object.index})}getSubLayerAccessor(e){return"function"!=typeof e?e:(t,n)=>e(t.object,n)}renderLayers(){const{elevationScale:e,extruded:t,wireframe:n,filled:r,stroked:o,lineWidthScale:a,lineWidthMinPixels:s,lineWidthMaxPixels:l,lineJointRounded:c,lineMiterLimit:u,lineDashJustified:d,fp64:g,material:h,getFillColor:f,getLineColor:p,getLineWidth:m,getLineDashArray:y,getElevation:x,updateTriggers:v}=this.props;return new(this.getSubLayerClass("cluster-region",i.PolygonLayer))({fp64:g,filled:r,wireframe:n,extruded:t,elevationScale:e,stroked:o,lineWidthScale:a,lineWidthMinPixels:s,lineWidthMaxPixels:l,lineJointRounded:c,lineMiterLimit:u,lineDashJustified:d,material:h,getFillColor:this.getSubLayerAccessor(f),getLineColor:this.getSubLayerAccessor(p),getLineWidth:this.getSubLayerAccessor(m),getLineDashArray:this.getSubLayerAccessor(y),getElevation:this.getSubLayerAccessor(x)},this.getSubLayerProps({id:"cluster-region",updateTriggers:v}),{data:this.state.polygons,getPolygon:e=>e.polygon})}}function F(e,t,n){const i=e(t,n),[r,o]=Object(E.h3ToGeo)(i);return[o,r]}O.defaultProps=I,O.layerName="H3ClusterLayer";const k={highPrecision:!1,coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},extruded:!0,fp64:!1,getHexagon:{type:"accessor",value:e=>e.hexagon},getColor:{type:"accessor",value:[255,0,255,255]},getElevation:{type:"accessor",value:1e3},material:new(n(3).PhongMaterial)};class A extends i.CompositeLayer{shouldUpdateState({changeFlags:e}){return this._shouldUseHighPrecision()?e.propsOrDataChanged:e.somethingChanged}updateState({props:e,oldProps:t,changeFlags:n}){if(n.dataChanged||n.updateTriggers&&n.updateTriggers.getHexagon){let t=-1,n=!1;const{iterable:r,objectInfo:o}=Object(i.createIterable)(e.data);for(const i of r){o.index++;const r=e.getHexagon(i,o);if(t=t<0?Object(E.h3GetResolution)(r):t,Object(E.h3IsPentagon)(r)){n=!0;break}}this.setState({resolution:t,hasPentagon:n,vertices:null})}this._updateVertices(this.context.viewport)}_shouldUseHighPrecision(){const{resolution:e,hasPentagon:t}=this.state;return this.props.highPrecision||t||e>=0&&e<=5}_updateVertices(e){if(this._shouldUseHighPrecision())return;const{resolution:t,centerHex:n}=this.state;if(t<0)return;const i=Object(E.geoToH3)(e.latitude,e.longitude,t);if(n===i)return;const{pixelsPerMeter:r}=e.distanceScales;let o=Object(E.h3ToGeoBoundary)(i,!0);const[a,s]=Object(E.h3ToGeo)(i),[l,c]=e.projectFlat([s,a]);o=o.map(t=>{const n=e.projectFlat(t);return n[0]=(n[0]-l)/r[0],n[1]=(n[1]-c)/r[1],n}),this.setState({centerHex:i,vertices:o})}renderLayers(){return this._shouldUseHighPrecision()?this._renderPolygonLayer():this._renderColumnLayer()}_renderPolygonLayer(){const{data:e,getHexagon:t,updateTriggers:n,elevationScale:r,extruded:o,fp64:a,getColor:s,getElevation:l,material:c}=this.props;return new(this.getSubLayerClass("hexagon-cell-hifi",i.SolidPolygonLayer))({filled:!0,elevationScale:r,extruded:o,fp64:a,getFillColor:s,getElevation:l,material:c},this.getSubLayerProps({id:"hexagon-cell-hifi",updateTriggers:{getFillColor:n.getFillColor,getElevation:n.getElevation}}),{data:e,getPolygon:(e,n)=>{const i=t(e,n);return Object(E.h3ToGeoBoundary)(i,!0)}})}_renderColumnLayer(){const{data:e,getHexagon:t,updateTriggers:n,coverage:r,elevationScale:o,extruded:a,fp64:s,getColor:l,getElevation:c,material:u}=this.props;return new(this.getSubLayerClass("hexagon-cell",i.ColumnLayer))({coverage:r,elevationScale:o,extruded:a,fp64:s,getColor:l,getElevation:c,material:u},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:n}),{data:e,diskResolution:6,radius:1,vertices:this.state.vertices,getPosition:F.bind(null,t)})}}A.defaultProps=k,A.layerName="H3HexagonLayer",n.d(t,"GreatCircleLayer",function(){return o}),n.d(t,"S2Layer",function(){return g}),n.d(t,"TileLayer",function(){return z}),n.d(t,"TripsLayer",function(){return D}),n.d(t,"H3ClusterLayer",function(){return O}),n.d(t,"H3HexagonLayer",function(){return A})}])});