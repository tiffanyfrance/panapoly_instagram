!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("luma"),require("deck"));else if("function"==typeof define&&define.amd)define(["luma","deck"],t);else{var n="object"==typeof exports?t(require("luma"),require("deck")):t(e.luma,e.deck);for(var i in n)("object"==typeof exports?exports:e)[i]=n[i]}}(window,function(e,t){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var o=t[i]={i:i,l:!1,exports:{}};return e[i].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(i,o,function(t){return e[t]}.bind(null,o));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=2)}([function(t,n){t.exports=e},function(e,n){e.exports=t},function(e,t,n){(function(t){const i=n(5),o=("undefined"==typeof window?t:window).deck||{};if(!o.LineLayer)throw new Error("@deck.gl/layers is not found");e.exports=Object.assign(o,i)}).call(this,n(4))},,function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";n.r(t);var i=n(1);const o=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];var r=n(0),a=n.n(r);function s(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=[],i=!0,o=!1,r=void 0;try{for(var a,s=e[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!t||n.length!==t);i=!0);}catch(e){o=!0,r=e}finally{try{i||null==s.return||s.return()}finally{if(o)throw r}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var l=1e-6,c="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;Math.PI;function u(e,t,n){var i=t[0],o=t[1],r=t[2],a=t[3];return e[0]=n[0]*i+n[4]*o+n[8]*r+n[12]*a,e[1]=n[1]*i+n[5]*o+n[9]*r+n[13]*a,e[2]=n[2]*i+n[6]*o+n[10]*r+n[14]*a,e[3]=n[3]*i+n[7]*o+n[11]*r+n[15]*a,e}var g,h;g=new c(4),c!=Float32Array&&(g[0]=0,g[1]=0,g[2]=0,g[3]=0),h=g;function d(e,t){var n,i,o,r=u([],t,e);return n=r,i=r,o=1/r[3],n[0]=i[0]*o,n[1]=i[1]*o,n[2]=i[2]*o,n[3]=i[3]*o,r}function f(e,t,n){var i=t[0],o=t[1],r=t[2],a=t[3],s=t[4],l=t[5],c=t[6],u=t[7],g=t[8],h=t[9],d=t[10],f=t[11],p=t[12],v=t[13],m=t[14],x=t[15],y=n[0],S=n[1],M=n[2],b=n[3];return e[0]=y*i+S*s+M*g+b*p,e[1]=y*o+S*l+M*h+b*v,e[2]=y*r+S*c+M*d+b*m,e[3]=y*a+S*u+M*f+b*x,y=n[4],S=n[5],M=n[6],b=n[7],e[4]=y*i+S*s+M*g+b*p,e[5]=y*o+S*l+M*h+b*v,e[6]=y*r+S*c+M*d+b*m,e[7]=y*a+S*u+M*f+b*x,y=n[8],S=n[9],M=n[10],b=n[11],e[8]=y*i+S*s+M*g+b*p,e[9]=y*o+S*l+M*h+b*v,e[10]=y*r+S*c+M*d+b*m,e[11]=y*a+S*u+M*f+b*x,y=n[12],S=n[13],M=n[14],b=n[15],e[12]=y*i+S*s+M*g+b*p,e[13]=y*o+S*l+M*h+b*v,e[14]=y*r+S*c+M*d+b*m,e[15]=y*a+S*u+M*f+b*x,e}function p(e,t,n){var i,o,r,a,s,l,c,u,g,h,d,f,p=n[0],v=n[1],m=n[2];return t===e?(e[12]=t[0]*p+t[4]*v+t[8]*m+t[12],e[13]=t[1]*p+t[5]*v+t[9]*m+t[13],e[14]=t[2]*p+t[6]*v+t[10]*m+t[14],e[15]=t[3]*p+t[7]*v+t[11]*m+t[15]):(i=t[0],o=t[1],r=t[2],a=t[3],s=t[4],l=t[5],c=t[6],u=t[7],g=t[8],h=t[9],d=t[10],f=t[11],e[0]=i,e[1]=o,e[2]=r,e[3]=a,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=g,e[9]=h,e[10]=d,e[11]=f,e[12]=i*p+s*v+g*m+t[12],e[13]=o*p+l*v+h*m+t[13],e[14]=r*p+c*v+d*m+t[14],e[15]=a*p+u*v+f*m+t[15]),e}function v(e,t,n){var i=n[0],o=n[1],r=n[2];return e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e[3]=t[3]*i,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function m(e,t,n){var i=Math.sin(n),o=Math.cos(n),r=t[4],a=t[5],s=t[6],l=t[7],c=t[8],u=t[9],g=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=r*o+c*i,e[5]=a*o+u*i,e[6]=s*o+g*i,e[7]=l*o+h*i,e[8]=c*o-r*i,e[9]=u*o-a*i,e[10]=g*o-s*i,e[11]=h*o-l*i,e}function x(e,t,n){var i=Math.sin(n),o=Math.cos(n),r=t[0],a=t[1],s=t[2],l=t[3],c=t[4],u=t[5],g=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=r*o+c*i,e[1]=a*o+u*i,e[2]=s*o+g*i,e[3]=l*o+h*i,e[4]=c*o-r*i,e[5]=u*o-a*i,e[6]=g*o-s*i,e[7]=h*o-l*i,e}function y(e,t,n,i,o){var r,a=1/Math.tan(t/2);return e[0]=a/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=a,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(r=1/(i-o),e[10]=(o+i)*r,e[14]=2*o*i*r):(e[10]=-1,e[14]=-2*i),e}!function(){var e,t=(e=new c(2),c!=Float32Array&&(e[0]=0,e[1]=0),e)}();function S(e,t,n){var i=new c(3);return i[0]=e,i[1]=t,i[2]=n,i}function M(e,t){var n=t[0],i=t[1],o=t[2],r=n*n+i*i+o*o;return r>0&&(r=1/Math.sqrt(r)),e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}!function(){var e,t=(e=new c(3),c!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e)}();function b(e,t){if(!e)throw new Error(t||"viewport-mercator-project: assertion failed.")}Math.PI;function C(e,t){var n=s(e,3),i=n[0],o=n[1],r=n[2],a=void 0===r?0:r;return b(Number.isFinite(i)&&Number.isFinite(o)&&Number.isFinite(a)),d(t,[i,o,a,1])}const w={SUM:1,MEAN:2,MIN:3,MAX:4},E={dataChanged:!0,viewportChanged:!0,cellSizeChanged:!0},P={changeFlags:E,projectPoints:!1,useGPU:!0,fp64:!1,viewport:null,gridTransformMatrix:null,createBufferObjects:!0},A=3.402823466e38,D=[a.a.MIN,a.a.FUNC_ADD],O=[a.a.MAX,a.a.FUNC_ADD],T=[a.a.MAX,a.a.MIN],N={[w.SUM]:a.a.FUNC_ADD,[w.MEAN]:a.a.FUNC_ADD,[w.MIN]:D,[w.MAX]:O},k=4,z={size:1,operation:w.SUM,needMin:!1,needMax:!1,combineMaxMin:!1},_=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],F=4,L=3;var B="#define SHADER_NAME gpu-aggregation-to-grid-vs\n\nattribute vec2 positions;\nattribute vec3 weights;\nuniform vec2 windowSize;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform mat4 uProjectionMatrix;\nuniform bool projectPoints;\n\nvarying vec3 vWeights;\n\nvec2 project_to_pixel(vec4 pos) {\n  vec4 result =  uProjectionMatrix * pos;\n  return result.xy/result.w;\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec4 windowPos = vec4(positions, 0, 1.);\n  if (projectPoints) {\n    windowPos = project_position_to_clipspace(vec3(positions, 0), vec2(0, 0), vec3(0, 0, 0));\n  }\n\n  vec2 pos = project_to_pixel(windowPos);\n\n  // Transform (0,0):windowSize -> (0, 0): gridSize\n  pos = floor(pos / cellSize);\n\n  // Transform (0,0):gridSize -> (-1, -1):(1,1)\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",R="#define SHADER_NAME gpu-aggregation-to-grid-vs-64\n\nattribute vec2 positions;\nattribute vec2 positions64xyLow;\nattribute vec3 weights;\nuniform vec2 windowSize;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform vec2 uProjectionMatrixFP64[16];\nuniform bool projectPoints;\n\nvarying vec3 vWeights;\n\nvoid project_to_pixel(vec2 pos, vec2 pos64xyLow, out vec2 pixelXY64[2]) {\n\n  vec2 result64[4];\n  vec2 position64[4];\n  position64[0] = vec2(pos.x, pos64xyLow.x);\n  position64[1] = vec2(pos.y, pos64xyLow.y);\n  position64[2] = vec2(0., 0.);\n  position64[3] = vec2(1., 0.);\n  mat4_vec4_mul_fp64(uProjectionMatrixFP64, position64,\n  result64);\n\n  pixelXY64[0] = div_fp64(result64[0], result64[3]);\n  pixelXY64[1] = div_fp64(result64[1], result64[3]);\n}\n\nvoid main(void) {\n\n  vWeights = weights;\n\n  vec2 windowPos = positions;\n  vec2 windowPos64xyLow = positions64xyLow;\n  if (projectPoints) {\n    vec2 projectedXY[2];\n    project_position_fp64(windowPos, windowPos64xyLow, projectedXY);\n    windowPos.x = projectedXY[0].x;\n    windowPos.y = projectedXY[1].x;\n    windowPos64xyLow.x = projectedXY[0].y;\n    windowPos64xyLow.y = projectedXY[1].y;\n  }\n\n  vec2 pixelXY64[2];\n  project_to_pixel(windowPos, windowPos64xyLow, pixelXY64);\n\n  // Transform (0,0):windowSize -> (0, 0): gridSize\n  vec2 gridXY64[2];\n  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\n  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\n  float x = floor(gridXY64[0].x);\n  float y = floor(gridXY64[1].x);\n  vec2 pos = vec2(x, y);\n\n  // Transform (0,0):gridSize -> (-1, -1):(1,1)\n  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n}\n",j="#define SHADER_NAME gpu-aggregation-to-grid-fs\n\nprecision highp float;\n\nvarying vec3 vWeights;\n\nvoid main(void) {\n  gl_FragColor = vec4(vWeights, 1.0);\n}\n",I="#version 300 es\n#define SHADER_NAME gpu-aggregation-all-vs-64\n\nin vec2 position;\nuniform vec2 gridSize;\n\nout vec2 vTextureCoord;\nvoid main(void) {\n  // Map each position to single pixel\n  vec2 pos = vec2(-1.0, -1.0);\n\n  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize\n  vec2 offset = 1.0 / gridSize;\n  pos = pos + offset;\n\n  gl_Position = vec4(pos, 0.0, 1.0);\n\n  float yIndex = floor(float(gl_InstanceID) / gridSize[0]);\n  float xIndex = float(gl_InstanceID) - (yIndex * gridSize[0]);\n\n  vec2 yIndexFP64 = vec2(yIndex, 0.);\n  vec2 xIndexFP64 = vec2(xIndex, 0.);\n  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\n  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\n\n  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\n  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\n\n  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\n}\n",W="#version 300 es\n#define SHADER_NAME gpu-aggregation-all-fs\n\nprecision highp float;\n\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform bool combineMaxMin;\nout vec4 fragColor;\nvoid main(void) {\n  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\n  if (textureColor.a == 0.) {\n    discard;\n  }\n  fragColor.rgb = textureColor.rgb;\n  // if combineMinMax is true, use Alpha channel for first weights min value.\n  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\n}\n",V="#define SHADER_NAME gpu-aggregation-transform-mean-vs\nattribute vec4 aggregationValues;\nvarying vec4 meanValues;\n\nvoid main()\n{\n  // TODO: Use 64-bit division ?? not needed given this is aggregation ??\n  bool isCellValid = bool(aggregationValues.w > 0.);\n  // aggregationValues:  XYZ contain aggregated values, W contains count\n  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\n  meanValues.w = aggregationValues.w;\n}\n";function U(e,t){const{width:n=1,height:i=1}=t;return new r.Texture2D(e,{data:null,format:a.a.RGBA32F,type:a.a.FLOAT,border:0,mipmaps:!1,parameters:{[a.a.TEXTURE_MAG_FILTER]:a.a.NEAREST,[a.a.TEXTURE_MIN_FILTER]:a.a.NEAREST},dataFormat:a.a.RGBA,width:n,height:i})}function G(e,t){const{id:n,width:i=1,height:o=1}=t,s=t.texture||U(e,t);return new r.Framebuffer(e,{id:n,width:i,height:o,attachments:{[a.a.COLOR_ATTACHMENT0]:s}})}function X(e,t,n=0){return!e||e.length<t?new Float32Array(t).fill(n):e}function Y({gl:e,bufferName:t,data:n,result:i}){i[t]?i[t].subData({data:n}):i[t]=new r.Buffer(e,n)}const{fp64ifyMatrix4:q}=r.fp64;class H{static getAggregationData({aggregationData:e,maxData:t,pixelIndex:n}){i.log.assert(e.length>=(n+1)*F),i.log.assert(t.length===F);const o=n*F;return{cellCount:e[o+3],cellWeight:e[o],totalCount:t[3],maxCellWieght:t[0]}}static getCellData({countsData:e,size:t=1}){const n=e.length/4,i=new Float32Array(n*t),o=new Uint32Array(n);for(let r=0;r<n;r++){for(let n=0;n<t;n++)i[r*t+n]=e[4*r+n];o[r]=e[4*r+3]}return{cellCounts:o,cellWeights:i}}constructor(e,t={}){this.id=t.id||"gpu-grid-aggregator",this.shaderCache=t.shaderCache||null,this.gl=e,this.state={weights:null,gridPositions:null,positionsBuffer:null,positions64xyLowBuffer:null,vertexCount:0,fp64:null,useGPU:null,numCol:0,numRow:0,windowSize:null,cellSize:null,weightAttributes:{},textures:{},meanTextures:{},buffers:{},framebuffers:{},maxMinFramebuffers:{},minFramebuffers:{},maxFramebuffers:{},equations:{}},this._hasGPUSupport=Object(r.isWebGL2)(e)&&Object(r.hasFeatures)(this.gl,r.FEATURES.BLEND_EQUATION_MINMAX,r.FEATURES.COLOR_ATTACHMENT_RGBA32F,r.FEATURES.TEXTURE_FLOAT)}delete(){const{gridAggregationModel:e,allAggregationModel:t,meanTransform:n}=this,{positionsBuffer:i,position64Buffer:o,framebuffers:r,maxMinFramebuffers:a,minFramebuffers:s,maxFramebuffers:l,meanTextures:c}=this.state;e&&e.delete(),t&&t.delete(),n&&n.delete(),i&&i.delete(),o&&o.delete(),this.deleteResources(r),this.deleteResources(a),this.deleteResources(s),this.deleteResources(l),this.deleteResources(c)}run(e={}){const t=this.getAggregationParams(e);this.updateGridSize(t);const{useGPU:n}=t;return this._hasGPUSupport&&n?this.runAggregationOnGPU(t):(n&&i.log.warn("ScreenGridAggregator: GPU Aggregation not supported, falling back to CPU")(),this.runAggregationOnCPU(t))}deleteResources(e){for(const t in e)e[t].delete()}getAggregationParams(e){const t=Object.assign({},P,e),{useGPU:n,gridTransformMatrix:i,viewport:o,weights:r,projectPoints:a,cellSize:s}=t;return this.state.useGPU!==n&&(t.changeFlags=Object.assign({},t.changeFlags,E)),!s||this.state.cellSize&&this.state.cellSize[0]===s[0]&&this.state.cellSize[1]===s[1]||(t.changeFlags.cellSizeChanged=!0,this.setState({cellSize:s})),this.validateProps(t,e),this.setState({useGPU:n}),t.gridTransformMatrix=(a?o.viewportMatrix:i)||_,r&&(t.weights=this.normalizeWeightParams(r),this.setState({weights:t.weights})),t}normalizeWeightParams(e){const t={};for(const n in e)t[n]=Object.assign({},z,e[n]);return t}setState(e){Object.assign(this.state,e)}shouldTransformToGrid(e){const{projectPoints:t,changeFlags:n}=e;return!!(!this.state.gridPositions||n.dataChanged||t&&n.viewportChanged)}updateGridSize(e){const{viewport:t,cellSize:n}=e,i=e.width||t.width,o=e.height||t.height,r=Math.ceil(i/n[0]),a=Math.ceil(o/n[1]);this.setState({numCol:r,numRow:a,windowSize:[i,o]})}validateProps(e,t){const{changeFlags:n,projectPoints:o,gridTransformMatrix:r}=e;i.log.assert(n.dataChanged||n.viewportChanged||n.cellSizeChanged),i.log.assert(!n.dataChanged||t.positions&&t.weights&&(!t.projectPositions||t.viewport)&&t.cellSize),i.log.assert(!n.cellSizeChanged||t.cellSize),i.log.assert(!(n.viewportChanged&&o)||t.viewport),o&&r&&i.log.warn("projectPoints is true, gridTransformMatrix is ignored")()}calculateAggregationData(e){const{weights:t,results:n,cellIndex:o,posIndex:r}=e;for(const e in t){const{values:a,size:s,operation:l}=t[e],{aggregationData:c}=n[e];for(let e=0;e<s;e++){const t=o+e,n=a[r*L+e];if(0===c[o+3])c[t]=n;else switch(l){case w.SUM:case w.MEAN:c[t]+=n;break;case w.MIN:c[t]=Math.min(c[t],n);break;case w.MAX:c[t]=Math.max(c[t],n);break;default:i.log.assert(!1)}}c[o+3]++}}calculateMeanMaxMinData(e){const{validCellIndices:t,results:n,weights:i}=e;t.forEach(e=>{for(const t in n){const{size:o,needMin:r,needMax:a,operation:s}=i[t],{aggregationData:l,minData:c,maxData:u,maxMinData:g}=n[t],h=r||a,d=s===w.MEAN,f=r&&a&&i[t].combineMaxMin,p=l[e+k-1];for(let t=0;t<o&&(h||d);t++){const n=e+t;let i=l[n];d&&(l[n]/=p,i=l[n]),f?g[t]=Math.max(g[t],i):(r&&(c[t]=Math.min(c[t],i)),a&&(u[t]=Math.max(u[t],i)))}f?g[k-1]=Math.min(g[k-1],l[e+0]):(r&&(c[k-1]+=p),a&&(u[k-1]+=p))}})}initCPUResults(e){const t=e.weights||this.state.weights,{numCol:n,numRow:i}=this.state,o={};for(const e in t){let{aggregationData:r,minData:a,maxData:s,maxMinData:l}=t[e];const{needMin:c,needMax:u}=t[e],g=c&&u&&t[e].combineMaxMin;r=X(r,n*i*k),g?((l=X(l,k)).fill(-1/0,0,k-1),l[k-1]=1/0):(c&&((a=X(a,k,1/0))[k-1]=0),u&&((s=X(s,k,-1/0))[k-1]=0)),o[e]=Object.assign({},t[e],{aggregationData:r,minData:a,maxData:s,maxMinData:l})}return o}runAggregationOnCPU(e){const{positions:t,cellSize:n,gridTransformMatrix:o,viewport:r,projectPoints:a}=e;let{weights:s}=e;const{numCol:l,numRow:c}=this.state,u=this.initCPUResults(e),g=this.shouldTransformToGrid(e);let h;const d=[0,0,0];let f;i.log.assert(g||e.changeFlags.cellSizeChanged),g?(f=t.length/2,h=new Float64Array(t.length),this.setState({gridPositions:h})):(h=this.state.gridPositions,s=this.state.weights,f=h.length/2);const p=new Set;for(let e=0;e<f;e++){let i,f;g?(d[0]=t[2*e],d[1]=t[2*e+1],[i,f]=a?r.project(d):C(d,o),h[2*e]=i,h[2*e+1]=f):(i=h[2*e],f=h[2*e+1]);const v=Math.floor(i/n[0]),m=Math.floor(f/n[1]);if(v>=0&&v<l&&m>=0&&m<c){const t=(v+m*l)*k;p.add(t),this.calculateAggregationData({weights:s,results:u,cellIndex:t,posIndex:e})}}return this.calculateMeanMaxMinData({validCellIndices:p,results:u,weights:s}),this.updateAggregationBuffers(e,u),u}updateAggregationBuffers(e,t){if(!e.createBufferObjects)return;const n=e.weights||this.state.weights;for(const e in t){const{aggregationData:i,minData:o,maxData:r,maxMinData:a}=t[e],{needMin:s,needMax:l}=n[e],c=s&&l&&n[e].combineMaxMin;Y({gl:this.gl,bufferName:"aggregationBuffer",data:i,result:t[e]}),c?Y({gl:this.gl,bufferName:"maxMinBuffer",data:a,result:t[e]}):(s&&Y({gl:this.gl,bufferName:"minBuffer",data:o,result:t[e]}),l&&Y({gl:this.gl,bufferName:"maxBuffer",data:r,result:t[e]}))}}getAggregateData(e){const t={},{textures:n,framebuffers:i,maxMinFramebuffers:o,minFramebuffers:s,maxFramebuffers:l,weights:c}=this.state;for(const e in c){t[e]={};const{needMin:u,needMax:g,combineMaxMin:h}=c[e];t[e].aggregationTexture=n[e],t[e].aggregationBuffer=Object(r.readPixelsToBuffer)(i[e],{target:c[e].aggregationBuffer,sourceType:a.a.FLOAT}),u&&g&&h?t[e].maxMinBuffer=Object(r.readPixelsToBuffer)(o[e],{target:c[e].maxMinBuffer,sourceType:a.a.FLOAT}):(u&&(t[e].minBuffer=Object(r.readPixelsToBuffer)(s[e],{target:c[e].minBuffer,sourceType:a.a.FLOAT})),g&&(t[e].maxBuffer=Object(r.readPixelsToBuffer)(l[e],{target:c[e].maxBuffer,sourceType:a.a.FLOAT})))}return t}getAggregationModel(e=!1){const{gl:t,shaderCache:n}=this;return new r.Model(t,{id:"Gird-Aggregation-Model",vs:e?R:B,fs:j,modules:e?["fp64","project64"]:["project32"],shaderCache:n,vertexCount:0,drawMode:a.a.POINTS})}getAllAggregationModel(e=!1){const{gl:t,shaderCache:n}=this;return new r.Model(t,{id:"All-Aggregation-Model",vs:I,fs:W,modules:["fp64"],shaderCache:n,vertexCount:1,drawMode:a.a.POINTS,isInstanced:!0,instanceCount:0,attributes:{position:new r.Buffer(t,{data:new Float32Array([0,0]),accessor:{size:2}})}})}getMeanTransform(e){return this.meanTransform?this.meanTransform.update(e):this.meanTransform=new r.Transform(this.gl,Object.assign({},{vs:V,_targetTextureVarying:"meanValues"},e)),this.meanTransform}renderAggregateData(e){const{cellSize:t,viewport:n,gridTransformMatrix:i,projectPoints:o}=e,{numCol:r,numRow:s,windowSize:l,maxMinFramebuffers:c,minFramebuffers:u,maxFramebuffers:g,weights:h}=this.state,d=q(i),f=[r,s],p={blend:!0,depthTest:!1,blendFunc:[a.a.ONE,a.a.ONE]},v={viewport:n},m={windowSize:l,cellSize:t,gridSize:f,uProjectionMatrix:i,uProjectionMatrixFP64:d,projectPoints:o};for(const e in h){const{needMin:t,needMax:n}=h[e],i=t&&n&&h[e].combineMaxMin;this.renderToWeightsTexture({id:e,parameters:p,moduleSettings:v,uniforms:m,gridSize:f}),i?this.renderToMaxMinTexture({id:e,parameters:Object.assign({},p,{blendEquation:T}),gridSize:f,minOrMaxFb:c[e],clearParams:{clearColor:[0,0,0,A]},combineMaxMin:i}):(t&&this.renderToMaxMinTexture({id:e,parameters:Object.assign({},p,{blendEquation:D}),gridSize:f,minOrMaxFb:u[e],clearParams:{clearColor:[A,A,A,0]},combineMaxMin:i}),n&&this.renderToMaxMinTexture({id:e,parameters:Object.assign({},p,{blendEquation:O}),gridSize:f,minOrMaxFb:g[e],combineMaxMin:i}))}}renderToMaxMinTexture(e){const{id:t,parameters:n,gridSize:i,minOrMaxFb:o,combineMaxMin:a,clearParams:s={}}=e,{framebuffers:l}=this.state,{gl:c,allAggregationModel:u}=this;o.bind(),c.viewport(0,0,i[0],i[1]),Object(r.withParameters)(c,s,()=>{c.clear(c.COLOR_BUFFER_BIT)}),u.draw({parameters:n,uniforms:{uSampler:l[t].texture,gridSize:i,combineMaxMin:a}}),o.unbind()}renderToWeightsTexture(e){const{id:t,parameters:n,moduleSettings:i,uniforms:o,gridSize:s}=e,{framebuffers:l,equations:c,weightAttributes:u,weights:g}=this.state,{gl:h,gridAggregationModel:d}=this,{operation:f}=g[t];l[t].bind(),h.viewport(0,0,s[0],s[1]);const p=f===w.MIN?[A,A,A,0]:[0,0,0,0];Object(r.withParameters)(h,{clearColor:p},()=>{h.clear(h.COLOR_BUFFER_BIT)});const v={weights:u[t]};if(d.draw({parameters:Object.assign({},n,{blendEquation:c[t]}),moduleSettings:i,uniforms:o,attributes:v}),l[t].unbind(),f===w.MEAN){const{meanTextures:e,textures:n}=this.state,i={_sourceTextures:{aggregationValues:e[t]},_targetTexture:n[t],elementCount:n[t].width*n[t].height};this.getMeanTransform(i).run({parameters:{blend:!1,depthTest:!1}}),l[t].attach({[a.a.COLOR_ATTACHMENT0]:n[t]})}}runAggregationOnGPU(e){return this.updateModels(e),this.setupFramebuffers(e),this.renderAggregateData(e),this.getAggregateData(e)}setupFramebuffers(e){const{numCol:t,numRow:n,textures:i,framebuffers:o,maxMinFramebuffers:r,minFramebuffers:s,maxFramebuffers:l,meanTextures:c,equations:u,weights:g}=this.state,h={width:t,height:n};for(const e in g){const{needMin:d,needMax:f,combineMaxMin:p,operation:v}=g[e];i[e]=g[e].aggregationTexture||i[e]||U(this.gl,{id:`${e}-texture`,width:t,height:n}),i[e].resize(h);let m=i[e];v===w.MEAN&&(c[e]=c[e]||U(this.gl,{id:`${e}-mean-texture`,width:t,height:n}),c[e].resize(h),m=c[e]),o[e]?o[e].attach({[a.a.COLOR_ATTACHMENT0]:m}):o[e]=G(this.gl,{id:`${e}-fb`,width:t,height:n,texture:m}),o[e].resize(h),u[e]=N[v],(d||f)&&(d&&f&&p?r[e]=r[e]||G(this.gl,{id:`${e}-maxMinFb`}):(d&&(s[e]=s[e]||G(this.gl,{id:`${e}-minFb`})),f&&(l[e]=l[e]||G(this.gl,{id:`${e}-maxFb`}))))}}setupModels(e=!1){this.gridAggregationModel&&this.gridAggregationModel.delete(),this.gridAggregationModel=this.getAggregationModel(e),this.allAggregationModel&&this.allAggregationModel.delete(),this.allAggregationModel=this.getAllAggregationModel(e)}setupWeightAttributes(e){const{weightAttributes:t,vertexCount:n,weights:o}=this.state;for(const e in o){const{values:a}=o[e];if(Array.isArray(a)||a.constructor===Float32Array){i.log.assert(a.length/3===n);const o=Array.isArray(a)?new Float32Array(a):a;t[e]instanceof r.Buffer?t[e].setData(o):t[e]=new r.Buffer(this.gl,o)}else i.log.assert(a instanceof r.Buffer),t[e]=a}}updateModels(e){const{gl:t}=this,{positions:n,positions64xyLow:o,changeFlags:a}=e,{numCol:s,numRow:l}=this.state;let{positionsBuffer:c,positions64xyLowBuffer:u}=this.state;const g={};let h=!1;if(e.fp64!==this.state.fp64&&(this.setupModels(e.fp64),this.setState({fp64:e.fp64}),e.fp64&&(h=!0)),a.dataChanged||!c){c&&c.delete();const i=n.length/2;c=new r.Buffer(t,new Float32Array(n)),h=e.fp64,Object.assign(g,{positions:c}),this.setState({positionsBuffer:c,vertexCount:i}),this.setupWeightAttributes(e),this.gridAggregationModel.setVertexCount(i)}h&&(i.log.assert(o),u&&u.delete(),u=new r.Buffer(t,{size:2,data:new Float32Array(o)}),Object.assign(g,{positions64xyLow:u}),this.setState({positions64xyLowBuffer:u})),this.gridAggregationModel.setAttributes(g),(a.cellSizeChanged||a.viewportChanged)&&this.allAggregationModel.setInstanceCount(s*l)}}var $="#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nin vec3 positions;\nin vec3 instancePositions;\nin vec4 instanceCounts;\nin vec3 instancePickingColors;\n\nlayout(std140) uniform;\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform AggregationData\n{\n  vec4 maxCount;\n} aggregationData;\n\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\n\nout vec4 vColor;\nout float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r ;\n  float maxWeight = aggregationData.maxCount.r;\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",Z="#define SHADER_NAME screen-grid-layer-vertex-shader-webgl1\n#define RANGE_COUNT 6\n\nattribute vec3 positions;\nattribute vec3 instancePositions;\nattribute vec4 instanceCounts;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform float maxWeight;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\n  vec4 outColor = vec4(0., 0., 0., 0.);\n  if (value >= domain.x && value <= domain.y) {\n    float domainRange = domain.y - domain.x;\n    if (domainRange <= 0.) {\n      outColor = colorRange[0];\n    } else {\n      float rangeCount = float(RANGE_COUNT);\n      float rangeStep = domainRange / rangeCount;\n      float idx = floor((value - domain.x) / rangeStep);\n      idx = clamp(idx, 0., rangeCount - 1.);\n      int intIdx = int(idx);\n      outColor = colorRange[intIdx];\n    }\n  }\n  outColor = outColor / 255.;\n  return outColor;\n}\n\nvoid main(void) {\n  vSampleCount = instanceCounts.a;\n\n  float weight = instanceCounts.r;\n  float step = weight / maxWeight;\n  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\n\n  vec2 domain = colorDomain;\n  float domainMaxValid = float(colorDomain.y != 0.);\n  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\n  vec4 rangeColor = quantizeScale(domain, colorRange, weight);\n\n  float rangeMinMax = float(shouldUseMinMax);\n  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\n  vColor = vec4(color.rgb, color.a * opacity);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  gl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n",Q="#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nin vec4 vColor;\nin float vSampleCount;\nout vec4 fragColor;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  fragColor = vColor;\n\n  fragColor = picking_filterColor(fragColor);\n}\n",K="#define SHADER_NAME screen-grid-layer-fragment-shader-webgl1\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float vSampleCount;\n\nvoid main(void) {\n  if (vSampleCount <= 0.0) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  gl_FragColor = picking_filterColor(gl_FragColor);\n}\n";const{count:J}=i.experimental,ee=[0,0,0,0],te=[0,255,0,255],ne=0,ie=["minColor","maxColor","colorRange","colorDomain"],oe={cellSizePixels:{value:100,min:1},cellMarginPixels:{value:2,min:0,max:5},colorDomain:null,colorRange:o,getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:e=>[1,0,0]},gpuAggregation:!0,aggregation:"SUM"};class re extends i.Layer{getShaders(){const e=Object(r.isWebGL2)(this.context.gl)?{vs:$,fs:Q}:{vs:Z,fs:K};return e.modules=["picking"],e}initializeState(){const e=this.getAttributeManager(),{gl:t}=this.context;e.addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,transition:!0,accessor:["getPosition","getWeight"],update:this.calculateInstanceCounts,noAlloc:!0}});const n={id:`${this.id}-aggregator`,shaderCache:this.context.shaderCache},i=this._getMaxCountBuffer(t),o={color:{size:1,operation:w.SUM,needMax:!0,maxBuffer:i}};this.setState({model:this._getModel(t),gpuGridAggregator:new H(t,n),maxBuffer:i,weights:o,aggregationResults:null}),this._setupUniformBuffer()}shouldUpdateState({changeFlags:e}){return e.somethingChanged}updateState(e){super.updateState(e),this._updateUniforms(e),e.changeFlags.dataChanged&&this._processData();const t=this._getAggregationChangeFlags(e);t&&this._updateAggregation(t)}draw({uniforms:e}){const{gl:t}=this.context,{parameters:n={}}=this.props,i=this.props.minColor||ee,o=this.props.maxColor||te,s=this.props.colorDomain||[1,0],{model:l,maxBuffer:c,cellScale:u,shouldUseMinMax:g,colorRange:h,maxWeight:d}=this.state,f={minColor:i,maxColor:o,cellScale:u,colorRange:h,colorDomain:s,shouldUseMinMax:g};Object(r.isWebGL2)(t)?c.bind({target:a.a.UNIFORM_BUFFER}):f.maxWeight=d,e=Object.assign(f,e),l.draw({uniforms:e,parameters:Object.assign({depthTest:!1,depthMask:!1},n)}),Object(r.isWebGL2)(t)&&c.unbind()}calculateInstancePositions(e,{numInstances:t}){const{width:n,height:i}=this.context.viewport,{cellSizePixels:o}=this.props,{numCol:r}=this.state,{value:a,size:s}=e;for(let e=0;e<t;e++){const t=e%r,l=Math.floor(e/r);a[e*s+0]=t*o/n*2-1,a[e*s+1]=1-l*o/i*2,a[e*s+2]=0}}calculateInstanceCounts(e,{numInstances:t}){const{aggregationBuffer:n}=this.state;e.update({buffer:n})}getPickingInfo({info:e,mode:t}){const{index:n}=e;if(n>=0){const{aggregationResults:t}=this.state;t.aggregationData=t.aggregationData||this.state.aggregationBuffer.getData(),t.maxData=t.maxData||this.state.maxBuffer.getData();const{aggregationData:i,maxData:o}=t;e.object=H.getAggregationData({aggregationData:i,maxData:o,pixelIndex:n})}return e}_getAggregationChangeFlags({oldProps:e,props:t,changeFlags:n}){const i=t.cellSizePixels!==e.cellSizePixels||t.cellMarginPixels!==e.cellMarginPixels,o=n.dataChanged||t.aggregation!==e.aggregation,r=n.viewportChanged;return i||o||r?{cellSizeChanged:i,dataChanged:o,viewportChanged:r}:null}_getModel(e){return new r.Model(e,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new r.Geometry({drawMode:a.a.TRIANGLE_FAN,attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,1,0])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}_getMaxCountBuffer(e){return new r.Buffer(e,{byteLength:16,index:ne,accessor:{size:4}})}_processData(){const{data:e,getPosition:t,getWeight:n}=this.props,o=J(e),r=new Float64Array(2*o),a=new Float32Array(3*o),{weights:s}=this.state,{iterable:l,objectInfo:c}=Object(i.createIterable)(e);for(const e of l){c.index++;const i=t(e,c),o=n(e,c),{index:s}=c;r[2*s]=i[0],r[2*s+1]=i[1],Array.isArray(o)?(a[3*s]=o[0],a[3*s+1]=o[1],a[3*s+2]=o[2]):a[3*s]=o}s.color.values=a,this.setState({positions:r})}_setupUniformBuffer(){const e=this.context.gl;if(!Object(r.isWebGL2)(e))return;const t=this.state.model.program.handle,n=e.getUniformBlockIndex(t,"AggregationData");e.uniformBlockBinding(t,n,ne)}_shouldUseMinMax(){const{minColor:e,maxColor:t,colorDomain:n,colorRange:o}=this.props;return e||t?(i.log.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!n&&!o}_updateAggregation(e){const t=this.getAttributeManager();(e.cellSizeChanged||e.viewportChanged)&&(this._updateGridParams(),t.invalidateAll());const{cellSizePixels:n,gpuAggregation:o}=this.props,{positions:r,weights:a}=this.state,{viewport:s}=this.context;a.color.operation=w[this.props.aggregation.toUpperCase()]||w.SUM;let l=!1,c=null;this.context.viewport instanceof i.WebMercatorViewport?l=!0:(l=!1,c=s.pixelProjectionMatrix);const u=this.state.gpuGridAggregator.run({positions:r,weights:a,cellSize:[n,n],viewport:s,changeFlags:e,useGPU:o,projectPoints:l,gridTransformMatrix:c}),g=u.color.maxData&&Number.isFinite(u.color.maxData[0])?u.color.maxData[0]:0,h={aggregationData:u.color.aggregationData,maxData:u.color.maxData};this.setState({aggregationResults:h,maxWeight:g}),t.invalidate("instanceCounts")}_updateUniforms({oldProps:e,props:t,changeFlags:n}){const i={};if(ie.some(n=>e[n]!==t[n])&&(i.shouldUseMinMax=this._shouldUseMinMax()),e.colorRange!==t.colorRange){const e=[];t.colorRange.forEach(t=>{e.push(t[0],t[1],t[2],t[3]||255)}),i.colorRange=e}if(e.cellMarginPixels!==t.cellMarginPixels||e.cellSizePixels!==t.cellSizePixels||n.viewportChanged){const{width:e,height:t}=this.context.viewport,{cellSizePixels:n,cellMarginPixels:o}=this.props,r=n>o?o:0;i.cellScale=new Float32Array([(n-r)/e*2,-(n-r)/t*2,1])}this.setState(i)}_updateGridParams(){const{width:e,height:t}=this.context.viewport,{cellSizePixels:n}=this.props,{gl:i}=this.context,o=Math.ceil(e/n),s=Math.ceil(t/n),l=o*s,c=4*l*4;let u=this.state.aggregationBuffer;u&&u.delete(),u=new r.Buffer(i,{byteLength:c,accessor:{size:4,type:a.a.FLOAT,divisor:1}}),this.state.weights.color.aggregationBuffer=u,this.setState({numCol:o,numRow:s,numInstances:l,aggregationBuffer:u})}}re.layerName="ScreenGridLayer",re.defaultProps=oe;const ae=e=>e.length;class se{constructor(e=[],t=ae){this.sortedBins=this.getSortedBins(e,t),this.maxCount=this.getMaxCount(),this.binMap=this.getBinMap()}getSortedBins(e,t){return e.reduce((e,n,i)=>{const o=t(n.points);return null!=o&&e.push({i:Number.isFinite(n.index)?n.index:i,value:o,counts:n.points.length}),e},[]).sort((e,t)=>e.value-t.value)}getValueRange([e,t]){const n=this.sortedBins.length;if(!n)return[0,0];const i=Math.ceil(e/100*(n-1)),o=Math.floor(t/100*(n-1));return[this.sortedBins[i].value,this.sortedBins[o].value]}getMaxCount(){let e=0;return this.sortedBins.forEach(t=>e=e>t.counts?e:t.counts),e}getBinMap(){return this.sortedBins.reduce((e,t)=>Object.assign(e,{[t.i]:t}),{})}}function le(e,t,n){const o=e[1]-e[0];if(o<=0)return i.log.warn("quantizeScale: invalid domain, returning range[0]")(),t[0];const r=o/t.length,a=Math.floor((n-e[0])/r);return t[Math.max(Math.min(a,t.length-1),0)]}function ce(e,t){return n=>le(e,t,n)}function ue(e,t){return n=>(n-e[0])/(e[1]-e[0])*(t[1]-t[0])+t[0]}const ge=6378e3;function he(e,t,n){const{gridHash:i,gridOffset:o}=function(e=[],t,n){let i,o=1/0,r=-1/0;for(const t of e)i=n(t)[1],Number.isFinite(i)&&(o=i<o?i:o,r=i>r?i:r);const a=function(e,t){const n=(a=e,a/ge*(180/Math.PI)),i=(o=t,r=e,r/ge*(180/Math.PI)/Math.cos(o*Math.PI/180));var o,r;var a;return{yOffset:n,xOffset:i}}(t,(o+r)/2);if(a.xOffset<=0||a.yOffset<=0)return{gridHash:{},gridOffset:a};const s={};for(const t of e){const[e,i]=n(t);if(Number.isFinite(i)&&Number.isFinite(e)){const n=Math.floor((i+90)/a.yOffset),o=Math.floor((e+180)/a.xOffset),r=`${n}-${o}`;s[r]=s[r]||{count:0,points:[]},s[r].count+=1,s[r].points.push(t)}}return{gridHash:s,gridOffset:a}}(e,t,n);return{gridOffset:o,layerData:function(e,t){return Object.keys(e).reduce((n,i,o)=>{const r=i.split("-"),a=parseInt(r[0],10),s=parseInt(r[1],10);return n.push(Object.assign({index:o,position:[t.xOffset*s-180,t.yOffset*a-90]},e[i])),n},[])}(i,o)}}function de(){}const fe={colorDomain:null,colorRange:o,getColorValue:{type:"accessor",value:e=>e.length},lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},onSetColorDomain:de,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:e=>e.length},elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScale:1,onSetElevationDomain:de,cellSize:{type:"number",min:0,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},extruded:!1,fp64:!1,material:new r.PhongMaterial};class pe extends i.CompositeLayer{initializeState(){this.state={layerData:[],sortedColorBins:null,sortedElevationBins:null,colorValueDomain:null,elevationValueDomain:null,colorScaleFunc:de,elevationScaleFunc:de,dimensionUpdaters:this.getDimensionUpdaters()}}updateState({oldProps:e,props:t,changeFlags:n}){const i=this.needsReProjectPoints(e,t,n);if(n.dataChanged||i)this.getLayerData();else{(this.getDimensionChanges(e,t)||[]).forEach(e=>"function"==typeof e&&e.apply(this))}}needsReProjectPoints(e,t,n){return e.cellSize!==t.cellSize||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPosition)}getDimensionUpdaters(){return{getColor:[{id:"value",triggers:["getColorValue"],updater:this.getSortedColorBins},{id:"domain",triggers:["lowerPercentile","upperPercentile"],updater:this.getColorValueDomain},{id:"scaleFunc",triggers:["colorDomain","colorRange"],updater:this.getColorScale}],getElevation:[{id:"value",triggers:["getElevationValue"],updater:this.getSortedElevationBins},{id:"domain",triggers:["elevationLowerPercentile","elevationUpperPercentile"],updater:this.getElevationValueDomain},{id:"scaleFunc",triggers:["elevationDomain","elevationRange"],updater:this.getElevationScale}]}}getDimensionChanges(e,t){const{dimensionUpdaters:n}=this.state,i=[];for(const o in n){const r=n[o].find(n=>n.triggers.some(n=>e[n]!==t[n]));r&&i.push(r.updater)}return i.length?i:null}getPickingInfo({info:e}){const{sortedColorBins:t,sortedElevationBins:n}=this.state;let i=null;if(e.picked&&e.index>-1){const o=this.state.layerData[e.index],r=t.binMap[o.index]&&t.binMap[o.index].value,a=n.binMap[o.index]&&n.binMap[o.index].value;i=Object.assign({colorValue:r,elevationValue:a},o)}return Object.assign(e,{picked:Boolean(i),object:i})}getUpdateTriggers(){const{dimensionUpdaters:e}=this.state,t={};for(const n in e){t[n]={};for(const i of e[n])i.triggers.forEach(e=>{t[n][e]=this.props[e]})}return t}getLayerData(){const{data:e,cellSize:t,getPosition:n}=this.props,{layerData:i}=he(e,t,n);this.setState({layerData:i}),this.getSortedBins()}getValueDomain(){this.getColorValueDomain(),this.getElevationValueDomain()}getSortedBins(){this.getSortedColorBins(),this.getSortedElevationBins()}getSortedColorBins(){const{getColorValue:e}=this.props,t=new se(this.state.layerData||[],e);this.setState({sortedColorBins:t}),this.getColorValueDomain()}getSortedElevationBins(){const{getElevationValue:e}=this.props,t=new se(this.state.layerData||[],e);this.setState({sortedElevationBins:t}),this.getElevationValueDomain()}getColorValueDomain(){const{lowerPercentile:e,upperPercentile:t,onSetColorDomain:n}=this.props;this.state.colorValueDomain=this.state.sortedColorBins.getValueRange([e,t]),"function"==typeof n&&n(this.state.colorValueDomain),this.getColorScale()}getElevationValueDomain(){const{elevationLowerPercentile:e,elevationUpperPercentile:t,onSetElevationDomain:n}=this.props;this.state.elevationValueDomain=this.state.sortedElevationBins.getValueRange([e,t]),"function"==typeof n&&n(this.state.elevationValueDomain),this.getElevationScale()}getColorScale(){const{colorRange:e}=this.props,t=this.props.colorDomain||this.state.colorValueDomain;this.state.colorScaleFunc=ce(t,e)}getElevationScale(){const{elevationRange:e}=this.props,t=this.props.elevationDomain||this.state.elevationValueDomain;this.state.elevationScaleFunc=ue(t,e)}_onGetSublayerColor(e){const{sortedColorBins:t,colorScaleFunc:n,colorValueDomain:i}=this.state,o=t.binMap[e.index]&&t.binMap[e.index].value,r=this.props.colorDomain||i,a=o>=r[0]&&o<=r[r.length-1]?n(o):[0,0,0,0];return a[3]=Number.isFinite(a[3])?a[3]:255,a}_onGetSublayerElevation(e){const{sortedElevationBins:t,elevationScaleFunc:n,elevationValueDomain:i}=this.state,o=t.binMap[e.index]&&t.binMap[e.index].value,r=this.props.elevationDomain||i;return o>=r[0]&&o<=r[r.length-1]?n(o):-1}renderLayers(){const{elevationScale:e,fp64:t,extruded:n,cellSize:o,coverage:r,material:a,transitions:s}=this.props;return new(this.getSubLayerClass("grid-cell",i.GridCellLayer))({fp64:t,cellSize:o,coverage:r,material:a,elevationScale:e,extruded:n,getColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:s&&{getColor:s.getColorValue,getElevation:s.getElevationValue}},this.getSubLayerProps({id:"grid-cell",updateTriggers:this.getUpdateTriggers()}),{data:this.state.layerData})}}pe.layerName="GridLayer",pe.defaultProps=fe;var ve=Math.PI/3,me=[0,ve,2*ve,3*ve,4*ve,5*ve];function xe(e){return e[0]}function ye(e){return e[1]}var Se=function(){var e,t,n,i=0,o=0,r=1,a=1,s=xe,l=ye;function c(e){var i,o={},r=[],a=e.length;for(i=0;i<a;++i)if(!isNaN(u=+s.call(null,c=e[i],i,e))&&!isNaN(g=+l.call(null,c,i,e))){var c,u,g,h=Math.round(g/=n),d=Math.round(u=u/t-(1&h)/2),f=g-h;if(3*Math.abs(f)>1){var p=u-d,v=d+(u<d?-1:1)/2,m=h+(g<h?-1:1),x=u-v,y=g-m;p*p+f*f>x*x+y*y&&(d=v+(1&h?1:-1)/2,h=m)}var S=d+"-"+h,M=o[S];M?M.push(c):(r.push(M=o[S]=[c]),M.x=(d+(1&h)/2)*t,M.y=h*n)}return r}function u(e){var t=0,n=0;return me.map(function(i){var o=Math.sin(i)*e,r=-Math.cos(i)*e,a=o-t,s=r-n;return t=o,n=r,[a,s]})}return c.hexagon=function(t){return"m"+u(null==t?e:+t).join("l")+"z"},c.centers=function(){for(var s=[],l=Math.round(o/n),c=Math.round(i/t),u=l*n;u<a+e;u+=n,++l)for(var g=c*t+(1&l)*t/2;g<r+t/2;g+=t)s.push([g,u]);return s},c.mesh=function(){var t=u(e).slice(0,4).join("l");return c.centers().map(function(e){return"M"+e+"m"+t}).join("")},c.x=function(e){return arguments.length?(s=e,c):s},c.y=function(e){return arguments.length?(l=e,c):l},c.radius=function(i){return arguments.length?(t=2*(e=+i)*Math.sin(ve),n=1.5*e,c):e},c.size=function(e){return arguments.length?(i=o=0,r=+e[0],a=+e[1],c):[r-i,a-o]},c.extent=function(e){return arguments.length?(i=+e[0][0],o=+e[0][1],r=+e[1][0],a=+e[1][1],c):[[i,o],[r,a]]},c.radius(1)};function Me(){}const be={colorDomain:null,colorRange:o,getColorValue:{type:"accessor",value:e=>e.length},lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},onSetColorDomain:Me,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:e=>e.length},elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},onSetElevationDomain:Me,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:function({data:e,radius:t,getPosition:n},o){const r=function(e,t){const{pixelsPerMeter:n}=t.getDistanceScales();return e*n[0]}(t,o),a=[],{iterable:s,objectInfo:l}=Object(i.createIterable)(e);for(const e of s)l.index++,a.push(Object.assign({screenCoord:o.projectFlat(n(e,l))},e));return{hexagons:Se().radius(r).x(e=>e.screenCoord[0]).y(e=>e.screenCoord[1])(a).map((e,t)=>({position:o.unprojectFlat([e.x,e.y]),points:e,index:t}))}},getPosition:{type:"accessor",value:e=>e.position},fp64:!1,material:new r.PhongMaterial};class Ce extends i.CompositeLayer{initializeState(){this.state={hexagons:[],sortedColorBins:null,sortedElevationBins:null,colorValueDomain:null,elevationValueDomain:null,colorScaleFunc:Me,elevationScaleFunc:Me,dimensionUpdaters:this.getDimensionUpdaters()}}updateState({oldProps:e,props:t,changeFlags:n}){const i=this.getDimensionChanges(e,t);n.dataChanged||this.needsReProjectPoints(e,t)?this.getHexagons():i&&i.forEach(e=>"function"==typeof e&&e.apply(this))}needsReProjectPoints(e,t){return e.radius!==t.radius||e.hexagonAggregator!==t.hexagonAggregator}getDimensionUpdaters(){return{getColor:[{id:"value",triggers:["getColorValue"],updater:this.getSortedColorBins},{id:"domain",triggers:["lowerPercentile","upperPercentile"],updater:this.getColorValueDomain},{id:"scaleFunc",triggers:["colorDomain","colorRange"],updater:this.getColorScale}],getElevation:[{id:"value",triggers:["getElevationValue"],updater:this.getSortedElevationBins},{id:"domain",triggers:["elevationLowerPercentile","elevationUpperPercentile"],updater:this.getElevationValueDomain},{id:"scaleFunc",triggers:["elevationDomain","elevationRange"],updater:this.getElevationScale}]}}getDimensionChanges(e,t){const{dimensionUpdaters:n}=this.state,i=[];for(const o in n){const r=n[o].find(n=>n.triggers.some(n=>e[n]!==t[n]));r&&i.push(r.updater)}return i.length?i:null}getHexagons(){const{hexagonAggregator:e}=this.props,{viewport:t}=this.context,{hexagons:n,hexagonVertices:i}=e(this.props,t);this.updateRadiusAngle(i),this.setState({hexagons:n}),this.getSortedBins()}getPickingInfo({info:e}){const{sortedColorBins:t,sortedElevationBins:n}=this.state;let i=null;if(e.picked&&e.index>-1){const o=this.state.hexagons[e.index],r=t.binMap[o.index]&&t.binMap[o.index].value,a=n.binMap[o.index]&&n.binMap[o.index].value;i=Object.assign({colorValue:r,elevationValue:a},o)}return Object.assign(e,{picked:Boolean(i),object:i})}getUpdateTriggers(){const{dimensionUpdaters:e}=this.state,t={};for(const n in e){t[n]={};for(const i of e[n])i.triggers.forEach(e=>{t[n][e]=this.props[e]})}return t}updateRadiusAngle(e){let{radius:t}=this.props,n=90;if(Array.isArray(e)){e.length<6&&i.log.error("HexagonCellLayer: hexagonVertices needs to be an array of 6 points")();const o=e[0],r=e[3],{viewport:a}=this.context,{pixelsPerMeter:s}=a.getDistanceScales(),l=this.projectFlat(o),c=this.projectFlat(r),u=l[0]-c[0],g=l[1]-c[1],h=Math.sqrt(u*u+g*g);n=Math.acos(u/h)*-Math.sign(g)/Math.PI*180+90,t=h/2/s[0]}this.setState({angle:n,radius:t})}getValueDomain(){this.getColorValueDomain(),this.getElevationValueDomain()}getSortedBins(){this.getSortedColorBins(),this.getSortedElevationBins()}getSortedColorBins(){const{getColorValue:e}=this.props,t=new se(this.state.hexagons||[],e);this.setState({sortedColorBins:t}),this.getColorValueDomain()}getSortedElevationBins(){const{getElevationValue:e}=this.props,t=new se(this.state.hexagons||[],e);this.setState({sortedElevationBins:t}),this.getElevationValueDomain()}getColorValueDomain(){const{lowerPercentile:e,upperPercentile:t,onSetColorDomain:n}=this.props;e>t&&i.log.warn("HexagonLayer: lowerPercentile is bigger than upperPercentile")(),this.state.colorValueDomain=this.state.sortedColorBins.getValueRange([e,t]),"function"==typeof n&&n(this.state.colorValueDomain),this.getColorScale()}getElevationValueDomain(){const{elevationLowerPercentile:e,elevationUpperPercentile:t,onSetElevationDomain:n}=this.props;this.state.elevationValueDomain=this.state.sortedElevationBins.getValueRange([e,t]),"function"==typeof n&&n(this.state.elevationValueDomain),this.getElevationScale()}getColorScale(){const{colorRange:e}=this.props,t=this.props.colorDomain||this.state.colorValueDomain;this.state.colorScaleFunc=ce(t,e)}getElevationScale(){const{elevationRange:e}=this.props,t=this.props.elevationDomain||this.state.elevationValueDomain;this.state.elevationScaleFunc=ue(t,e)}_onGetSublayerColor(e){const{sortedColorBins:t,colorScaleFunc:n,colorValueDomain:i}=this.state,o=t.binMap[e.index]&&t.binMap[e.index].value,r=this.props.colorDomain||i,a=o>=r[0]&&o<=r[r.length-1]?n(o):[0,0,0,0];return a[3]=Number.isFinite(a[3])?a[3]:255,a}_onGetSublayerElevation(e){const{sortedElevationBins:t,elevationScaleFunc:n,elevationValueDomain:i}=this.state,o=t.binMap[e.index]&&t.binMap[e.index].value,r=this.props.elevationDomain||i;return o>=r[0]&&o<=r[r.length-1]?n(o):-1}renderLayers(){const{elevationScale:e,extruded:t,coverage:n,material:o,fp64:r,transitions:a}=this.props,{angle:s,radius:l}=this.state;return new(this.getSubLayerClass("hexagon-cell",i.ColumnLayer))({fp64:r,radius:l,diskResolution:6,elevationScale:e,angle:s,extruded:t,coverage:n,material:o,getColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:a&&{getColor:a.getColorValue,getElevation:a.getElevationValue}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:this.getUpdateTriggers()}),{data:this.state.hexagons})}}Ce.layerName="HexagonLayer",Ce.defaultProps=be;var we={};function Ee(e){if(!Number.isFinite(e))throw new Error("Invalid number ".concat(e));return e}function Pe(e){return Math.round(e/we.EPSILON)*we.EPSILON}function Ae(e){var t=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).precision,n=void 0===t?we.precision||4:t;return e=Pe(e),parseFloat(e.toPrecision(n))}function De(e){return Array.isArray(e)||ArrayBuffer.isView(e)&&void 0!==e.length}function Oe(e,t){if(De(e)&&De(t)){if(e===t)return!0;if(e.length!==t.length)return!1;for(var n=0;n<e.length;++n)if(!Oe(e[n],t[n]))return!1;return!0}return Math.abs(e-t)<=we.EPSILON*Math.max(1,Math.abs(e),Math.abs(t))}we.EPSILON=1e-12,we.debug=!0,we.precision=4,we.printTypes=!1,we.printDegrees=!1,we.printRowMajor=!0;const Te={N:[0,.5],E:[.5,0],S:[0,-.5],W:[-.5,0],NE:[.5,.5],NW:[-.5,.5],SE:[.5,-.5],SW:[-.5,-.5]},Ne=[Te.W,Te.SW,Te.S],ke=[Te.S,Te.SE,Te.E],ze=[Te.E,Te.NE,Te.N],_e=[Te.NW,Te.W,Te.N],Fe=[[-.5,1/6],[-.5,-1/6],[-1/6,-.5],[1/6,-.5]],Le=[[-1/6,-.5],[1/6,-.5],[.5,-1/6],[.5,1/6]],Be=[[.5,-1/6],[.5,1/6],[1/6,.5],[-1/6,.5]],Re=[[-.5,1/6],[-.5,-1/6],[1/6,.5],[-1/6,.5]],je=[Te.W,Te.SW,Te.SE,Te.E],Ie=[Te.S,Te.SE,Te.NE,Te.N],We=[Te.NW,Te.W,Te.E,Te.NE],Ve=[Te.NW,Te.SW,Te.S,Te.N],Ue=[[-.5,1/6],[-.5,-1/6],[.5,-1/6],[.5,1/6]],Ge=[[-1/6,-.5],[1/6,-.5],[1/6,.5],[-1/6,.5]],Xe=[Te.NW,Te.SW,Te.SE,Te.NE],Ye=[Te.NW,Te.SW,Te.SE,Te.E,Te.N],qe=[Te.W,Te.SW,Te.SE,Te.NE,Te.N],He=[Te.NW,Te.W,Te.S,Te.SE,Te.NE],$e=[Te.NW,Te.SW,Te.S,Te.E,Te.NE],Ze=[Te.NW,Te.W,[.5,-1/6],[.5,1/6],Te.N],Qe=[[-1/6,-.5],[1/6,-.5],Te.E,Te.NE,Te.N],Ke=[[-.5,1/6],[-.5,-1/6],Te.S,Te.SE,Te.E],Je=[Te.W,Te.SW,Te.S,[1/6,.5],[-1/6,.5]],et=[Te.NW,Te.W,[-1/6,-.5],[1/6,-.5],Te.N],tt=[[-.5,1/6],[-.5,-1/6],Te.E,Te.NE,Te.N],nt=[Te.S,Te.SE,Te.E,[1/6,.5],[-1/6,.5]],it=[Te.W,Te.SW,Te.S,[.5,-1/6],[.5,1/6]],ot=[Te.W,Te.SW,Te.SE,Te.E,[1/6,.5],[-1/6,.5]],rt=[[-.5,1/6],[-.5,-1/6],Te.S,Te.SE,Te.NE,Te.N],at=[Te.NW,Te.W,[-1/6,-.5],[1/6,-.5],Te.E,Te.NE],st=[Te.NW,Te.SW,Te.S,[.5,-1/6],[.5,1/6],Te.N],lt=[Te.W,Te.SW,Te.S,Te.E,Te.NE,Te.N],ct=[Te.NW,Te.W,Te.S,Te.SE,Te.E,Te.N],ut=[[-.5,1/6],[-.5,-1/6],[-1/6,-.5],[1/6,-.5],Te.E,Te.NE,Te.N],gt=[Te.W,Te.SW,Te.S,[.5,-1/6],[.5,1/6],[1/6,.5],[-1/6,.5]],ht=[Te.NW,Te.W,[-1/6,-.5],[1/6,-.5],[.5,-1/6],[.5,1/6],Te.N],dt=[[-.5,1/6],[-.5,-1/6],Te.S,Te.SE,Te.E,[1/6,.5],[-1/6,.5]],ft=[[-.5,1/6],[-.5,-1/6],[-1/6,-.5],[1/6,-.5],[.5,-1/6],[.5,1/6],[1/6,.5],[-1/6,.5]],pt={0:[],1:[[Te.W,Te.S]],2:[[Te.S,Te.E]],3:[[Te.W,Te.E]],4:[[Te.N,Te.E]],5:{0:[[Te.W,Te.S],[Te.N,Te.E]],1:[[Te.W,Te.N],[Te.S,Te.E]]},6:[[Te.N,Te.S]],7:[[Te.W,Te.N]],8:[[Te.W,Te.N]],9:[[Te.N,Te.S]],10:{0:[[Te.W,Te.N],[Te.S,Te.E]],1:[[Te.W,Te.S],[Te.N,Te.E]]},11:[[Te.N,Te.E]],12:[[Te.W,Te.E]],13:[[Te.S,Te.E]],14:[[Te.W,Te.S]],15:[]};function vt(e){return parseInt(e,4)}const mt={[vt("0000")]:[],[vt("2222")]:[],[vt("2221")]:[Ne],[vt("2212")]:[ke],[vt("2122")]:[ze],[vt("1222")]:[_e],[vt("0001")]:[Ne],[vt("0010")]:[ke],[vt("0100")]:[ze],[vt("1000")]:[_e],[vt("2220")]:[Fe],[vt("2202")]:[Le],[vt("2022")]:[Be],[vt("0222")]:[Re],[vt("0002")]:[Fe],[vt("0020")]:[Le],[vt("0200")]:[Be],[vt("2000")]:[Re],[vt("0011")]:[je],[vt("0110")]:[Ie],[vt("1100")]:[We],[vt("1001")]:[Ve],[vt("2211")]:[je],[vt("2112")]:[Ie],[vt("1122")]:[We],[vt("1221")]:[Ve],[vt("2200")]:[Ue],[vt("2002")]:[Ge],[vt("0022")]:[Ue],[vt("0220")]:[Ge],[vt("1111")]:[Xe],[vt("1211")]:[Ye],[vt("2111")]:[qe],[vt("1112")]:[He],[vt("1121")]:[$e],[vt("1011")]:[Ye],[vt("0111")]:[qe],[vt("1110")]:[He],[vt("1101")]:[$e],[vt("1200")]:[Ze],[vt("0120")]:[Qe],[vt("0012")]:[Ke],[vt("2001")]:[Je],[vt("1022")]:[Ze],[vt("2102")]:[Qe],[vt("2210")]:[Ke],[vt("0221")]:[Je],[vt("1002")]:[et],[vt("2100")]:[tt],[vt("0210")]:[nt],[vt("0021")]:[it],[vt("1220")]:[et],[vt("0122")]:[tt],[vt("2012")]:[nt],[vt("2201")]:[it],[vt("0211")]:[ot],[vt("2110")]:[rt],[vt("1102")]:[at],[vt("1021")]:[st],[vt("2011")]:[ot],[vt("0112")]:[rt],[vt("1120")]:[at],[vt("1201")]:[st],[vt("2101")]:[lt],[vt("0121")]:[lt],[vt("1012")]:[ct],[vt("1210")]:[ct],[vt("0101")]:{0:[Ne,ze],1:[lt],2:[lt]},[vt("1010")]:{0:[_e,ke],1:[ct],2:[ct]},[vt("2121")]:{0:[lt],1:[lt],2:[Ne,ze]},[vt("1212")]:{0:[ct],1:[ct],2:[_e,ke]},[vt("2120")]:{0:[ut],1:[ut],2:[Fe,ze]},[vt("2021")]:{0:[gt],1:[gt],2:[Ne,Be]},[vt("1202")]:{0:[ht],1:[ht],2:[_e,Le]},[vt("0212")]:{0:[dt],1:[dt],2:[ke,Re]},[vt("0102")]:{0:[Fe,ze],1:[ut],2:[ut]},[vt("0201")]:{0:[Ne,Be],1:[gt],2:[gt]},[vt("1020")]:{0:[_e,Le],1:[ht],2:[ht]},[vt("2010")]:{0:[ke,Re],1:[dt],2:[dt]},[vt("2020")]:{0:[Re,Le],1:[ft],2:[Fe,Be]},[vt("0202")]:{0:[Be,Fe],1:[ft],2:[Re,Le]}},xt={ISO_LINES:1,ISO_BANDS:2},yt={zIndex:0,zOffset:.005};function St(e,t){return Array.isArray(t)?e<t[0]?0:e<t[1]?1:2:e>=t?1:0}function Mt(e){const{cellWeights:t,x:n,y:o,width:r,height:a}=e;let s=e.threshold;e.thresholdValue&&(i.log.deprecated("thresholdValue","threshold")(),s=e.thresholdValue);const l=n<0,c=n>=r-1,u=o<0,g=o>=a-1,h=l||c||u||g,d={},f={};l||g?f.top=0:(d.top=t[(o+1)*r+n],f.top=St(d.top,s)),c||g?f.topRight=0:(d.topRight=t[(o+1)*r+n+1],f.topRight=St(d.topRight,s)),c||u?f.right=0:(d.right=t[o*r+n+1],f.right=St(d.right,s)),l||u?f.current=0:(d.current=t[o*r+n],f.current=St(d.current,s));const{top:p,topRight:v,right:m,current:x}=f;let y=-1;Number.isFinite(s)&&(y=p<<3|v<<2|m<<1|x),Array.isArray(s)&&(y=p<<6|v<<4|m<<2|x);let S=0;return h||(S=St((d.top+d.topRight+d.right+d.current)/4,s)),{code:y,meanCode:S}}function bt(e){const{gridOrigin:t,cellSize:n,x:i,y:o,code:r,meanCode:a,type:s=xt.ISO_LINES}=e,l=Object.assign({},yt,e.thresholdData);let c=s===xt.ISO_BANDS?mt[r]:pt[r];Array.isArray(c)||(c=c[a]);const u=l.zIndex*l.zOffset,g=(i+1)*n[0],h=(o+1)*n[1],d=t[0]+g,f=t[1]+h;if(s===xt.ISO_BANDS){const e=[];return c.forEach(t=>{const i=[];t.forEach(e=>{const t=d+e[0]*n[0],o=f+e[1]*n[1];i.push([t,o,u])}),e.push(i)}),e}const p=[];return c.forEach(e=>{e.forEach(e=>{const t=d+e[0]*n[0],i=f+e[1]*n[1];p.push([t,i,u])})}),p}function Ct(e){return function(e){if(Array.isArray(e)){for(var t=0,n=new Array(e.length);t<e.length;t++)n[t]=e[t];return n}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function wt(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Et(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function Pt(e,t,n){return t&&Et(e.prototype,t),n&&Et(e,n),e}function At(e){return(At="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Dt(e){return(Dt="function"==typeof Symbol&&"symbol"===At(Symbol.iterator)?function(e){return At(e)}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":At(e)})(e)}function Ot(e,t){return!t||"object"!==Dt(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function Tt(e){return(Tt=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Nt(e,t){return(Nt=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function kt(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&Nt(e,t)}function zt(e){function t(){var t=Reflect.construct(e,Array.from(arguments));return Object.setPrototypeOf(t,Object.getPrototypeOf(this)),t}return t.prototype=Object.create(e.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e,t}var _t=function(e){function t(){return wt(this,t),Ot(this,Tt(t).apply(this,arguments))}return kt(t,zt(Array)),Pt(t,[{key:"clone",value:function(){return(new this.constructor).copy(this).check()}},{key:"copy",value:function(e){for(var t=0;t<this.ELEMENTS;++t)this[t]=e[t];return this.check()}},{key:"set",value:function(){for(var e=0;e<this.ELEMENTS;++e)this[e]=(e<0||arguments.length<=e?void 0:arguments[e])||0;return this.check()}},{key:"fromArray",value:function(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=0;n<this.ELEMENTS;++n)this[n]=e[n+t];return this.check()}},{key:"toString",value:function(){return this.formatString(we)}},{key:"formatString",value:function(e){for(var t="",n=0;n<this.ELEMENTS;++n)t+=(n>0?", ":"")+Ae(this[n],e);return"".concat(e.printTypes?this.constructor.name:"","[").concat(t,"]")}},{key:"toArray",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=0;n<this.ELEMENTS;++n)e[t+n]=this[n];return e}},{key:"toFloat32Array",value:function(){return new Float32Array(this)}},{key:"equals",value:function(e){if(!e||this.length!==e.length)return!1;for(var t=0;t<this.ELEMENTS;++t)if(!Oe(this[t],e[t]))return!1;return!0}},{key:"exactEquals",value:function(e){if(!e||this.length!==e.length)return!1;for(var t=0;t<this.ELEMENTS;++t)if(this[t]!==e[t])return!1;return!0}},{key:"negate",value:function(){for(var e=0;e<this.ELEMENTS;++e)this[e]=-this[e];return this.check()}},{key:"inverse",value:function(){for(var e=0;e<this.ELEMENTS;++e)this[e]=1/this[e];return this.check()}},{key:"lerp",value:function(e,t,n){void 0===n&&(n=t,t=e,e=this);for(var i=0;i<this.ELEMENTS;++i){var o=e[i];this[i]=o+n*(t[i]-o)}return this.check()}},{key:"min",value:function(e){for(var t=0;t<this.ELEMENTS;++t)this[t]=Math.min(e[t],this[t]);return this.check()}},{key:"max",value:function(e){for(var t=0;t<this.ELEMENTS;++t)this[t]=Math.max(e[t],this[t]);return this.check()}},{key:"clamp",value:function(e,t){for(var n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e[n]),t[n]);return this.check()}},{key:"validate",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this,t=e&&e.length===this.ELEMENTS,n=0;n<this.ELEMENTS;++n)t=t&&Number.isFinite(e[n]);return t}},{key:"check",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this;if(we.debug&&!this.validate(e))throw new Error("math.gl: ".concat(this.constructor.name," some fields set to invalid numbers'"));return this}},{key:"sub",value:function(e){return this.subtract(e)}},{key:"setScalar",value:function(e){for(var t=0;t<this.ELEMENTS;++t)this[t]=e;return this.check()}},{key:"addScalar",value:function(e){for(var t=0;t<this.ELEMENTS;++t)this[t]+=e;return this.check()}},{key:"subScalar",value:function(e){return this.addScalar(-e)}},{key:"multiplyScalar",value:function(e){return this.scale(e)}},{key:"divideScalar",value:function(e){return this.scale(1/e)}},{key:"clampScalar",value:function(e,t){for(var n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e),t);return this.check()}}]),t}();function Ft(e,t){return e.length===t&&e.every(Number.isFinite)}var Lt=function(e,t){if(!e)throw new Error(t)},Bt=function(e){function t(){return wt(this,t),Ot(this,Tt(t).apply(this,arguments))}return kt(t,_t),Pt(t,[{key:"len",value:function(){return Math.sqrt(this.lengthSquared())}},{key:"magnitude",value:function(){return Math.sqrt(this.lengthSquared())}},{key:"lengthSquared",value:function(){for(var e=0,t=0;t<this.ELEMENTS;++t)e+=this[t]*this[t];return e}},{key:"distance",value:function(e){return Math.sqrt(this.distanceSquared(e))}},{key:"distanceSquared",value:function(e){for(var t=0,n=0;n<this.ELEMENTS;++n){var i=this[n]-e[n];t+=i*i}return Ee(t)}},{key:"dot",value:function(e){for(var t=0,n=0;n<this.ELEMENTS;++n)t+=this[n]*e[n];return Ee(t)}},{key:"normalize",value:function(){var e=this.magnitude();if(0!==e)for(var t=0;t<this.ELEMENTS;++t)this[t]/=e;return this.check()}},{key:"add",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(var i=0;i<t.length;i++)for(var o=t[i],r=0;r<this.ELEMENTS;++r)this[r]+=o[r];return this.check()}},{key:"subtract",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(var i=0;i<t.length;i++)for(var o=t[i],r=0;r<this.ELEMENTS;++r)this[r]-=o[r];return this.check()}},{key:"multiply",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(var i=0;i<t.length;i++)for(var o=t[i],r=0;r<this.ELEMENTS;++r)this[r]*=o[r];return this.check()}},{key:"divide",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(var i=0;i<t.length;i++)for(var o=t[i],r=0;r<this.ELEMENTS;++r)this[r]/=o[r];return this.check()}},{key:"scale",value:function(e){if(Array.isArray(e))return this.multiply(e);for(var t=0;t<this.ELEMENTS;++t)this[t]*=e;return this.check()}},{key:"scaleAndAdd",value:function(e,t){for(var n=0;n<this.ELEMENTS;++n)this[n]=this[n]*t+e[n];return this.check()}},{key:"lengthSq",value:function(){return this.lengthSquared()}},{key:"distanceTo",value:function(e){return this.distance(e)}},{key:"distanceToSquared",value:function(e){return this.distanceSquared(e)}},{key:"getComponent",value:function(e){return Lt(e>=0&&e<this.ELEMENTS,"index is out of range"),Ee(this[e])}},{key:"setComponent",value:function(e,t){return Lt(e>=0&&e<this.ELEMENTS,"index is out of range"),this[e]=t,this.check()}},{key:"addVectors",value:function(e,t){return this.copy(e).add(t)}},{key:"subVectors",value:function(e,t){return this.copy(e).subtract(t)}},{key:"multiplyVectors",value:function(e,t){return this.copy(e).multiply(t)}},{key:"addScaledVector",value:function(e,t){return this.add(new this.constructor(e).multiplyScalar(t))}},{key:"x",get:function(){return this[0]},set:function(e){return this[0]=Ee(e)}},{key:"y",get:function(){return this[1]},set:function(e){return this[1]=Ee(e)}}]),t}(),Rt=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return wt(this,t),e=Ot(this,Tt(t).call(this)),Array.isArray(n)&&1===arguments.length?e.copy(n):e.set(n,i),e}return kt(t,Bt),Pt(t,[{key:"cross",value:function(e){var t,n,i,o;return t=this,i=e,o=(n=this)[0]*i[1]-n[1]*i[0],t[0]=t[1]=0,t[2]=o,this.check()}},{key:"horizontalAngle",value:function(){return Math.atan2(this.y,this.x)}},{key:"verticalAngle",value:function(){return Math.atan2(this.x,this.y)}},{key:"operation",value:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return e.apply(void 0,[this,this].concat(n)),this.check()}},{key:"ELEMENTS",get:function(){return 2}}]),t}(),jt=[0,0,0],It=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return wt(this,t),e=Ot(this,Tt(t).call(this)),Array.isArray(n)&&1===arguments.length?e.copy(n):e.set(n,i,o),e}return kt(t,Bt),Pt(t,[{key:"angle",value:function(e){return function(e,t){var n=S(e[0],e[1],e[2]),i=S(t[0],t[1],t[2]);M(n,n),M(i,i);var o=function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}(n,i);return o>1?0:o<-1?Math.PI:Math.acos(o)}(this,e)}},{key:"cross",value:function(e){var t,n,i,o,r,a,s,l,c;return t=this,i=e,o=(n=this)[0],r=n[1],a=n[2],s=i[0],l=i[1],c=i[2],t[0]=r*c-a*l,t[1]=a*s-o*c,t[2]=o*l-r*s,this.check()}},{key:"rotateX",value:function(e){var t,n,i,o,r,a,s=e.radians,l=e.origin;return t=this,i=void 0===l?jt:l,o=s,a=[],(r=[])[0]=(n=this)[0]-i[0],r[1]=n[1]-i[1],r[2]=n[2]-i[2],a[0]=r[0],a[1]=r[1]*Math.cos(o)-r[2]*Math.sin(o),a[2]=r[1]*Math.sin(o)+r[2]*Math.cos(o),t[0]=a[0]+i[0],t[1]=a[1]+i[1],t[2]=a[2]+i[2],this.check()}},{key:"rotateY",value:function(e){var t,n,i,o,r,a,s=e.radians,l=e.origin;return t=this,i=void 0===l?jt:l,o=s,a=[],(r=[])[0]=(n=this)[0]-i[0],r[1]=n[1]-i[1],r[2]=n[2]-i[2],a[0]=r[2]*Math.sin(o)+r[0]*Math.cos(o),a[1]=r[1],a[2]=r[2]*Math.cos(o)-r[0]*Math.sin(o),t[0]=a[0]+i[0],t[1]=a[1]+i[1],t[2]=a[2]+i[2],this.check()}},{key:"rotateZ",value:function(e){var t,n,i,o,r,a,s=e.radians,l=e.origin;return t=this,i=void 0===l?jt:l,o=s,a=[],(r=[])[0]=(n=this)[0]-i[0],r[1]=n[1]-i[1],r[2]=n[2]-i[2],a[0]=r[0]*Math.cos(o)-r[1]*Math.sin(o),a[1]=r[0]*Math.sin(o)+r[1]*Math.cos(o),a[2]=r[2],t[0]=a[0]+i[0],t[1]=a[1]+i[1],t[2]=a[2]+i[2],this.check()}},{key:"operation",value:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];return e.apply(void 0,[this,this].concat(n)),this.check()}},{key:"ELEMENTS",get:function(){return 3}},{key:"z",get:function(){return this[2]},set:function(e){return this[2]=Ee(e)}}]),t}(),Wt=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return wt(this,t),e=Ot(this,Tt(t).call(this)),Array.isArray(n)&&1===arguments.length?e.copy(n):e.set(n,i,o,r),e}return kt(t,Bt),Pt(t,[{key:"applyMatrix4",value:function(e){return e.transformVector(this,this),this}},{key:"ELEMENTS",get:function(){return 4}},{key:"z",get:function(){return this[2]},set:function(e){return this[2]=Ee(e)}},{key:"w",get:function(){return this[3]},set:function(e){return this[3]=Ee(e)}}]),t}(),Vt=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var Ut=function(e){function t(){for(var e,n=arguments.length,i=new Array(n),o=0;o<n;o++)i[o]=arguments[o];return wt(this,t),e=Ot(this,Tt(t).call(this)),Array.isArray(i[0])&&1===arguments.length?e.copy(i[0]):e.identity(),e}return kt(t,_t),Pt(t,[{key:"setRowMajor",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,c=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,u=arguments.length>10&&void 0!==arguments[10]?arguments[10]:1,g=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,h=arguments.length>12&&void 0!==arguments[12]?arguments[12]:0,d=arguments.length>13&&void 0!==arguments[13]?arguments[13]:0,f=arguments.length>14&&void 0!==arguments[14]?arguments[14]:0,p=arguments.length>15&&void 0!==arguments[15]?arguments[15]:1;return this[0]=e,this[1]=o,this[2]=l,this[3]=h,this[4]=t,this[5]=r,this[6]=c,this[7]=d,this[8]=n,this[9]=a,this[10]=u,this[11]=f,this[12]=i,this[13]=s,this[14]=g,this[15]=p,this.check()}},{key:"setColumnMajor",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,c=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,u=arguments.length>10&&void 0!==arguments[10]?arguments[10]:1,g=arguments.length>11&&void 0!==arguments[11]?arguments[11]:0,h=arguments.length>12&&void 0!==arguments[12]?arguments[12]:0,d=arguments.length>13&&void 0!==arguments[13]?arguments[13]:0,f=arguments.length>14&&void 0!==arguments[14]?arguments[14]:0,p=arguments.length>15&&void 0!==arguments[15]?arguments[15]:1;return this[0]=e,this[1]=t,this[2]=n,this[3]=i,this[4]=o,this[5]=r,this[6]=a,this[7]=s,this[8]=l,this[9]=c,this[10]=u,this[11]=g,this[12]=h,this[13]=d,this[14]=f,this[15]=p,this.check()}},{key:"copy",value:function(e){return this.setColumnMajor.apply(this,Ct(e))}},{key:"set",value:function(){return this.setColumnMajor.apply(this,arguments)}},{key:"getElement",value:function(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?this[e][t]:this[t][e]}},{key:"setElement",value:function(e,t,n){return arguments.length>3&&void 0!==arguments[3]&&arguments[3]?this[e][t]=Ee(n):this[t][e]=Ee(n),this}},{key:"determinant",value:function(){return t=(e=this)[0],n=e[1],i=e[2],o=e[3],r=e[4],a=e[5],s=e[6],l=e[7],c=e[8],u=e[9],g=e[10],h=e[11],d=e[12],f=e[13],p=e[14],v=e[15],(t*a-n*r)*(g*v-h*p)-(t*s-i*r)*(u*v-h*f)+(t*l-o*r)*(u*p-g*f)+(n*s-i*a)*(c*v-h*d)-(n*l-o*a)*(c*p-g*d)+(i*l-o*s)*(c*f-u*d);var e,t,n,i,o,r,a,s,l,c,u,g,h,d,f,p,v}},{key:"identity",value:function(){return this.copy(Vt)}},{key:"fromQuaternion",value:function(e){return function(e,t){var n=t[0],i=t[1],o=t[2],r=t[3],a=n+n,s=i+i,l=o+o,c=n*a,u=i*a,g=i*s,h=o*a,d=o*s,f=o*l,p=r*a,v=r*s,m=r*l;e[0]=1-g-f,e[1]=u+m,e[2]=h-v,e[3]=0,e[4]=u-m,e[5]=1-c-f,e[6]=d+p,e[7]=0,e[8]=h+v,e[9]=d-p,e[10]=1-c-g,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(this,e),this.check()}},{key:"frustum",value:function(e){return function(e,t,n,i,o,r,a){var s=1/(n-t),l=1/(o-i),c=1/(r-a);e[0]=2*r*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*r*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+i)*l,e[10]=(a+r)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*r*2*c,e[15]=0}(this,e.left,e.right,e.bottom,e.top,e.near,e.far),this.check()}},{key:"lookAt",value:function(e){var t=e.eye,n=e.center,i=void 0===n?[0,0,0]:n,o=e.up;return function(e,t,n,i){var o,r,a,s,c,u,g,h,d,f,p=t[0],v=t[1],m=t[2],x=i[0],y=i[1],S=i[2],M=n[0],b=n[1],C=n[2];Math.abs(p-M)<l&&Math.abs(v-b)<l&&Math.abs(m-C)<l?function(e){e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1}(e):(g=p-M,h=v-b,d=m-C,o=y*(d*=f=1/Math.sqrt(g*g+h*h+d*d))-S*(h*=f),r=S*(g*=f)-x*d,a=x*h-y*g,(f=Math.sqrt(o*o+r*r+a*a))?(o*=f=1/f,r*=f,a*=f):(o=0,r=0,a=0),s=h*a-d*r,c=d*o-g*a,u=g*r-h*o,(f=Math.sqrt(s*s+c*c+u*u))?(s*=f=1/f,c*=f,u*=f):(s=0,c=0,u=0),e[0]=o,e[1]=s,e[2]=g,e[3]=0,e[4]=r,e[5]=c,e[6]=h,e[7]=0,e[8]=a,e[9]=u,e[10]=d,e[11]=0,e[12]=-(o*p+r*v+a*m),e[13]=-(s*p+c*v+u*m),e[14]=-(g*p+h*v+d*m),e[15]=1)}(this,t,i,void 0===o?[0,1,0]:o),this.check()}},{key:"ortho",value:function(e){var t=e.left,n=e.right,i=e.bottom,o=e.top,r=e.near,a=void 0===r?.1:r,s=e.far;return function(e,t,n,i,o,r,a){var s=1/(t-n),l=1/(i-o),c=1/(r-a);e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+i)*l,e[14]=(a+r)*c,e[15]=1}(this,t,n,i,o,a,void 0===s?500:s),this.check()}},{key:"orthographic",value:function(e){var n=e.fovy,i=void 0===n?45*Math.PI/180:n,o=e.aspect,r=void 0===o?1:o,a=e.focalDistance,s=void 0===a?1:a,l=e.near,c=void 0===l?.1:l,u=e.far,g=void 0===u?500:u;if(i>2*Math.PI)throw Error("radians");var h=i/2,d=s*Math.tan(h),f=d*r;return(new t).ortho({left:-f,right:f,bottom:-d,top:d,near:c,far:g})}},{key:"perspective",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.fovy,n=e.fov,i=void 0===n?45*Math.PI/180:n,o=e.aspect,r=void 0===o?1:o,a=e.near,s=void 0===a?.1:a,l=e.far,c=void 0===l?500:l;if((t=t||i)>2*Math.PI)throw Error("radians");return y(this,t,r,s,c),this.check()}},{key:"transpose",value:function(){return function(e,t){if(e===t){var n=t[1],i=t[2],o=t[3],r=t[6],a=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=i,e[9]=r,e[11]=t[14],e[12]=o,e[13]=a,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15]}(this,this),this.check()}},{key:"invert",value:function(){var e,t,n,i,o,r,a,s,l,c,u,g,h,d,f,p,v,m,x,y,S,M,b,C,w,E,P,A,D,O,T;return e=this,n=(t=this)[0],i=t[1],o=t[2],r=t[3],a=t[4],s=t[5],l=t[6],c=t[7],u=t[8],g=t[9],h=t[10],d=t[11],f=t[12],p=t[13],v=t[14],m=t[15],(T=(x=n*s-i*a)*(O=h*m-d*v)-(y=n*l-o*a)*(D=g*m-d*p)+(S=n*c-r*a)*(A=g*v-h*p)+(M=i*l-o*s)*(P=u*m-d*f)-(b=i*c-r*s)*(E=u*v-h*f)+(C=o*c-r*l)*(w=u*p-g*f))&&(T=1/T,e[0]=(s*O-l*D+c*A)*T,e[1]=(o*D-i*O-r*A)*T,e[2]=(p*C-v*b+m*M)*T,e[3]=(h*b-g*C-d*M)*T,e[4]=(l*P-a*O-c*E)*T,e[5]=(n*O-o*P+r*E)*T,e[6]=(v*S-f*C-m*y)*T,e[7]=(u*C-h*S+d*y)*T,e[8]=(a*D-s*P+c*w)*T,e[9]=(i*P-n*D-r*w)*T,e[10]=(f*b-p*S+m*x)*T,e[11]=(g*S-u*b-d*x)*T,e[12]=(s*E-a*A-l*w)*T,e[13]=(n*A-i*E+o*w)*T,e[14]=(p*y-f*M-v*x)*T,e[15]=(u*M-g*y+h*x)*T),this.check()}},{key:"multiplyLeft",value:function(e){return f(this,e,this),this.check()}},{key:"multiplyRight",value:function(e){return f(this,this,e),this.check()}},{key:"rotateX",value:function(e){return m(this,this,e),this.check()}},{key:"rotateY",value:function(e){var t,n,i,o,r,a,s,l,c,u,g,h,d;return t=this,n=this,i=e,o=Math.sin(i),r=Math.cos(i),a=n[0],s=n[1],l=n[2],c=n[3],u=n[8],g=n[9],h=n[10],d=n[11],n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]),t[0]=a*r-u*o,t[1]=s*r-g*o,t[2]=l*r-h*o,t[3]=c*r-d*o,t[8]=a*o+u*r,t[9]=s*o+g*r,t[10]=l*o+h*r,t[11]=c*o+d*r,this.check()}},{key:"rotateZ",value:function(e){return x(this,this,e),this.check()}},{key:"rotateXYZ",value:function(e){var t=s(e,3),n=t[0],i=t[1],o=t[2];return this.rotateX(n).rotateY(i).rotateZ(o)}},{key:"rotateAxis",value:function(e,t){return function(e,t,n,i){var o,r,a,s,c,u,g,h,d,f,p,v,m,x,y,S,M,b,C,w,E,P,A,D,O=i[0],T=i[1],N=i[2],k=Math.sqrt(O*O+T*T+N*N);k<l||(O*=k=1/k,T*=k,N*=k,o=Math.sin(n),a=1-(r=Math.cos(n)),s=t[0],c=t[1],u=t[2],g=t[3],h=t[4],d=t[5],f=t[6],p=t[7],v=t[8],m=t[9],x=t[10],y=t[11],S=O*O*a+r,M=T*O*a+N*o,b=N*O*a-T*o,C=O*T*a-N*o,w=T*T*a+r,E=N*T*a+O*o,P=O*N*a+T*o,A=T*N*a-O*o,D=N*N*a+r,e[0]=s*S+h*M+v*b,e[1]=c*S+d*M+m*b,e[2]=u*S+f*M+x*b,e[3]=g*S+p*M+y*b,e[4]=s*C+h*w+v*E,e[5]=c*C+d*w+m*E,e[6]=u*C+f*w+x*E,e[7]=g*C+p*w+y*E,e[8]=s*P+h*A+v*D,e[9]=c*P+d*A+m*D,e[10]=u*P+f*A+x*D,e[11]=g*P+p*A+y*D,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]))}(this,this,e,t),this.check()}},{key:"scale",value:function(e){return Array.isArray(e)?v(this,this,e):v(this,this,[e,e,e]),this.check()}},{key:"translate",value:function(e){return p(this,this,e),this.check()}},{key:"transformVector2",value:function(e,t){return function(e,t,n){var i=t[0],o=t[1];e[0]=n[0]*i+n[4]*o+n[12],e[1]=n[1]*i+n[5]*o+n[13]}(t=t||new Rt,e,this),Ft(t,2),t}},{key:"transformVector3",value:function(e,t){return function(e,t,n){var i=t[0],o=t[1],r=t[2],a=n[3]*i+n[7]*o+n[11]*r+n[15];a=a||1,e[0]=(n[0]*i+n[4]*o+n[8]*r+n[12])/a,e[1]=(n[1]*i+n[5]*o+n[9]*r+n[13])/a,e[2]=(n[2]*i+n[6]*o+n[10]*r+n[14])/a}(t=t||new It,e,this),Ft(t,3),t}},{key:"transformVector4",value:function(e,t){return u(t=t||new Wt,e,this),Ft(t,4),t.check()}},{key:"transformVector",value:function(e,t){switch(e.length){case 2:return this.transformVector2(e,t);case 3:return this.transformVector3(e,t);case 4:return this.transformVector4(e,t);default:throw new Error("Illegal vector")}}},{key:"transformDirection",value:function(e,t){return this._transformVector(e,t,0)}},{key:"transformPoint",value:function(e,t){return this._transformVector(e,t,1)}},{key:"_transformVector",value:function(e,t,n){switch(e.length){case 2:u(t=t||new Rt,[e[0],e[1],0,n],this),t.length=2,Ft(t,2);break;case 3:u(t=t||new It,[e[0],e[1],e[2],n],this),t.length=3,Ft(t,3);break;case 4:if(Boolean(n)!==Boolean(e[3]))throw new Error("math.gl: Matrix4.transformPoint - invalid vector");u(t=t||new Wt,e,this),Ft(t,4);break;default:throw new Error("Illegal vector")}return t}},{key:"makeRotationX",value:function(e){return this.identity().rotateX(e)}},{key:"makeTranslation",value:function(e,t,n){return this.identity().translate([e,t,n])}},{key:"ELEMENTS",get:function(){return 16}}]),t}();const{count:Gt}=i.experimental,{fp64LowPart:Xt}=r.fp64,Yt=6378e3,qt=[1,0,0];function Ht({data:e,getPosition:t,cellSizeMeters:n,gpuGridAggregator:o,gpuAggregation:r,aggregationFlags:a,getWeight:s,fp64:l=!1,coordinateSystem:c=i.COORDINATE_SYSTEM.LNGLAT,viewport:u=null,boundingBox:g=null}){let h={};i.log.assert(a.dataChanged||a.cellSizeChanged||a.viewportChanged),a.dataChanged&&(g=(h=function(e,t,n=null){const o=Gt(e),r=new Float32Array(2*o),a=new Float32Array(2*o),s=new Float32Array(3*o);let l,c,u=1/0,g=-1/0,h=1/0,d=-1/0;const{iterable:f,objectInfo:p}=Object(i.createIterable)(e);for(const e of f){p.index++;const i=t(e,p),{index:o}=p;c=i[0],l=i[1],r[2*o]=c,r[2*o+1]=l,a[2*o]=Xt(c),a[2*o+1]=Xt(l);const f=n?n(e,p):qt;Array.isArray(f)?(s[3*o]=f[0],s[3*o+1]=f[1],s[3*o+2]=f[2]):s[3*o]=f,Number.isFinite(l)&&Number.isFinite(c)&&(u=l<u?l:u,g=l>g?l:g,h=c<h?c:h,d=c>d?c:d)}const v={weight1:{size:1,operation:w.SUM,needMax:!0,values:s}};return{positions:r,positions64xyLow:a,weights:v,boundingBox:{xMin:h,xMax:d,yMin:u,yMax:g}}}(e,t,s)).boundingBox);let d=[n,n],f=[0,0];switch(i.log.assert(c===i.COORDINATE_SYSTEM.LNGLAT||c===i.COORDINATE_SYSTEM.IDENTITY),c){case i.COORDINATE_SYSTEM.LNGLAT:case i.COORDINATE_SYSTEM.LNGLAT_DEPRECATED:const e=function(e,t){const{yMin:n,yMax:i}=e;return function(e,t){const n=(a=e,a/Yt*(180/Math.PI)),i=(o=t,r=e,r/Yt*(180/Math.PI)/Math.cos(o*Math.PI/180));var o,r;var a;return{yOffset:n,xOffset:i}}(t,(n+i)/2)}(g,n);d=[e.xOffset,e.yOffset],f=[-180,-90];break;case i.COORDINATE_SYSTEM.IDENTITY:const{width:t,height:o}=u;f=[-t/2,-o/2];break;default:i.log.assert(!1)}const p=function({boundingBox:e,cellSize:t,worldOrigin:n}){const{yMin:i,yMax:o,xMin:r,xMax:a}=e,s=$t(r-n[0],t[0])+n[0],l=$t(i-n[1],t[1])+n[1],c=(new Ut).translate([-1*s,-1*l,0]),u=[s,l],g=a-r+t[0],h=o-i+t[1],d=[Math.ceil(g/t[0]),Math.ceil(h/t[1])];return{gridOrigin:u,gridSize:d,width:g,height:h,gridTransformMatrix:c}}({boundingBox:g,cellSize:d,worldOrigin:f}),v=o.run({positions:h.positions,positions64xyLow:h.positions64xyLow,weights:h.weights,cellSize:d,width:p.width,height:p.height,gridTransformMatrix:p.gridTransformMatrix,useGPU:r,changeFlags:a,fp64:l});return{countsBuffer:v.weight1.aggregationBuffer,maxCountBuffer:v.weight1.maxBuffer,countsData:v.weight1.aggregationData,maxCountData:v.weight1.maxData,gridSize:p.gridSize,gridOrigin:p.gridOrigin,cellSize:d,boundingBox:g}}function $t(e,t){const n=e<0?-1:1;let i=n<0?Math.abs(e)+t:Math.abs(e);return(i=Math.floor(i/t)*t)*n}const Zt=[255,255,255,255],Qt=1,Kt={cellSize:{type:"number",min:1,max:1e3,value:1e3},getPosition:{type:"accessor",value:e=>e.position},getWeight:{type:"accessor",value:e=>1},contours:[{threshold:1}],fp64:!1,zOffset:.005};class Jt extends i.CompositeLayer{initializeState(){const{gl:e}=this.context,t={id:`${this.id}-gpu-aggregator`,shaderCache:this.context.shaderCache};this.state={contourData:{},gridAggregator:new H(e,t),colorTrigger:0,strokeWidthTrigger:0}}updateState({oldProps:e,props:t,changeFlags:n}){let i=!1,o=!1;const r=this._getAggregationFlags({oldProps:e,props:t,changeFlags:n});r&&(i=!0,this.setState({countsData:null}),this._aggregateData(r)),this._shouldRebuildContours({oldProps:e,props:t})&&(o=!0,this._updateThresholdData(t)),i||o?this._generateContours():this._updateSubLayerTriggers(e,t)}renderLayers(){const{contourSegments:e,contourPolygons:t}=this.state.contourData,n=e&&e.length>0,o=t&&t.length>0;return[n&&new i.LineLayer(this._getLineLayerProps()),o&&new i.SolidPolygonLayer(this._getSolidPolygonLayerProps())]}_aggregateData(e){const{data:t,cellSize:n,getPosition:i,getWeight:o,gpuAggregation:r,fp64:a,coordinateSystem:s}=this.props,{countsData:l,countsBuffer:c,gridSize:u,gridOrigin:g,cellSize:h,boundingBox:d}=Ht({data:t,cellSizeMeters:n,getPosition:i,getWeight:o,gpuAggregation:r,gpuGridAggregator:this.state.gridAggregator,fp64:a,coordinateSystem:s,viewport:this.context.viewport,boundingBox:this.state.boundingBox,aggregationFlags:e});this.setState({countsData:l,countsBuffer:c,gridSize:u,gridOrigin:g,cellSize:h,boundingBox:d})}_generateContours(){const{gridSize:e,gridOrigin:t,cellSize:n,thresholdData:i}=this.state;let{countsData:o}=this.state;if(!o){const{countsBuffer:e}=this.state;o=e.getData(),this.setState({countsData:o})}const{cellWeights:r}=H.getCellData({countsData:o}),a=function({thresholdData:e,colors:t,cellWeights:n,gridSize:i,gridOrigin:o,cellSize:r}){const a=[],s=[],l=i[0],c=i[1];return e.forEach((e,t)=>{const{threshold:i}=e;for(let t=-1;t<l;t++)for(let u=-1;u<c;u++){const{code:g,meanCode:h}=Mt({cellWeights:n,threshold:i,x:t,y:u,width:l,height:c}),d={gridOrigin:o,cellSize:r,x:t,y:u,width:l,height:c,code:g,meanCode:h,thresholdData:e};if(Array.isArray(i))d.type=xt.ISO_BANDS,bt(d).forEach(e=>{s.push({vertices:e,threshold:i})});else{d.type=xt.ISO_LINES;const e=bt(d);for(let t=0;t<e.length;t+=2)a.push({start:e[t],end:e[t+1],threshold:i})}}}),{contourSegments:a,contourPolygons:s}}({thresholdData:i,cellWeights:r,gridSize:e,gridOrigin:t,cellSize:n});this.setState({contourData:a})}_getAggregationFlags({oldProps:e,props:t,changeFlags:n}){let i=null;return(n.dataChanged||e.gpuAggregation!==t.gpuAggregation||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPosition))&&(i=Object.assign({},i,{dataChanged:!0})),e.cellSize!==t.cellSize&&(i=Object.assign({},i,{cellSizeChanged:!0})),i}_getLineLayerProps(){const{fp64:e}=this.props,{colorTrigger:t,strokeWidthTrigger:n}=this.state;return this.getSubLayerProps({id:"contour-line-layer",data:this.state.contourData.contourSegments,fp64:e,getSourcePosition:e=>e.start,getTargetPosition:e=>e.end,getColor:this._onGetSublayerColor.bind(this),getWidth:this._onGetSublayerStrokeWidth.bind(this),widthUnits:"pixels",updateTriggers:{getColor:t,getWidth:n}})}_getSolidPolygonLayerProps(){const{fp64:e}=this.props,{colorTrigger:t}=this.state;return this.getSubLayerProps({id:"contour-solid-polygon-layer",data:this.state.contourData.contourPolygons,fp64:e,getPolygon:e=>e.vertices,getFillColor:this._onGetSublayerColor.bind(this),updateTriggers:{getFillColor:t}})}_onGetSublayerColor(e){const{contours:t}=this.props;let n=Zt;return t.forEach(t=>{Oe(t.threshold,e.threshold)&&(n=t.color||Zt)}),n}_onGetSublayerStrokeWidth(e){const{contours:t}=this.props;let n=Qt;return t.some(t=>t.threshold===e.threshold&&(n=t.strokeWidth||Qt,!0)),n}_shouldRebuildContours({oldProps:e,props:t}){if(!e.contours||!e.zOffset||e.contours.length!==t.contours.length||e.zOffset!==t.zOffset)return!0;const n=e.contours.map(e=>e.threshold),i=t.contours.map(e=>e.threshold);return i.some((e,t)=>!Oe(i[t],n[t]))}_updateSubLayerTriggers(e,t){e&&e.contours&&t&&t.contours&&(t.contours.some((t,n)=>t.color!==e.contours[n].color)&&this.state.colorTrigger++,t.contours.some((t,n)=>t.strokeWidth!==e.contours[n].strokeWidth)&&this.state.strokeWidthTrigger++)}_updateThresholdData(e){const t=e.contours.map((t,n)=>({threshold:t.threshold,zIndex:t.zIndex||n,zOffset:e.zOffset}));this.setState({thresholdData:t})}}Jt.layerName="ContourLayer",Jt.defaultProps=Kt;var en="#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec4 instanceCounts;\n\n// Custom uniforms\nuniform float extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\n\nuniform vec2 gridSize;\nuniform vec2 gridOrigin;\nuniform vec2 gridOriginLow;\nuniform vec2 gridOffset;\nuniform vec2 gridOffsetLow;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nlayout(std140) uniform;\nuniform AggregationData\n{\n  vec4 maxCount;\n} aggregationData;\n\n#define ELEVATION_SCALE 100.\n\n// Result\nout vec4 vColor;\n\nvoid main(void) {\n\n  bool noRender = instanceCounts.r <= 0.0;\n\n  float step = instanceCounts.r / aggregationData.maxCount.r;\n  vec4 color = mix(minColor, maxColor, step) / 255.;\n\n  // TODO: discard when noRender is true\n  float finalCellSize = noRender ? 0.0 : project_size(cellSize);\n\n\n  float elevation = 0.0;\n\n  if (extruded > 0.5) {\n    elevation = instanceCounts.r  * (positions.z + 1.0) *\n      ELEVATION_SCALE * elevationScale;\n  }\n\n  float yIndex = floor(float(gl_InstanceID) / gridSize[0]);\n  float xIndex = float(gl_InstanceID) - (yIndex * gridSize[0]);\n\n  // Keeping 32-bit calculations for debugging, to be removed.\n  // float instancePositionX = gridOffset[0] * xIndex + gridOrigin[0];\n  // float instancePositionY = gridOffset[1] * yIndex + gridOrigin[1];\n  // vec3 extrudedPosition = vec3(instancePositionX, instancePositionY, elevation);\n  // vec2 extrudedPosition64xyLow = vec2(0., 0.);\n\n  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(xIndex, 0.));\n  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\n  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(yIndex, 0.));\n  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\n  vec3 extrudedPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\n  vec2 extrudedPosition64xyLow = vec2(instancePositionXFP64[1], instancePositionYFP64[1]);\n\n  vec3 offset = vec3(\n    (positions.x * coverage + 1.0) / 2.0 * finalCellSize,\n    (positions.y * coverage - 1.0) / 2.0 * finalCellSize,\n    1.0);\n\n  // extrude positions\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(extrudedPosition, extrudedPosition64xyLow, offset, position_commonspace);\n\n   if (extruded > 0.5) {\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, position_commonspace.xyz, normals);\n    vColor = vec4(lightColor, color.a * opacity);\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n}\n",tn="#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-fragment-shader\n\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vColor;\n}\n";const{fp64LowPart:nn}=r.fp64,on=new r.PhongMaterial,rn=0,an={cellSize:{type:"number",min:0,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},extruded:!0,fp64:!1,pickable:!1,minColor:{type:"color",value:[0,0,0,255]},maxColor:{type:"color",value:[0,255,0,255]},material:on};class sn extends i.Layer{getShaders(){return{vs:en,fs:tn,modules:["project32","gouraud-lighting","picking","fp64"]}}initializeState(){this.getAttributeManager().addInstanced({instanceCounts:{size:4,update:this.calculateInstanceCounts,noAlloc:!0}})}updateState({props:e,oldProps:t,changeFlags:n}){if(super.updateState({props:e,oldProps:t,changeFlags:n}),e.fp64!==t.fp64){const{gl:e}=this.context;this.state.model&&this.state.model.delete();const t=this._getModel(e);this._setupUniformBuffer(t),this.setState({model:t}),this.state.attributeManager.invalidate("instanceCounts")}e.countsBuffer!==t.countsBuffer&&this.state.attributeManager.invalidate("instanceCounts")}_getModel(e){return new r.Model(e,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new r.CubeGeometry,isInstanced:!0,shaderCache:this.context.shaderCache}))}draw({uniforms:e}){const{cellSize:t,extruded:n,elevationScale:i,coverage:o,gridSize:r,gridOrigin:s,gridOffset:l,minColor:c,maxColor:u,maxCountBuffer:g}=this.props,h=[nn(s[0]),nn(s[1])],d=[nn(l[0]),nn(l[1])];g.bind({target:a.a.UNIFORM_BUFFER,index:rn}),this.state.model.setUniforms(Object.assign({},e,{cellSize:t,extruded:n,elevationScale:i,coverage:o,gridSize:r,gridOrigin:s,gridOriginLow:h,gridOffset:l,gridOffsetLow:d,minColor:c,maxColor:u})).draw(),g.unbind({target:a.a.UNIFORM_BUFFER,index:rn})}calculateInstanceCounts(e){const{countsBuffer:t}=this.props;e.update({buffer:t})}_setupUniformBuffer(e){const t=this.context.gl,n=e.program.handle,i=t.getUniformBlockIndex(n,"AggregationData");t.uniformBlockBinding(n,i,rn)}}sn.layerName="GPUGridCellLayer",sn.defaultProps=an;const ln=[0,0,0,255],cn=[0,255,0,255],un={elevationScale:{type:"number",min:0,value:1},cellSize:{type:"number",min:0,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},extruded:!1,fp64:!1,pickable:!1,material:new r.PhongMaterial,gpuAggregation:!0};class gn extends i.CompositeLayer{initializeState(){const{gl:e}=this.context,t={id:`${this.id}-gpu-aggregator`,shaderCache:this.context.shaderCache};this.state={gpuGridAggregator:new H(e,t)}}updateState(e){const t=this.getAggregationFlags(e);t&&this.getLayerData(t)}getAggregationFlags({oldProps:e,props:t,changeFlags:n}){let i=null;return(n.dataChanged||e.gpuAggregation!==t.gpuAggregation||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPosition))&&(i=Object.assign({},i,{dataChanged:!0})),e.cellSize!==t.cellSize&&(i=Object.assign({},i,{cellSizeChanged:!0})),i}getLayerData(e){const{data:t,cellSize:n,getPosition:i,gpuAggregation:o}=this.props,{countsBuffer:r,maxCountBuffer:a,gridSize:s,gridOrigin:l,cellSize:c,boundingBox:u}=Ht({data:t,cellSizeMeters:n,getPosition:i,gpuAggregation:o,gpuGridAggregator:this.state.gpuGridAggregator,boundingBox:this.state.boundingBox,aggregationFlags:e});this.setState({countsBuffer:r,maxCountBuffer:a,gridSize:s,gridOrigin:l,cellSize:c,boundingBox:u})}getSubLayerProps(){const{elevationScale:e,fp64:t,extruded:n,cellSize:i,coverage:o,material:r}=this.props,{countsBuffer:a,maxCountBuffer:s,gridSize:l,gridOrigin:c,cellSize:u}=this.state,g=ln,h=cn;return super.getSubLayerProps({id:"grid-cell",data:this.state.layerData,countsBuffer:a,maxCountBuffer:s,gridSize:l,gridOrigin:c,gridOffset:u,numInstances:l[0]*l[1],minColor:g,maxColor:h,fp64:t,cellSize:i,coverage:o,material:r,elevationScale:e,extruded:n,pickable:!1})}getSubLayerClass(){return sn}renderLayers(){return new(this.getSubLayerClass())(this.getSubLayerProps())}}gn.layerName="GPUGridLayer",gn.defaultProps=un,n.d(t,"experimental",function(){return hn}),n.d(t,"ScreenGridLayer",function(){return re}),n.d(t,"GridLayer",function(){return pe}),n.d(t,"HexagonLayer",function(){return Ce}),n.d(t,"ContourLayer",function(){return Jt}),n.d(t,"_GPUGridLayer",function(){return gn}),n.d(t,"_GPUGridAggregator",function(){return H}),n.d(t,"AGGREGATION_OPERATION",function(){return w}),n.d(t,"_pointToDensityGridData",function(){return Ht});const hn={BinSorter:se,linearScale:function(e,t,n){return(n-e[0])/(e[1]-e[0])*(t[1]-t[0])+t[0]},getLinearScale:ue,quantizeScale:le,getQuantizeScale:ce,defaultColorRange:o}}])});