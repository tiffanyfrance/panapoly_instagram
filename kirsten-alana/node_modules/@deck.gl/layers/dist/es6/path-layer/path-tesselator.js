import { experimental } from '@deck.gl/core';
const Tesselator = experimental.Tesselator;
import { fp64 as fp64Module } from '@luma.gl/core';
const fp64LowPart = fp64Module.fp64LowPart;
export default class PathTesselator extends Tesselator {
  constructor(_ref) {
    let data = _ref.data,
        getGeometry = _ref.getGeometry,
        positionFormat = _ref.positionFormat,
        fp64 = _ref.fp64;
    super({
      data,
      getGeometry,
      fp64,
      positionFormat,
      attributes: {
        startPositions: {
          size: 3
        },
        endPositions: {
          size: 3
        },
        leftDeltas: {
          size: 3
        },
        rightDeltas: {
          size: 3
        },
        startEndPositions64XyLow: {
          size: 4,
          fp64Only: true
        }
      }
    });
  }

  get(attributeName, target, accessor) {
    if (this.attributes[attributeName]) {
      return this.attributes[attributeName];
    }

    switch (attributeName) {
      case 'strokeWidths':
        return this._updateAttribute({
          target,
          size: 1,
          getValue: (object, objectInfo) => {
            objectInfo.target[0] = accessor(object, objectInfo);
            return objectInfo.target;
          }
        });

      case 'dashArrays':
        return this._updateAttribute({
          target,
          size: 2,
          getValue: accessor
        });

      case 'colors':
        return this._updateAttribute({
          target,
          size: 4,
          getValue: (object, objectInfo) => {
            const color = accessor(object, objectInfo);

            if (color.length === 4) {
              return color;
            }

            const value = objectInfo.target;
            value[0] = color[0];
            value[1] = color[1];
            value[2] = color[2];
            value[3] = 255;
            return value;
          }
        });

      case 'pickingColors':
        return this._updateAttribute({
          target,
          size: 3,
          getValue: (object, _ref2) => {
            let index = _ref2.index,
                value = _ref2.target;
            return accessor(index, value);
          }
        });

      default:
        return null;
    }
  }

  getGeometrySize(path) {
    return Math.max(0, this.getPathLength(path) - 1);
  }

  updateGeometryAttributes(path, context) {
    const _this$attributes = this.attributes,
          startPositions = _this$attributes.startPositions,
          endPositions = _this$attributes.endPositions,
          leftDeltas = _this$attributes.leftDeltas,
          rightDeltas = _this$attributes.rightDeltas,
          startEndPositions64XyLow = _this$attributes.startEndPositions64XyLow,
          fp64 = this.fp64;
    const numPoints = context.geometrySize + 1;

    if (numPoints < 2) {
      return;
    }

    const isPathClosed = this.isClosed(path);
    let startPoint = this.getPointOnPath(path, 0);
    let endPoint = this.getPointOnPath(path, 1);
    let prevPoint = isPathClosed ? this.getPointOnPath(path, numPoints - 2) : startPoint;
    let nextPoint;

    for (let i = context.vertexStart, ptIndex = 1; ptIndex < numPoints; i++, ptIndex++) {
      if (ptIndex + 1 < numPoints) {
        nextPoint = this.getPointOnPath(path, ptIndex + 1);
      } else {
        nextPoint = isPathClosed ? this.getPointOnPath(path, 1) : endPoint;
      }

      startPositions[i * 3] = startPoint[0];
      startPositions[i * 3 + 1] = startPoint[1];
      startPositions[i * 3 + 2] = startPoint[2] || 0;
      endPositions[i * 3] = endPoint[0];
      endPositions[i * 3 + 1] = endPoint[1];
      endPositions[i * 3 + 2] = endPoint[2] || 0;
      leftDeltas[i * 3] = startPoint[0] - prevPoint[0];
      leftDeltas[i * 3 + 1] = startPoint[1] - prevPoint[1];
      leftDeltas[i * 3 + 2] = startPoint[2] - prevPoint[2] || 0;
      rightDeltas[i * 3] = nextPoint[0] - endPoint[0];
      rightDeltas[i * 3 + 1] = nextPoint[1] - endPoint[1];
      rightDeltas[i * 3 + 2] = nextPoint[2] - endPoint[2] || 0;

      if (fp64) {
        startEndPositions64XyLow[i * 4] = fp64LowPart(startPoint[0]);
        startEndPositions64XyLow[i * 4 + 1] = fp64LowPart(startPoint[1]);
        startEndPositions64XyLow[i * 4 + 2] = fp64LowPart(endPoint[0]);
        startEndPositions64XyLow[i * 4 + 3] = fp64LowPart(endPoint[1]);
      }

      prevPoint = startPoint;
      startPoint = endPoint;
      endPoint = nextPoint;
    }
  }

  getPathLength(path) {
    if (Number.isFinite(path[0])) {
      return path.length / this.positionSize;
    }

    return path.length;
  }

  getPointOnPath(path, index) {
    if (Number.isFinite(path[0])) {
      const positionSize = this.positionSize;
      return [path[index * positionSize], path[index * positionSize + 1], positionSize === 3 ? path[index * positionSize + 2] : 0];
    }

    return path[index];
  }

  isClosed(path) {
    const numPoints = this.getPathLength(path);
    const firstPoint = this.getPointOnPath(path, 0);
    const lastPoint = this.getPointOnPath(path, numPoints - 1);
    return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];
  }

}
//# sourceMappingURL=path-tesselator.js.map