!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("luma"),require("deck"));else if("function"==typeof define&&define.amd)define(["luma","deck"],e);else{var n="object"==typeof exports?e(require("luma"),require("deck")):e(t.luma,t.deck);for(var i in n)("object"==typeof exports?exports:t)[i]=n[i]}}(window,function(t,e){return function(t){var e={};function n(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return t[i].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(i,o,function(e){return t[e]}.bind(null,o));return i},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=13)}([function(e,n){e.exports=t},function(t,n){t.exports=e},function(t,e,n){t.exports=n(15)},function(t,e,n){"use strict";function i(t,e,n,i,o,r,s){try{var a=t[r](s),c=a.value}catch(t){return void n(t)}a.done?e(c):Promise.resolve(c).then(i,o)}function o(t){return function(){var e=this,n=arguments;return new Promise(function(o,r){var s=t.apply(e,n);function a(t){i(s,o,r,a,c,"next",t)}function c(t){i(s,o,r,a,c,"throw",t)}a(void 0)})}}n.d(e,"a",function(){return o})},function(t,e,n){"use strict";(function(t){n.d(e,"a",function(){return f});var i=n(2),o=n.n(i),r=n(3),s=n(8),a=n.n(s),c=n(9),l=n.n(c),u=n(12);function f(t,e){return h.apply(this,arguments)}function h(){return(h=Object(r.a)(o.a.mark(function e(n,i){var r,s,c,f,h;return o.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return r=l.a.promisify(a.a),s=Object(u.a)(n),c=s.mimeType,f=n instanceof t?n:t.from(n),e.next=5,r(f,c);case 5:return h=e.sent,e.abrupt("return",{width:h.shape[0],height:h.shape[1],data:h.data});case 7:case"end":return e.stop()}},e)}))).apply(this,arguments)}}).call(this,n(7).Buffer)},function(t,e,n){"use strict";(function(t){function i(e){return t.isBuffer(e)?new Uint8Array(e).buffer:e}n.d(e,"a",function(){return i})}).call(this,n(7).Buffer)},function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e,n){"use strict";(function(t){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var i=n(17),o=n(18),r=n(19);function s(){return c.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(t,e){if(s()<e)throw new RangeError("Invalid typed array length");return c.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=c.prototype:(null===t&&(t=new c(e)),t.length=e),t}function c(t,e,n){if(!(c.TYPED_ARRAY_SUPPORT||this instanceof c))return new c(t,e,n);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return f(this,t)}return l(this,t,e,n)}function l(t,e,n,i){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,n,i){if(e.byteLength,n<0||e.byteLength<n)throw new RangeError("'offset' is out of bounds");if(e.byteLength<n+(i||0))throw new RangeError("'length' is out of bounds");e=void 0===n&&void 0===i?new Uint8Array(e):void 0===i?new Uint8Array(e,n):new Uint8Array(e,n,i);c.TYPED_ARRAY_SUPPORT?(t=e).__proto__=c.prototype:t=h(t,e);return t}(t,e,n,i):"string"==typeof e?function(t,e,n){"string"==typeof n&&""!==n||(n="utf8");if(!c.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var i=0|g(e,n),o=(t=a(t,i)).write(e,n);o!==i&&(t=t.slice(0,o));return t}(t,e,n):function(t,e){if(c.isBuffer(e)){var n=0|p(e.length);return 0===(t=a(t,n)).length?t:(e.copy(t,0,0,n),t)}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(i=e.length)!=i?a(t,0):h(t,e);if("Buffer"===e.type&&r(e.data))return h(t,e.data)}var i;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function u(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function f(t,e){if(u(e),t=a(t,e<0?0:0|p(e)),!c.TYPED_ARRAY_SUPPORT)for(var n=0;n<e;++n)t[n]=0;return t}function h(t,e){var n=e.length<0?0:0|p(e.length);t=a(t,n);for(var i=0;i<n;i+=1)t[i]=255&e[i];return t}function p(t){if(t>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|t}function g(t,e){if(c.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var n=t.length;if(0===n)return 0;for(var i=!1;;)switch(e){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return B(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return U(t).length;default:if(i)return B(t).length;e=(""+e).toLowerCase(),i=!0}}function d(t,e,n){var i=t[e];t[e]=t[n],t[n]=i}function v(t,e,n,i,o){if(0===t.length)return-1;if("string"==typeof n?(i=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=o?0:t.length-1),n<0&&(n=t.length+n),n>=t.length){if(o)return-1;n=t.length-1}else if(n<0){if(!o)return-1;n=0}if("string"==typeof e&&(e=c.from(e,i)),c.isBuffer(e))return 0===e.length?-1:y(t,e,n,i,o);if("number"==typeof e)return e&=255,c.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,e,n):Uint8Array.prototype.lastIndexOf.call(t,e,n):y(t,[e],n,i,o);throw new TypeError("val must be string, number or Buffer")}function y(t,e,n,i,o){var r,s=1,a=t.length,c=e.length;if(void 0!==i&&("ucs2"===(i=String(i).toLowerCase())||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(t.length<2||e.length<2)return-1;s=2,a/=2,c/=2,n/=2}function l(t,e){return 1===s?t[e]:t.readUInt16BE(e*s)}if(o){var u=-1;for(r=n;r<a;r++)if(l(t,r)===l(e,-1===u?0:r-u)){if(-1===u&&(u=r),r-u+1===c)return u*s}else-1!==u&&(r-=r-u),u=-1}else for(n+c>a&&(n=a-c),r=n;r>=0;r--){for(var f=!0,h=0;h<c;h++)if(l(t,r+h)!==l(e,h)){f=!1;break}if(f)return r}return-1}function x(t,e,n,i){n=Number(n)||0;var o=t.length-n;i?(i=Number(i))>o&&(i=o):i=o;var r=e.length;if(r%2!=0)throw new TypeError("Invalid hex string");i>r/2&&(i=r/2);for(var s=0;s<i;++s){var a=parseInt(e.substr(2*s,2),16);if(isNaN(a))return s;t[n+s]=a}return s}function m(t,e,n,i){return W(B(e,t.length-n),t,n,i)}function P(t,e,n,i){return W(function(t){for(var e=[],n=0;n<t.length;++n)e.push(255&t.charCodeAt(n));return e}(e),t,n,i)}function _(t,e,n,i){return P(t,e,n,i)}function b(t,e,n,i){return W(U(e),t,n,i)}function w(t,e,n,i){return W(function(t,e){for(var n,i,o,r=[],s=0;s<t.length&&!((e-=2)<0);++s)n=t.charCodeAt(s),i=n>>8,o=n%256,r.push(o),r.push(i);return r}(e,t.length-n),t,n,i)}function C(t,e,n){return 0===e&&n===t.length?i.fromByteArray(t):i.fromByteArray(t.slice(e,n))}function S(t,e,n){n=Math.min(t.length,n);for(var i=[],o=e;o<n;){var r,s,a,c,l=t[o],u=null,f=l>239?4:l>223?3:l>191?2:1;if(o+f<=n)switch(f){case 1:l<128&&(u=l);break;case 2:128==(192&(r=t[o+1]))&&(c=(31&l)<<6|63&r)>127&&(u=c);break;case 3:r=t[o+1],s=t[o+2],128==(192&r)&&128==(192&s)&&(c=(15&l)<<12|(63&r)<<6|63&s)>2047&&(c<55296||c>57343)&&(u=c);break;case 4:r=t[o+1],s=t[o+2],a=t[o+3],128==(192&r)&&128==(192&s)&&128==(192&a)&&(c=(15&l)<<18|(63&r)<<12|(63&s)<<6|63&a)>65535&&c<1114112&&(u=c)}null===u?(u=65533,f=1):u>65535&&(u-=65536,i.push(u>>>10&1023|55296),u=56320|1023&u),i.push(u),o+=f}return function(t){var e=t.length;if(e<=A)return String.fromCharCode.apply(String,t);var n="",i=0;for(;i<e;)n+=String.fromCharCode.apply(String,t.slice(i,i+=A));return n}(i)}e.Buffer=c,e.SlowBuffer=function(t){+t!=t&&(t=0);return c.alloc(+t)},e.INSPECT_MAX_BYTES=50,c.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=s(),c.poolSize=8192,c._augment=function(t){return t.__proto__=c.prototype,t},c.from=function(t,e,n){return l(null,t,e,n)},c.TYPED_ARRAY_SUPPORT&&(c.prototype.__proto__=Uint8Array.prototype,c.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&c[Symbol.species]===c&&Object.defineProperty(c,Symbol.species,{value:null,configurable:!0})),c.alloc=function(t,e,n){return function(t,e,n,i){return u(e),e<=0?a(t,e):void 0!==n?"string"==typeof i?a(t,e).fill(n,i):a(t,e).fill(n):a(t,e)}(null,t,e,n)},c.allocUnsafe=function(t){return f(null,t)},c.allocUnsafeSlow=function(t){return f(null,t)},c.isBuffer=function(t){return!(null==t||!t._isBuffer)},c.compare=function(t,e){if(!c.isBuffer(t)||!c.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var n=t.length,i=e.length,o=0,r=Math.min(n,i);o<r;++o)if(t[o]!==e[o]){n=t[o],i=e[o];break}return n<i?-1:i<n?1:0},c.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(t,e){if(!r(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return c.alloc(0);var n;if(void 0===e)for(e=0,n=0;n<t.length;++n)e+=t[n].length;var i=c.allocUnsafe(e),o=0;for(n=0;n<t.length;++n){var s=t[n];if(!c.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(i,o),o+=s.length}return i},c.byteLength=g,c.prototype._isBuffer=!0,c.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)d(this,e,e+1);return this},c.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)d(this,e,e+3),d(this,e+1,e+2);return this},c.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)d(this,e,e+7),d(this,e+1,e+6),d(this,e+2,e+5),d(this,e+3,e+4);return this},c.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?S(this,0,t):function(t,e,n){var i=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return M(this,e,n);case"utf8":case"utf-8":return S(this,e,n);case"ascii":return L(this,e,n);case"latin1":case"binary":return E(this,e,n);case"base64":return C(this,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,n);default:if(i)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),i=!0}}.apply(this,arguments)},c.prototype.equals=function(t){if(!c.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===c.compare(this,t)},c.prototype.inspect=function(){var t="",n=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(t+=" ... ")),"<Buffer "+t+">"},c.prototype.compare=function(t,e,n,i,o){if(!c.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===n&&(n=t?t.length:0),void 0===i&&(i=0),void 0===o&&(o=this.length),e<0||n>t.length||i<0||o>this.length)throw new RangeError("out of range index");if(i>=o&&e>=n)return 0;if(i>=o)return-1;if(e>=n)return 1;if(this===t)return 0;for(var r=(o>>>=0)-(i>>>=0),s=(n>>>=0)-(e>>>=0),a=Math.min(r,s),l=this.slice(i,o),u=t.slice(e,n),f=0;f<a;++f)if(l[f]!==u[f]){r=l[f],s=u[f];break}return r<s?-1:s<r?1:0},c.prototype.includes=function(t,e,n){return-1!==this.indexOf(t,e,n)},c.prototype.indexOf=function(t,e,n){return v(this,t,e,n,!0)},c.prototype.lastIndexOf=function(t,e,n){return v(this,t,e,n,!1)},c.prototype.write=function(t,e,n,i){if(void 0===e)i="utf8",n=this.length,e=0;else if(void 0===n&&"string"==typeof e)i=e,n=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(n)?(n|=0,void 0===i&&(i="utf8")):(i=n,n=void 0)}var o=this.length-e;if((void 0===n||n>o)&&(n=o),t.length>0&&(n<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var r=!1;;)switch(i){case"hex":return x(this,t,e,n);case"utf8":case"utf-8":return m(this,t,e,n);case"ascii":return P(this,t,e,n);case"latin1":case"binary":return _(this,t,e,n);case"base64":return b(this,t,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return w(this,t,e,n);default:if(r)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),r=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var A=4096;function L(t,e,n){var i="";n=Math.min(t.length,n);for(var o=e;o<n;++o)i+=String.fromCharCode(127&t[o]);return i}function E(t,e,n){var i="";n=Math.min(t.length,n);for(var o=e;o<n;++o)i+=String.fromCharCode(t[o]);return i}function M(t,e,n){var i=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>i)&&(n=i);for(var o="",r=e;r<n;++r)o+=D(t[r]);return o}function T(t,e,n){for(var i=t.slice(e,n),o="",r=0;r<i.length;r+=2)o+=String.fromCharCode(i[r]+256*i[r+1]);return o}function I(t,e,n){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>n)throw new RangeError("Trying to access beyond buffer length")}function z(t,e,n,i,o,r){if(!c.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>o||e<r)throw new RangeError('"value" argument is out of bounds');if(n+i>t.length)throw new RangeError("Index out of range")}function k(t,e,n,i){e<0&&(e=65535+e+1);for(var o=0,r=Math.min(t.length-n,2);o<r;++o)t[n+o]=(e&255<<8*(i?o:1-o))>>>8*(i?o:1-o)}function F(t,e,n,i){e<0&&(e=4294967295+e+1);for(var o=0,r=Math.min(t.length-n,4);o<r;++o)t[n+o]=e>>>8*(i?o:3-o)&255}function O(t,e,n,i,o,r){if(n+i>t.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function j(t,e,n,i,r){return r||O(t,0,n,4),o.write(t,e,n,i,23,4),n+4}function R(t,e,n,i,r){return r||O(t,0,n,8),o.write(t,e,n,i,52,8),n+8}c.prototype.slice=function(t,e){var n,i=this.length;if((t=~~t)<0?(t+=i)<0&&(t=0):t>i&&(t=i),(e=void 0===e?i:~~e)<0?(e+=i)<0&&(e=0):e>i&&(e=i),e<t&&(e=t),c.TYPED_ARRAY_SUPPORT)(n=this.subarray(t,e)).__proto__=c.prototype;else{var o=e-t;n=new c(o,void 0);for(var r=0;r<o;++r)n[r]=this[r+t]}return n},c.prototype.readUIntLE=function(t,e,n){t|=0,e|=0,n||I(t,e,this.length);for(var i=this[t],o=1,r=0;++r<e&&(o*=256);)i+=this[t+r]*o;return i},c.prototype.readUIntBE=function(t,e,n){t|=0,e|=0,n||I(t,e,this.length);for(var i=this[t+--e],o=1;e>0&&(o*=256);)i+=this[t+--e]*o;return i},c.prototype.readUInt8=function(t,e){return e||I(t,1,this.length),this[t]},c.prototype.readUInt16LE=function(t,e){return e||I(t,2,this.length),this[t]|this[t+1]<<8},c.prototype.readUInt16BE=function(t,e){return e||I(t,2,this.length),this[t]<<8|this[t+1]},c.prototype.readUInt32LE=function(t,e){return e||I(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},c.prototype.readUInt32BE=function(t,e){return e||I(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},c.prototype.readIntLE=function(t,e,n){t|=0,e|=0,n||I(t,e,this.length);for(var i=this[t],o=1,r=0;++r<e&&(o*=256);)i+=this[t+r]*o;return i>=(o*=128)&&(i-=Math.pow(2,8*e)),i},c.prototype.readIntBE=function(t,e,n){t|=0,e|=0,n||I(t,e,this.length);for(var i=e,o=1,r=this[t+--i];i>0&&(o*=256);)r+=this[t+--i]*o;return r>=(o*=128)&&(r-=Math.pow(2,8*e)),r},c.prototype.readInt8=function(t,e){return e||I(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},c.prototype.readInt16LE=function(t,e){e||I(t,2,this.length);var n=this[t]|this[t+1]<<8;return 32768&n?4294901760|n:n},c.prototype.readInt16BE=function(t,e){e||I(t,2,this.length);var n=this[t+1]|this[t]<<8;return 32768&n?4294901760|n:n},c.prototype.readInt32LE=function(t,e){return e||I(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},c.prototype.readInt32BE=function(t,e){return e||I(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},c.prototype.readFloatLE=function(t,e){return e||I(t,4,this.length),o.read(this,t,!0,23,4)},c.prototype.readFloatBE=function(t,e){return e||I(t,4,this.length),o.read(this,t,!1,23,4)},c.prototype.readDoubleLE=function(t,e){return e||I(t,8,this.length),o.read(this,t,!0,52,8)},c.prototype.readDoubleBE=function(t,e){return e||I(t,8,this.length),o.read(this,t,!1,52,8)},c.prototype.writeUIntLE=function(t,e,n,i){(t=+t,e|=0,n|=0,i)||z(this,t,e,n,Math.pow(2,8*n)-1,0);var o=1,r=0;for(this[e]=255&t;++r<n&&(o*=256);)this[e+r]=t/o&255;return e+n},c.prototype.writeUIntBE=function(t,e,n,i){(t=+t,e|=0,n|=0,i)||z(this,t,e,n,Math.pow(2,8*n)-1,0);var o=n-1,r=1;for(this[e+o]=255&t;--o>=0&&(r*=256);)this[e+o]=t/r&255;return e+n},c.prototype.writeUInt8=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,1,255,0),c.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},c.prototype.writeUInt16LE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):k(this,t,e,!0),e+2},c.prototype.writeUInt16BE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):k(this,t,e,!1),e+2},c.prototype.writeUInt32LE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):F(this,t,e,!0),e+4},c.prototype.writeUInt32BE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):F(this,t,e,!1),e+4},c.prototype.writeIntLE=function(t,e,n,i){if(t=+t,e|=0,!i){var o=Math.pow(2,8*n-1);z(this,t,e,n,o-1,-o)}var r=0,s=1,a=0;for(this[e]=255&t;++r<n&&(s*=256);)t<0&&0===a&&0!==this[e+r-1]&&(a=1),this[e+r]=(t/s>>0)-a&255;return e+n},c.prototype.writeIntBE=function(t,e,n,i){if(t=+t,e|=0,!i){var o=Math.pow(2,8*n-1);z(this,t,e,n,o-1,-o)}var r=n-1,s=1,a=0;for(this[e+r]=255&t;--r>=0&&(s*=256);)t<0&&0===a&&0!==this[e+r+1]&&(a=1),this[e+r]=(t/s>>0)-a&255;return e+n},c.prototype.writeInt8=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,1,127,-128),c.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},c.prototype.writeInt16LE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):k(this,t,e,!0),e+2},c.prototype.writeInt16BE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):k(this,t,e,!1),e+2},c.prototype.writeInt32LE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,4,2147483647,-2147483648),c.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):F(this,t,e,!0),e+4},c.prototype.writeInt32BE=function(t,e,n){return t=+t,e|=0,n||z(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),c.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):F(this,t,e,!1),e+4},c.prototype.writeFloatLE=function(t,e,n){return j(this,t,e,!0,n)},c.prototype.writeFloatBE=function(t,e,n){return j(this,t,e,!1,n)},c.prototype.writeDoubleLE=function(t,e,n){return R(this,t,e,!0,n)},c.prototype.writeDoubleBE=function(t,e,n){return R(this,t,e,!1,n)},c.prototype.copy=function(t,e,n,i){if(n||(n=0),i||0===i||(i=this.length),e>=t.length&&(e=t.length),e||(e=0),i>0&&i<n&&(i=n),i===n)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),t.length-e<i-n&&(i=t.length-e+n);var o,r=i-n;if(this===t&&n<e&&e<i)for(o=r-1;o>=0;--o)t[o+e]=this[o+n];else if(r<1e3||!c.TYPED_ARRAY_SUPPORT)for(o=0;o<r;++o)t[o+e]=this[o+n];else Uint8Array.prototype.set.call(t,this.subarray(n,n+r),e);return r},c.prototype.fill=function(t,e,n,i){if("string"==typeof t){if("string"==typeof e?(i=e,e=0,n=this.length):"string"==typeof n&&(i=n,n=this.length),1===t.length){var o=t.charCodeAt(0);o<256&&(t=o)}if(void 0!==i&&"string"!=typeof i)throw new TypeError("encoding must be a string");if("string"==typeof i&&!c.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<n)throw new RangeError("Out of range index");if(n<=e)return this;var r;if(e>>>=0,n=void 0===n?this.length:n>>>0,t||(t=0),"number"==typeof t)for(r=e;r<n;++r)this[r]=t;else{var s=c.isBuffer(t)?t:B(new c(t,i).toString()),a=s.length;for(r=0;r<n-e;++r)this[r+e]=s[r%a]}return this};var N=/[^+\/0-9A-Za-z-_]/g;function D(t){return t<16?"0"+t.toString(16):t.toString(16)}function B(t,e){var n;e=e||1/0;for(var i=t.length,o=null,r=[],s=0;s<i;++s){if((n=t.charCodeAt(s))>55295&&n<57344){if(!o){if(n>56319){(e-=3)>-1&&r.push(239,191,189);continue}if(s+1===i){(e-=3)>-1&&r.push(239,191,189);continue}o=n;continue}if(n<56320){(e-=3)>-1&&r.push(239,191,189),o=n;continue}n=65536+(o-55296<<10|n-56320)}else o&&(e-=3)>-1&&r.push(239,191,189);if(o=null,n<128){if((e-=1)<0)break;r.push(n)}else if(n<2048){if((e-=2)<0)break;r.push(n>>6|192,63&n|128)}else if(n<65536){if((e-=3)<0)break;r.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;r.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return r}function U(t){return i.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(N,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function W(t,e,n,i){for(var o=0;o<i&&!(o+n>=e.length||o>=t.length);++o)e[o+n]=t[o];return o}}).call(this,n(6))},function(t,e){},function(t,e){},function(t,e,n){"use strict";function i(t,e,n){n=n||2;var i,a,c,l,u,p,d,v=e&&e.length,y=v?e[0]*n:t.length,x=o(t,0,y,n,!0),m=[];if(!x)return m;if(v&&(x=function(t,e,n,i){var s,a,c,l,u,p=[];for(s=0,a=e.length;s<a;s++)c=e[s]*i,l=s<a-1?e[s+1]*i:t.length,(u=o(t,c,l,i,!1))===u.next&&(u.steiner=!0),p.push(g(u));for(p.sort(f),s=0;s<p.length;s++)h(p[s],n),n=r(n,n.next);return n}(t,e,x,n)),t.length>80*n){i=c=t[0],a=l=t[1];for(var P=n;P<y;P+=n)(u=t[P])<i&&(i=u),(p=t[P+1])<a&&(a=p),u>c&&(c=u),p>l&&(l=p);d=0!==(d=Math.max(c-i,l-a))?1/d:0}return s(x,m,n,i,a,d),m}function o(t,e,n,i,o){var r,s;if(o===S(t,e,n,i)>0)for(r=e;r<n;r+=i)s=b(r,t[r],t[r+1],s);else for(r=n-i;r>=e;r-=i)s=b(r,t[r],t[r+1],s);return s&&x(s,s.next)&&(w(s),s=s.next),s}function r(t,e){if(!t)return t;e||(e=t);var n,i=t;do{if(n=!1,i.steiner||!x(i,i.next)&&0!==y(i.prev,i,i.next))i=i.next;else{if(w(i),(i=e=i.prev)===i.next)break;n=!0}}while(n||i!==e);return e}function s(t,e,n,i,o,f,h){if(t){!h&&f&&function(t,e,n,i){var o=t;do{null===o.z&&(o.z=p(o.x,o.y,e,n,i)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==t);o.prevZ.nextZ=null,o.prevZ=null,function(t){var e,n,i,o,r,s,a,c,l=1;do{for(n=t,t=null,r=null,s=0;n;){for(s++,i=n,a=0,e=0;e<l&&(a++,i=i.nextZ);e++);for(c=l;a>0||c>0&&i;)0!==a&&(0===c||!i||n.z<=i.z)?(o=n,n=n.nextZ,a--):(o=i,i=i.nextZ,c--),r?r.nextZ=o:t=o,o.prevZ=r,r=o;n=i}r.nextZ=null,l*=2}while(s>1)}(o)}(t,i,o,f);for(var g,d,v=t;t.prev!==t.next;)if(g=t.prev,d=t.next,f?c(t,i,o,f):a(t))e.push(g.i/n),e.push(t.i/n),e.push(d.i/n),w(t),t=d.next,v=d.next;else if((t=d)===v){h?1===h?s(t=l(t,e,n),e,n,i,o,f,2):2===h&&u(t,e,n,i,o,f):s(r(t),e,n,i,o,f,1);break}}}function a(t){var e=t.prev,n=t,i=t.next;if(y(e,n,i)>=0)return!1;for(var o=t.next.next;o!==t.prev;){if(d(e.x,e.y,n.x,n.y,i.x,i.y,o.x,o.y)&&y(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function c(t,e,n,i){var o=t.prev,r=t,s=t.next;if(y(o,r,s)>=0)return!1;for(var a=o.x<r.x?o.x<s.x?o.x:s.x:r.x<s.x?r.x:s.x,c=o.y<r.y?o.y<s.y?o.y:s.y:r.y<s.y?r.y:s.y,l=o.x>r.x?o.x>s.x?o.x:s.x:r.x>s.x?r.x:s.x,u=o.y>r.y?o.y>s.y?o.y:s.y:r.y>s.y?r.y:s.y,f=p(a,c,e,n,i),h=p(l,u,e,n,i),g=t.prevZ,v=t.nextZ;g&&g.z>=f&&v&&v.z<=h;){if(g!==t.prev&&g!==t.next&&d(o.x,o.y,r.x,r.y,s.x,s.y,g.x,g.y)&&y(g.prev,g,g.next)>=0)return!1;if(g=g.prevZ,v!==t.prev&&v!==t.next&&d(o.x,o.y,r.x,r.y,s.x,s.y,v.x,v.y)&&y(v.prev,v,v.next)>=0)return!1;v=v.nextZ}for(;g&&g.z>=f;){if(g!==t.prev&&g!==t.next&&d(o.x,o.y,r.x,r.y,s.x,s.y,g.x,g.y)&&y(g.prev,g,g.next)>=0)return!1;g=g.prevZ}for(;v&&v.z<=h;){if(v!==t.prev&&v!==t.next&&d(o.x,o.y,r.x,r.y,s.x,s.y,v.x,v.y)&&y(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function l(t,e,n){var i=t;do{var o=i.prev,r=i.next.next;!x(o,r)&&m(o,i,i.next,r)&&P(o,r)&&P(r,o)&&(e.push(o.i/n),e.push(i.i/n),e.push(r.i/n),w(i),w(i.next),i=t=r),i=i.next}while(i!==t);return i}function u(t,e,n,i,o,a){var c=t;do{for(var l=c.next.next;l!==c.prev;){if(c.i!==l.i&&v(c,l)){var u=_(c,l);return c=r(c,c.next),u=r(u,u.next),s(c,e,n,i,o,a),void s(u,e,n,i,o,a)}l=l.next}c=c.next}while(c!==t)}function f(t,e){return t.x-e.x}function h(t,e){if(e=function(t,e){var n,i=e,o=t.x,r=t.y,s=-1/0;do{if(r<=i.y&&r>=i.next.y&&i.next.y!==i.y){var a=i.x+(r-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(a<=o&&a>s){if(s=a,a===o){if(r===i.y)return i;if(r===i.next.y)return i.next}n=i.x<i.next.x?i:i.next}}i=i.next}while(i!==e);if(!n)return null;if(o===s)return n.prev;var c,l=n,u=n.x,f=n.y,h=1/0;i=n.next;for(;i!==l;)o>=i.x&&i.x>=u&&o!==i.x&&d(r<f?o:s,r,u,f,r<f?s:o,r,i.x,i.y)&&((c=Math.abs(r-i.y)/(o-i.x))<h||c===h&&i.x>n.x)&&P(i,t)&&(n=i,h=c),i=i.next;return n}(t,e)){var n=_(e,t);r(n,n.next)}}function p(t,e,n,i,o){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*o)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*o)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function g(t){var e=t,n=t;do{e.x<n.x&&(n=e),e=e.next}while(e!==t);return n}function d(t,e,n,i,o,r,s,a){return(o-s)*(e-a)-(t-s)*(r-a)>=0&&(t-s)*(i-a)-(n-s)*(e-a)>=0&&(n-s)*(r-a)-(o-s)*(i-a)>=0}function v(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){var n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&m(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&P(t,e)&&P(e,t)&&function(t,e){var n=t,i=!1,o=(t.x+e.x)/2,r=(t.y+e.y)/2;do{n.y>r!=n.next.y>r&&n.next.y!==n.y&&o<(n.next.x-n.x)*(r-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next}while(n!==t);return i}(t,e)}function y(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function x(t,e){return t.x===e.x&&t.y===e.y}function m(t,e,n,i){return!!(x(t,e)&&x(n,i)||x(t,i)&&x(n,e))||y(t,e,n)>0!=y(t,e,i)>0&&y(n,i,t)>0!=y(n,i,e)>0}function P(t,e){return y(t.prev,t,t.next)<0?y(t,e,t.next)>=0&&y(t,t.prev,e)>=0:y(t,e,t.prev)<0||y(t,t.next,e)<0}function _(t,e){var n=new C(t.i,t.x,t.y),i=new C(e.i,e.x,e.y),o=t.next,r=e.prev;return t.next=e,e.prev=t,n.next=o,o.prev=n,i.next=n,n.prev=i,r.next=i,i.prev=r,i}function b(t,e,n,i){var o=new C(t,e,n);return i?(o.next=i.next,o.prev=i,i.next.prev=o,i.next=o):(o.prev=o,o.next=o),o}function w(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function C(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function S(t,e,n,i){for(var o=0,r=e,s=n-i;r<n;r+=i)o+=(t[s]-t[r])*(t[r+1]+t[s+1]),s=r;return o}t.exports=i,t.exports.default=i,i.deviation=function(t,e,n,i){var o=e&&e.length,r=o?e[0]*n:t.length,s=Math.abs(S(t,0,r,n));if(o)for(var a=0,c=e.length;a<c;a++){var l=e[a]*n,u=a<c-1?e[a+1]*n:t.length;s-=Math.abs(S(t,l,u,n))}var f=0;for(a=0;a<i.length;a+=3){var h=i[a]*n,p=i[a+1]*n,g=i[a+2]*n;f+=Math.abs((t[h]-t[g])*(t[p+1]-t[h+1])-(t[h]-t[p])*(t[g+1]-t[h+1]))}return 0===s&&0===f?0:Math.abs((f-s)/s)},i.flatten=function(t){for(var e=t[0][0].length,n={vertices:[],holes:[],dimensions:e},i=0,o=0;o<t.length;o++){for(var r=0;r<t[o].length;r++)for(var s=0;s<e;s++)n.vertices.push(t[o][r][s]);o>0&&(i+=t[o-1].length,n.holes.push(i))}return n}},function(t,e,n){"use strict";t.exports=o;var i=1e20;function o(t,e,n,i,o,r){this.fontSize=t||24,this.buffer=void 0===e?3:e,this.cutoff=i||.25,this.fontFamily=o||"sans-serif",this.fontWeight=r||"normal",this.radius=n||8;var s=this.size=this.fontSize+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=s,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(s*s),this.gridInner=new Float64Array(s*s),this.f=new Float64Array(s),this.d=new Float64Array(s),this.z=new Float64Array(s+1),this.v=new Int16Array(s),this.middle=Math.round(s/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}function r(t,e,n,i,o,r,a){for(var c=0;c<e;c++){for(var l=0;l<n;l++)i[l]=t[l*e+c];for(s(i,o,r,a,n),l=0;l<n;l++)t[l*e+c]=o[l]}for(l=0;l<n;l++){for(c=0;c<e;c++)i[c]=t[l*e+c];for(s(i,o,r,a,e),c=0;c<e;c++)t[l*e+c]=Math.sqrt(o[c])}}function s(t,e,n,o,r){n[0]=0,o[0]=-i,o[1]=+i;for(var s=1,a=0;s<r;s++){for(var c=(t[s]+s*s-(t[n[a]]+n[a]*n[a]))/(2*s-2*n[a]);c<=o[a];)a--,c=(t[s]+s*s-(t[n[a]]+n[a]*n[a]))/(2*s-2*n[a]);n[++a]=s,o[a]=c,o[a+1]=+i}for(s=0,a=0;s<r;s++){for(;o[a+1]<s;)a++;e[s]=(s-n[a])*(s-n[a])+t[n[a]]}}o.prototype.draw=function(t){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.fillText(t,this.buffer,this.middle);for(var e=this.ctx.getImageData(0,0,this.size,this.size),n=new Uint8ClampedArray(this.size*this.size),o=0;o<this.size*this.size;o++){var s=e.data[4*o+3]/255;this.gridOuter[o]=1===s?0:0===s?i:Math.pow(Math.max(0,.5-s),2),this.gridInner[o]=1===s?i:0===s?0:Math.pow(Math.max(0,s-.5),2)}for(r(this.gridOuter,this.size,this.size,this.f,this.d,this.v,this.z),r(this.gridInner,this.size,this.size,this.f,this.d,this.v,this.z),o=0;o<this.size*this.size;o++){var a=this.gridOuter[o]-this.gridInner[o];n[o]=Math.max(0,Math.min(255,Math.round(255-255*(a/this.radius+this.cutoff))))}return n}},function(t,e,n){"use strict";function i(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=[],i=!0,o=!1,r=void 0;try{for(var s,a=t[Symbol.iterator]();!(i=(s=a.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0);}catch(t){o=!0,r=t}finally{try{i||null==a.return||a.return()}finally{if(o)throw r}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var o=n(5);n.d(e,"a",function(){return l});var r=!1,s=!0,a=new Map([["image/png",function(t){var e=f(t);if(e.byteLength<24||2303741511!==e.getUint32(0,r))return null;return{width:e.getUint32(16,r),height:e.getUint32(20,r)}}],["image/jpeg",function(t){var e=f(t);if(e.byteLength<2||65496!==e.getUint16(0,r))return null;var n=function(){for(var t=new Set([65499,65476,65484,65501,65534]),e=65504;e<65520;++e)t.add(e);var n=new Set([65472,65473,65474,65475,65477,65478,65479,65481,65482,65483,65485,65486,65487,65502]);return{tableMarkers:t,sofMarkers:n}}(),i=n.tableMarkers,o=n.sofMarkers,s=2;for(;s<e.byteLength;){var a=e.getUint16(s,r);if(o.has(a))return{height:e.getUint16(s+5,r),width:e.getUint16(s+7,r)};if(!i.has(a))return null;s+=2,s+=e.getUint16(s,r)}return null}],["image/gif",function(t){var e=f(t);if(e.byteLength<10||1195984440!==e.getUint32(0,r))return null;return{width:e.getUint16(6,s),height:e.getUint16(8,s)}}],["image/bmp",function(t){var e=f(t);if(16973!==e.getUint16(0,r))return null;return{width:e.getUint32(18,s),height:e.getUint32(22,s)}}]]),c="Invalid MIME type. Supported MIME types are: ".concat(Array.from(a.keys()).join(", "));function l(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(e){var n=a.get(e);if(!n)throw new Error(c);var i=n(t);if(!i)throw new Error("invalid image data for type: ".concat(e));return i}var o=u(t,e);if(!o)throw new Error(c);return o}function u(t,e){var n=!0,o=!1,r=void 0;try{for(var s,c=a.entries()[Symbol.iterator]();!(n=(s=c.next()).done);n=!0){var l=i(s.value,2),u=l[0],f=(0,l[1])(t);if(f)return f.mimeType=u,f}}catch(t){o=!0,r=t}finally{try{n||null==c.return||c.return()}finally{if(o)throw r}}return null}function f(t){if(o.a&&(t=Object(o.a)(t)),t instanceof ArrayBuffer||ArrayBuffer.isView(t))return new DataView(t.buffer||t);throw new Error("toDataView")}},function(t,e,n){(function(e){const i=n(20),o=("undefined"==typeof window?e:window).deck||{};if(!o.Layer)throw new Error("@deck.gl/core is not found");t.exports=Object.assign(o,i)}).call(this,n(6))},,function(t,e,n){var i=function(){return this||"object"==typeof self&&self}()||Function("return this")(),o=i.regeneratorRuntime&&Object.getOwnPropertyNames(i).indexOf("regeneratorRuntime")>=0,r=o&&i.regeneratorRuntime;if(i.regeneratorRuntime=void 0,t.exports=n(16),o)i.regeneratorRuntime=r;else try{delete i.regeneratorRuntime}catch(t){i.regeneratorRuntime=void 0}},function(t,e){!function(e){"use strict";var n,i=Object.prototype,o=i.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},s=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",c=r.toStringTag||"@@toStringTag",l="object"==typeof t,u=e.regeneratorRuntime;if(u)l&&(t.exports=u);else{(u=e.regeneratorRuntime=l?t.exports:{}).wrap=P;var f="suspendedStart",h="suspendedYield",p="executing",g="completed",d={},v={};v[s]=function(){return this};var y=Object.getPrototypeOf,x=y&&y(y(I([])));x&&x!==i&&o.call(x,s)&&(v=x);var m=C.prototype=b.prototype=Object.create(v);w.prototype=m.constructor=C,C.constructor=w,C[c]=w.displayName="GeneratorFunction",u.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===w||"GeneratorFunction"===(e.displayName||e.name))},u.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,C):(t.__proto__=C,c in t||(t[c]="GeneratorFunction")),t.prototype=Object.create(m),t},u.awrap=function(t){return{__await:t}},S(A.prototype),A.prototype[a]=function(){return this},u.AsyncIterator=A,u.async=function(t,e,n,i){var o=new A(P(t,e,n,i));return u.isGeneratorFunction(e)?o:o.next().then(function(t){return t.done?t.value:o.next()})},S(m),m[c]="Generator",m[s]=function(){return this},m.toString=function(){return"[object Generator]"},u.keys=function(t){var e=[];for(var n in t)e.push(n);return e.reverse(),function n(){for(;e.length;){var i=e.pop();if(i in t)return n.value=i,n.done=!1,n}return n.done=!0,n}},u.values=I,T.prototype={constructor:T,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(M),!t)for(var e in this)"t"===e.charAt(0)&&o.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=n)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function i(i,o){return a.type="throw",a.arg=t,e.next=i,o&&(e.method="next",e.arg=n),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var s=this.tryEntries[r],a=s.completion;if("root"===s.tryLoc)return i("end");if(s.tryLoc<=this.prev){var c=o.call(s,"catchLoc"),l=o.call(s,"finallyLoc");if(c&&l){if(this.prev<s.catchLoc)return i(s.catchLoc,!0);if(this.prev<s.finallyLoc)return i(s.finallyLoc)}else if(c){if(this.prev<s.catchLoc)return i(s.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return i(s.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&o.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var r=i;break}}r&&("break"===t||"continue"===t)&&r.tryLoc<=e&&e<=r.finallyLoc&&(r=null);var s=r?r.completion:{};return s.type=t,s.arg=e,r?(this.method="next",this.next=r.finallyLoc,d):this.complete(s)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),d},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),M(n),d}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var i=n.completion;if("throw"===i.type){var o=i.arg;M(n)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,i){return this.delegate={iterator:I(t),resultName:e,nextLoc:i},"next"===this.method&&(this.arg=n),d}}}function P(t,e,n,i){var o=e&&e.prototype instanceof b?e:b,r=Object.create(o.prototype),s=new T(i||[]);return r._invoke=function(t,e,n){var i=f;return function(o,r){if(i===p)throw new Error("Generator is already running");if(i===g){if("throw"===o)throw r;return z()}for(n.method=o,n.arg=r;;){var s=n.delegate;if(s){var a=L(s,n);if(a){if(a===d)continue;return a}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(i===f)throw i=g,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);i=p;var c=_(t,e,n);if("normal"===c.type){if(i=n.done?g:h,c.arg===d)continue;return{value:c.arg,done:n.done}}"throw"===c.type&&(i=g,n.method="throw",n.arg=c.arg)}}}(t,n,s),r}function _(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(t){return{type:"throw",arg:t}}}function b(){}function w(){}function C(){}function S(t){["next","throw","return"].forEach(function(e){t[e]=function(t){return this._invoke(e,t)}})}function A(t){var e;this._invoke=function(n,i){function r(){return new Promise(function(e,r){!function e(n,i,r,s){var a=_(t[n],t,i);if("throw"!==a.type){var c=a.arg,l=c.value;return l&&"object"==typeof l&&o.call(l,"__await")?Promise.resolve(l.__await).then(function(t){e("next",t,r,s)},function(t){e("throw",t,r,s)}):Promise.resolve(l).then(function(t){c.value=t,r(c)},function(t){return e("throw",t,r,s)})}s(a.arg)}(n,i,e,r)})}return e=e?e.then(r,r):r()}}function L(t,e){var i=t.iterator[e.method];if(i===n){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=n,L(t,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var o=_(i,t.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,d;var r=o.arg;return r?r.done?(e[t.resultName]=r.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=n),e.delegate=null,d):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function E(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function M(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function T(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(E,this),this.reset(!0)}function I(t){if(t){var e=t[s];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var i=-1,r=function e(){for(;++i<t.length;)if(o.call(t,i))return e.value=t[i],e.done=!1,e;return e.value=n,e.done=!0,e};return r.next=r}}return{next:z}}function z(){return{value:n,done:!0}}}(function(){return this||"object"==typeof self&&self}()||Function("return this")())},function(t,e,n){"use strict";e.byteLength=function(t){var e=l(t),n=e[0],i=e[1];return 3*(n+i)/4-i},e.toByteArray=function(t){for(var e,n=l(t),i=n[0],s=n[1],a=new r(function(t,e,n){return 3*(e+n)/4-n}(0,i,s)),c=0,u=s>0?i-4:i,f=0;f<u;f+=4)e=o[t.charCodeAt(f)]<<18|o[t.charCodeAt(f+1)]<<12|o[t.charCodeAt(f+2)]<<6|o[t.charCodeAt(f+3)],a[c++]=e>>16&255,a[c++]=e>>8&255,a[c++]=255&e;2===s&&(e=o[t.charCodeAt(f)]<<2|o[t.charCodeAt(f+1)]>>4,a[c++]=255&e);1===s&&(e=o[t.charCodeAt(f)]<<10|o[t.charCodeAt(f+1)]<<4|o[t.charCodeAt(f+2)]>>2,a[c++]=e>>8&255,a[c++]=255&e);return a},e.fromByteArray=function(t){for(var e,n=t.length,o=n%3,r=[],s=0,a=n-o;s<a;s+=16383)r.push(u(t,s,s+16383>a?a:s+16383));1===o?(e=t[n-1],r.push(i[e>>2]+i[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],r.push(i[e>>10]+i[e>>4&63]+i[e<<2&63]+"="));return r.join("")};for(var i=[],o=[],r="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,c=s.length;a<c;++a)i[a]=s[a],o[s.charCodeAt(a)]=a;function l(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=t.indexOf("=");return-1===n&&(n=e),[n,n===e?0:4-n%4]}function u(t,e,n){for(var o,r,s=[],a=e;a<n;a+=3)o=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),s.push(i[(r=o)>>18&63]+i[r>>12&63]+i[r>>6&63]+i[63&r]);return s.join("")}o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,n,i,o){var r,s,a=8*o-i-1,c=(1<<a)-1,l=c>>1,u=-7,f=n?o-1:0,h=n?-1:1,p=t[e+f];for(f+=h,r=p&(1<<-u)-1,p>>=-u,u+=a;u>0;r=256*r+t[e+f],f+=h,u-=8);for(s=r&(1<<-u)-1,r>>=-u,u+=i;u>0;s=256*s+t[e+f],f+=h,u-=8);if(0===r)r=1-l;else{if(r===c)return s?NaN:1/0*(p?-1:1);s+=Math.pow(2,i),r-=l}return(p?-1:1)*s*Math.pow(2,r-i)},e.write=function(t,e,n,i,o,r){var s,a,c,l=8*r-o-1,u=(1<<l)-1,f=u>>1,h=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,p=i?0:r-1,g=i?1:-1,d=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=u):(s=Math.floor(Math.log(e)/Math.LN2),e*(c=Math.pow(2,-s))<1&&(s--,c*=2),(e+=s+f>=1?h/c:h*Math.pow(2,1-f))*c>=2&&(s++,c/=2),s+f>=u?(a=0,s=u):s+f>=1?(a=(e*c-1)*Math.pow(2,o),s+=f):(a=e*Math.pow(2,f-1)*Math.pow(2,o),s=0));o>=8;t[n+p]=255&a,p+=g,a/=256,o-=8);for(s=s<<o|a,l+=o;l>0;t[n+p]=255&s,p+=g,s/=256,l-=8);t[n+p-g]|=128*d}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e,n){"use strict";n.r(e);var i=n(1),o=n(0),r=n.n(o),s="#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nfloat paraboloid(vec2 source, vec2 target, float ratio) {\n\n  vec2 x = mix(source, target, ratio);\n  vec2 center = mix(source, target, 0.5);\n\n  float dSourceCenter = distance(source, center);\n  float dXCenter = distance(x, center);\n  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 getPos(vec2 source, vec2 target, float segmentRatio) {\n  float vertexHeight = sqrt(max(0.0, paraboloid(source, target, segmentRatio))) * instanceHeights;\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target - source);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * vertexHeight * sin(tiltAngle);\n\n  return vec3(\n    mix(source, target, segmentRatio) + tilt,\n    vertexHeight * cos(tiltAngle)\n  );\n}\n\nvoid main(void) {\n  vec2 source = project_position(vec3(instancePositions.xy, 0.0), instancePositions64Low.xy).xy;\n  vec2 target = project_position(vec3(instancePositions.zw, 0.0), instancePositions64Low.zw).xy;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec3 currPos = getPos(source, target, segmentRatio);\n  vec3 nextPos = getPos(source, target, nextSegmentRatio);\n  vec4 curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n  vec4 next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n\n  // Multiply out width and clamp to limits\n  // mercator pixels are interpreted as screen pixels\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  // extrude\n  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels);\n  gl_Position = curr + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n",a="#define SHADER_NAME arc-layer-vertex-shader-64\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\n\nattribute vec4 instancePositions;\nattribute vec4 instancePositions64Low;\n\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\nvec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {\n\n  vec2 x[2];\n  vec2_mix_fp64(source, target, ratio, x);\n  vec2 center[2];\n  vec2_mix_fp64(source, target, 0.5, center);\n\n  vec2 dSourceCenter = vec2_distance_fp64(source, center);\n  vec2 dXCenter = vec2_distance_fp64(x, center);\n  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvoid get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {\n\n  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);\n\n  vec2 position_temp[2];\n\n  vec2_mix_fp64(source, target, segmentRatio, position_temp);\n\n  position[0] = position_temp[0];\n  position[1] = position_temp[1];\n\n  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {\n    vertex_height = vec2(0.0, 0.0);\n  }\n\n  position[2] = sqrt_fp64(vertex_height);\n  position[3] = vec2(1.0, 0.0);\n}\n\nvoid main(void) {\n  vec2 projected_source_coord[2];\n  vec2 projected_target_coord[2];\n\n  project_position_fp64(instancePositions.xy, instancePositions64Low.xy, projected_source_coord);\n  project_position_fp64(instancePositions.zw, instancePositions64Low.zw, projected_target_coord);\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n\n  vec2 curr_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,\n    curr_pos_modelspace);\n\n  vec2 next_pos_modelspace[4];\n\n  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,\n    next_pos_modelspace);\n\n  vec4 curr_pos_clipspace = project_common_position_to_clipspace_fp64(curr_pos_modelspace);\n  vec4 next_pos_clipspace = project_common_position_to_clipspace_fp64(next_pos_modelspace);\n\n  // Multiply out width and clamp to limits\n  // mercator pixels are interpreted as screen pixels\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y, widthPixels);\n\n  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;\n  vColor = vec4(color.rgb, color.a * opacity);\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n",c="#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const{fp64LowPart:l}=o.fp64,u=[0,0,0,255],f={fp64:!1,getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getSourceColor:{type:"accessor",value:u},getTargetColor:{type:"accessor",value:u},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0},getStrokeWidth:{deprecatedFor:"getWidth"}};class h extends i.Layer{getShaders(){return this.use64bitProjection()?{vs:a,fs:c,modules:["project64","picking"]}:{vs:s,fs:c,modules:["picking"]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:4,transition:!0,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstancePositions},instancePositions64Low:{size:4,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstancePositions64Low},instanceSourceColors:{size:4,type:r.a.UNSIGNED_BYTE,transition:!0,accessor:"getSourceColor",defaultValue:u},instanceTargetColors:{size:4,type:r.a.UNSIGNED_BYTE,transition:!0,accessor:"getTargetColor",defaultValue:u},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),t.fp64!==e.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{widthUnits:n,widthScale:i,widthMinPixels:o,widthMaxPixels:r}=this.props,s="pixels"===n?e.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{widthScale:i*s,widthMinPixels:o,widthMaxPixels:r})).draw()}_getModel(t){let e=[];for(let t=0;t<50;t++)e=e.concat([t,-1,0,t,1,0]);const n=new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new o.Geometry({drawMode:r.a.TRIANGLE_STRIP,attributes:{positions:new Float32Array(e)}}),isInstanced:!0,shaderCache:this.context.shaderCache}));return n.setUniforms({numSegments:50}),n}calculateInstancePositions(t){const{data:e,getSourcePosition:n,getTargetPosition:o}=this.props,{value:r}=t;let s=0;const{iterable:a,objectInfo:c}=Object(i.createIterable)(e);for(const t of a){c.index++;const e=n(t,c),i=o(t,c);r[s++]=e[0],r[s++]=e[1],r[s++]=i[0],r[s++]=i[1]}}calculateInstancePositions64Low(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(4));const{data:n,getSourcePosition:o,getTargetPosition:r}=this.props,{value:s}=t;let a=0;const{iterable:c,objectInfo:u}=Object(i.createIterable)(n);for(const t of c){u.index++;const e=o(t,u),n=r(t,u);s[a++]=l(e[0]),s[a++]=l(e[1]),s[a++]=l(n[0]),s[a++]=l(n[1])}}}h.layerName="ArcLayer",h.defaultProps=f;var p=n(2),g=n.n(p),d=n(3),v=n(4);v.a;function y(t,e){return v.a?Object(v.a)(t,e):function(t){if("undefined"==typeof createImageBitmap)throw new Error("parseImage");var e=new Blob([new Uint8Array(t)]);return createImageBitmap(e)}(t)}function x(t,e){return m.apply(this,arguments)}function m(){return(m=Object(d.a)(g.a.mark(function t(e,n){var i,o;return g.a.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:if("undefined"!=typeof Image){t.next=8;break}return t.next=3,fetch(e,n);case 3:return i=t.sent,t.next=6,i.arrayBuffer();case 6:return o=t.sent,t.abrupt("return",y(o));case 8:return t.next=10,P(e,n);case 10:return t.abrupt("return",t.sent);case 11:case"end":return t.stop()}},t)}))).apply(this,arguments)}function P(t,e){return _.apply(this,arguments)}function _(){return(_=Object(d.a)(g.a.mark(function t(e,n){var i,o,r;return g.a.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:if(!/\.svg((\?|#).*)?$/.test(e)){t.next=10;break}return t.next=3,fetch(e,n);case 3:return o=t.sent,t.next=6,o.text();case 6:r=t.sent,i="data:image/svg+xml;base64,".concat(btoa(r)),t.next=13;break;case 10:return t.next=12,e;case 12:i=t.sent;case 13:return t.next=15,new Promise(function(t,o){try{var r=new Image;r.onload=function(){return t(r)},r.onerror=function(t){return o(new Error("Could not load image ".concat(e,": ").concat(t)))},r.crossOrigin=n&&n.crossOrigin||"anonymous",r.src=i}catch(t){o(t)}});case 15:return t.abrupt("return",t.sent);case 16:case"end":return t.stop()}},t)}))).apply(this,arguments)}var b="\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec2 positions64xyLow;\nattribute vec3 instancePickingColors;\n\nvarying vec2 vTexCoord;\n\nvoid main(void) {\n  gl_Position = project_position_to_clipspace(positions, positions64xyLow, vec3(0.0));\n \n  vTexCoord = texCoords;\n \n  picking_setPickingColor(instancePickingColors);\n}\n",w="\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor / 255.0;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor / 255.0, vec4(color, 1.0), alpha);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const{fp64LowPart:C}=o.fp64,S={[r.a.TEXTURE_MIN_FILTER]:r.a.LINEAR_MIPMAP_LINEAR,[r.a.TEXTURE_MAG_FILTER]:r.a.LINEAR,[r.a.TEXTURE_WRAP_S]:r.a.CLAMP_TO_EDGE,[r.a.TEXTURE_WRAP_T]:r.a.CLAMP_TO_EDGE};class A extends i.Layer{getShaders(){const t=this.use64bitProjection()?"project64":"project32";return{vs:b,fs:w,modules:[t,"picking"]}}initializeState(){const t=[-1,-1,0,-1,1,0,1,1,0,1,-1,0];this.getAttributeManager().add({positions:{size:3,update:this.calculatePositions,value:new Float32Array(t)},positions64xyLow:{size:3,update:this.calculatePositions64xyLow,value:new Float32Array(t)}}),this.setState({numInstances:1})}updateState({props:t,oldProps:e,changeFlags:n}){if(t.fp64!==e.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),this.getAttributeManager().invalidateAll()}t.image!==e.image&&this.loadTexture();const i=this.getAttributeManager();t.bounds!==e.bounds&&(this.setState({positions:this._getPositionsFromBounds(t.bounds)}),i.invalidate("positions"),i.invalidate("positions64xyLow"))}_getPositionsFromBounds(t){const e=new Array(12);if(Number.isFinite(t[0]))e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[0],e[4]=t[3],e[5]=0,e[6]=t[2],e[7]=t[3],e[8]=0,e[9]=t[2],e[10]=t[1],e[11]=0;else for(let n=0;n<t.length;n++)e[3*n+0]=t[n][0],e[3*n+1]=t[n][1],e[3*n+2]=t[n][2]||0;return e}_getModel(t){return t?new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,shaderCache:this.context.shaderCache,geometry:new o.Geometry({drawMode:r.a.TRIANGLE_FAN,vertexCount:4,attributes:{texCoords:new Float32Array([0,0,0,1,1,1,1,0])}}),isInstanced:!1})):null}draw({uniforms:t}){const{bitmapTexture:e,model:n}=this.state,{desaturate:i,transparentColor:o,tintColor:r}=this.props;e&&n&&n.setUniforms(Object.assign({},t,{bitmapTexture:e,desaturate:i,transparentColor:o,tintColor:r})).draw()}loadTexture(){const{gl:t}=this.context,{image:e}=this.props;"string"==typeof e?x(e).then(e=>{this.setState({bitmapTexture:new o.Texture2D(t,{data:e,parameters:S})})}):e instanceof o.Texture2D?this.setState({bitmapTexture:e}):(e instanceof Image||e instanceof HTMLCanvasElement)&&this.setState({bitmapTexture:new o.Texture2D(t,{data:e,parameters:S})})}calculatePositions({value:t}){const{positions:e}=this.state;t.set(e)}calculatePositions64xyLow(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(4));const{value:n}=t;n.set(this.state.positions.map(C))}}A.layerName="BitmapLayer",A.defaultProps={image:null,bounds:{type:"array",value:[1,0,0,1],compare:!0},fp64:!1,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]}};var L='#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n  // convert size in meters to pixels, then scaled and clamp\n \n  // project meters to pixels and clamp to limits \n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n\n  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n\n  if (billboard)  {\n    pixelOffset.y *= -1.0;\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.0)); \n    gl_Position.xy += project_pixel_size_to_clipspace(pixelOffset);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset_common); \n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vColor = instanceColors / 255.;\n\n  vColorMode = instanceColorModes;\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n',E="#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\n\nconst float MIN_ALPHA = 0.05;\n\nvoid main(void) {\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n\n  // if colorMode == 0, use pixel color from the texture\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  // Take the global opacity and the alpha from vColor into account for the alpha component\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < MIN_ALPHA) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const M=1024,T=4,I=()=>{},z={[r.a.TEXTURE_MIN_FILTER]:r.a.LINEAR_MIPMAP_LINEAR,[r.a.TEXTURE_MAG_FILTER]:r.a.LINEAR};function k(t,e,n,i){const{naturalWidth:o,naturalHeight:r}=e;return n===o&&i===r?e:(t.canvas.height=i,t.canvas.width=n,t.clearRect(0,0,t.canvas.width,t.canvas.height),t.drawImage(e,0,0,o,r,0,0,n,i),t.canvas)}function F(t){return t&&(t.id||t.url)}function O(t,e,n){for(let i=0;i<e.length;i++){const{icon:o,xOffset:r}=e[i];t[F(o)]=Object.assign({},o,{x:r,y:n})}}class j{constructor(t,{onUpdate:e=I}){this.gl=t,this.onUpdate=e,this._getIcon=null,this._texture=null,this._mapping={},this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._buffer=T,this._canvasWidth=M,this._canvasHeight=0,this._canvas=null}getTexture(){return this._texture}getIconMapping(t,e){const n=this._getIcon(t,e),i=this._autoPacking?F(n):n;return this._mapping[i]||{}}setProps({autoPacking:t,iconAtlas:e,iconMapping:n,data:i,getIcon:o}){void 0!==t&&(this._autoPacking=t),o&&(this._getIcon=o),n&&(this._mapping=n),e&&this._updateIconAtlas(e),this._autoPacking&&(i||o)&&"undefined"!=typeof document&&(this._canvas=this._canvas||document.createElement("canvas"),this._updateAutoPacking(i))}_updateIconAtlas(t){t instanceof o.Texture2D?(t.setParameters(z),this._texture=t,this.onUpdate()):"string"==typeof t&&x(t).then(t=>{this._texture=new o.Texture2D(this.gl,{data:t,parameters:z}),this.onUpdate()})}_updateAutoPacking(t){const e=Object.values(function(t,e,n){if(!t||!e)return null;n=n||{};const o={},{iterable:r,objectInfo:s}=Object(i.createIterable)(t);for(const t of r){s.index++;const i=e(t,s),r=F(i);if(!i)throw new Error("Icon is missing.");if(!i.url)throw new Error("Icon url is missing.");o[r]||n[r]&&i.url===n[r].url||(o[r]=i)}return o}(t,this._getIcon,this._mapping)||{});if(e.length>0){const{mapping:t,xOffset:n,yOffset:i,canvasHeight:r}=function({icons:t,buffer:e,mapping:n={},xOffset:i=0,yOffset:o=0,canvasWidth:r}){let s=0,a=[];for(let c=0;c<t.length;c++){const l=t[c];if(!n[F(l)]){const{height:t,width:c}=l;i+c+e>r&&(O(n,a,o),i=0,o=s+o+e,s=0,a=[]),a.push({icon:l,xOffset:i}),i=i+c+e,s=Math.max(s,t)}}return a.length>0&&O(n,a,o),{mapping:n,xOffset:i,yOffset:o,canvasWidth:r,canvasHeight:(c=s+o+e,Math.pow(2,Math.ceil(Math.log2(c))))};var c}({icons:e,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,xOffset:this._xOffset,yOffset:this._yOffset});this._mapping=t,this._xOffset=n,this._yOffset=i,this._canvasHeight=r,this._texture||(this._texture=new o.Texture2D(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:z})),this._texture.height!==this._canvasHeight&&function(t,e,n){const i=t.width,r=t.height,s=Object(o.readPixelsToBuffer)(t,{});t.resize({width:e,height:n}),t.setSubImageData({data:s,x:0,y:n-r,width:i,height:r,parameters:z}),t.generateMipmap(),s.delete()}(this._texture,this._canvasWidth,this._canvasHeight),this.onUpdate(),this._loadIcons(e)}}_loadIcons(t){const e=this._canvas.getContext("2d"),n=this._texture.height;for(const i of t)x(i.url).then(t=>{const o=F(i),{x:s,y:a,width:c,height:l}=this._mapping[o],u=k(e,t,c,l);this._texture.setSubImageData({data:u,x:s,y:n-a-l,width:c,height:l,parameters:Object.assign({},z,{[r.a.UNPACK_FLIP_Y_WEBGL]:!0})}),this._texture.generateMipmap(),this.onUpdate()})}}const{fp64LowPart:R}=o.fp64,N=[0,0,0,255],D={iconAtlas:null,iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},fp64:!1,billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},getPosition:{type:"accessor",value:t=>t.position},getIcon:{type:"accessor",value:t=>t.icon},getColor:{type:"accessor",value:N},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0}};class B extends i.Layer{getShaders(){const t=this.use64bitProjection()?"project64":"project32";return{vs:L,fs:E,modules:[t,"picking"]}}initializeState(){this.state={iconManager:new j(this.context.gl,{onUpdate:()=>this._onUpdate()})},this.getAttributeManager().addInstanced({instancePositions:{size:3,transition:!0,accessor:"getPosition"},instancePositions64xyLow:{size:2,accessor:"getPosition",update:this.calculateInstancePositions64xyLow},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",update:this.calculateInstanceOffsets},instanceIconFrames:{size:4,accessor:"getIcon",update:this.calculateInstanceIconFrames},instanceColorModes:{size:1,type:r.a.UNSIGNED_BYTE,accessor:"getIcon",update:this.calculateInstanceColorMode},instanceColors:{size:4,type:r.a.UNSIGNED_BYTE,transition:!0,accessor:"getColor",defaultValue:N},instanceAngles:{size:1,transition:!0,accessor:"getAngle",defaultValue:0}})}updateState({oldProps:t,props:e,changeFlags:n}){super.updateState({props:e,oldProps:t,changeFlags:n});const i=this.getAttributeManager(),{iconManager:o}=this.state,{iconAtlas:r,iconMapping:s,data:a,getIcon:c}=e;let l=!1;if(r?(t.iconAtlas!==e.iconAtlas&&o.setProps({iconAtlas:r,autoPacking:!1}),t.iconMapping!==e.iconMapping&&(o.setProps({iconMapping:s}),l=!0)):o.setProps({autoPacking:!0}),(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&(o.setProps({data:a,getIcon:c}),l=!0),l&&(i.invalidate("instanceOffsets"),i.invalidate("instanceIconFrames"),i.invalidate("instanceColorModes")),e.fp64!==t.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),i.invalidateAll()}}draw({uniforms:t}){const{sizeScale:e,sizeMinPixels:n,sizeMaxPixels:i,sizeUnits:o,billboard:r}=this.props,{iconManager:s}=this.state,{viewport:a}=this.context,c=s.getTexture();c&&this.state.model.setUniforms(Object.assign({},t,{iconsTexture:c,iconsTextureDim:[c.width,c.height],sizeScale:e*("pixels"===o?a.distanceScales.metersPerPixel[2]:1),sizeMinPixels:n,sizeMaxPixels:i,billboard:r})).draw()}_getModel(t){return new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new o.Geometry({drawMode:r.a.TRIANGLE_FAN,attributes:{positions:new Float32Array([-1,-1,0,-1,1,0,1,1,0,1,-1,0])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}_onUpdate(){this.setNeedsRedraw()}calculateInstancePositions64xyLow(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(2));const{data:n,getPosition:o}=this.props,{value:r}=t;let s=0;const{iterable:a,objectInfo:c}=Object(i.createIterable)(n);for(const t of a){c.index++;const e=o(t,c);r[s++]=R(e[0]),r[s++]=R(e[1])}}calculateInstanceOffsets(t){const{data:e}=this.props,{iconManager:n}=this.state,{value:o}=t;let r=0;const{iterable:s,objectInfo:a}=Object(i.createIterable)(e);for(const t of s){a.index++;const e=n.getIconMapping(t,a);o[r++]=e.width/2-e.anchorX||0,o[r++]=e.height/2-e.anchorY||0}}calculateInstanceColorMode(t){const{data:e}=this.props,{iconManager:n}=this.state,{value:o}=t;let r=0;const{iterable:s,objectInfo:a}=Object(i.createIterable)(e);for(const t of s){a.index++;const e=n.getIconMapping(t,a).mask;o[r++]=e?1:0}}calculateInstanceIconFrames(t){const{data:e}=this.props,{iconManager:n}=this.state,{value:o}=t;let r=0;const{iterable:s,objectInfo:a}=Object(i.createIterable)(e);for(const t of s){a.index++;const e=n.getIconMapping(t,a);o[r++]=e.x||0,o[r++]=e.y||0,o[r++]=e.width||0,o[r++]=e.height||0}}}B.layerName="IconLayer",B.defaultProps=D;var U="#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec4 instanceSourceTargetPositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;\n  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);\n\n  return offset_clipspace;\n}\n\nvoid main(void) {\n  // Position\n  vec4 source = project_position_to_clipspace(instanceSourcePositions, instanceSourceTargetPositions64xyLow.xy, vec3(0.));\n  vec4 target = project_position_to_clipspace(instanceTargetPositions, instanceSourceTargetPositions64xyLow.zw, vec3(0.));\n\n  // Multiply out width and clamp to limits\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  \n  // linear interpolation of source & target to pick right coord\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n\n  // extrude\n  vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels);\n  gl_Position = p + vec4(offset, 0.0, 0.0);\n\n  // Color\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n",W="#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const{fp64LowPart:G}=o.fp64,V={fp64:!1,getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0},getStrokeWidth:{deprecatedFor:"getWidth"}};class Y extends i.Layer{getShaders(){const t=this.use64bitProjection()?"project64":"project32";return{vs:U,fs:W,modules:[t,"picking"]}}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,transition:!0,accessor:"getTargetPosition"},instanceSourceTargetPositions64xyLow:{size:4,accessor:["getSourcePosition","getTargetPosition"],update:this.calculateInstanceSourceTargetPositions64xyLow},instanceColors:{size:4,type:r.a.UNSIGNED_BYTE,transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),t.fp64!==e.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{widthUnits:n,widthScale:i,widthMinPixels:o,widthMaxPixels:r}=this.props,s="pixels"===n?e.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{widthScale:i*s,widthMinPixels:o,widthMaxPixels:r})).draw()}_getModel(t){return new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new o.Geometry({drawMode:r.a.TRIANGLE_STRIP,attributes:{positions:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}calculateInstanceSourceTargetPositions64xyLow(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(4));const{data:n,getSourcePosition:o,getTargetPosition:r}=this.props,{value:s}=t;let a=0;const{iterable:c,objectInfo:l}=Object(i.createIterable)(n);for(const t of c){l.index++;const e=o(t,l),n=r(t,l);s[a++]=G(e[0]),s[a++]=G(e[1]),s[a++]=G(n[0]),s[a++]=G(n[1])}}}Y.layerName="LineLayer",Y.defaultProps=V;var H="#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n\n  // Find the center of the point and add the current vertex\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.), position_commonspace);\n  gl_Position.xy += project_pixel_size_to_clipspace(positions.xy * radiusPixels);\n\n  // Apply lighting\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, position_commonspace.xyz, project_normal(instanceNormals));\n\n  // Apply opacity to instance color, or return instance picking color\n  vColor = vec4(lightColor, instanceColors.a * opacity) / 255.0;\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n",X="#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const{fp64LowPart:J}=o.fp64,Z=[0,0,0,255],$=[0,0,1],q=new o.PhongMaterial,Q={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},fp64:!1,getPosition:{type:"accessor",value:t=>t.position},getNormal:{type:"accessor",value:$},getColor:{type:"accessor",value:Z},material:q,radiusPixels:{deprecatedFor:"pointSize"}};class K extends i.Layer{getShaders(t){const e=this.use64bitProjection()?"project64":"project32";return{vs:H,fs:X,modules:[e,"gouraud-lighting","picking"]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,transition:!0,accessor:"getPosition"},instancePositions64xyLow:{size:2,accessor:"getPosition",update:this.calculateInstancePositions64xyLow},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:$},instanceColors:{size:4,type:r.a.UNSIGNED_BYTE,transition:!0,accessor:"getColor",defaultValue:Z}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),t.fp64!==e.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{pointSize:n,sizeUnits:i}=this.props,o="meters"===i?e.distanceScales.pixelsPerMeter[2]:1;this.state.model.setUniforms(Object.assign({},t,{radiusPixels:n*o})).draw()}_getModel(t){const e=[];for(let t=0;t<3;t++){const n=t/3*Math.PI*2;e.push(2*Math.cos(n),2*Math.sin(n),0)}return new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new o.Geometry({drawMode:r.a.TRIANGLES,attributes:{positions:new Float32Array(e)}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}calculateInstancePositions64xyLow(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(2));const{data:n,getPosition:o}=this.props,{value:r}=t;let s=0;const{iterable:a,objectInfo:c}=Object(i.createIterable)(n);for(const t of a){c.index++;const e=o(t,c);r[s++]=J(e[0]),r[s++]=J(e[1])}}}K.layerName="PointCloudLayer",K.defaultProps=Q;var tt="#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n  // Multiply out radius and clamp to limits\n  float outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity) / 255.;\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity) / 255.;\n  \n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n",et="#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\n\nvoid main(void) {\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  } \n  if (distToCenter > innerUnitRadius) {\n    gl_FragColor = vLineColor;\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const{fp64LowPart:nt}=o.fp64,it=[0,0,0,255],ot={radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,fp64:!1,filled:!0,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:it},getLineColor:{type:"accessor",value:it},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class rt extends i.Layer{getShaders(t){const e=this.use64bitProjection()?"project64":"project32";return{vs:tt,fs:et,modules:[e,"picking"]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,transition:!0,accessor:"getPosition"},instancePositions64xyLow:{size:2,accessor:"getPosition",update:this.calculateInstancePositions64xyLow},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:4,transition:!0,type:r.a.UNSIGNED_BYTE,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,type:r.a.UNSIGNED_BYTE,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),t.fp64!==e.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),this.getAttributeManager().invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{radiusScale:n,radiusMinPixels:i,radiusMaxPixels:o,stroked:r,filled:s,lineWidthUnits:a,lineWidthScale:c,lineWidthMinPixels:l,lineWidthMaxPixels:u}=this.props,f="pixels"===a?e.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{stroked:r?1:0,filled:s,radiusScale:n,radiusMinPixels:i,radiusMaxPixels:o,lineWidthScale:c*f,lineWidthMinPixels:l,lineWidthMaxPixels:u})).draw()}_getModel(t){return new o.Model(t,Object.assign(this.getShaders(),{id:this.props.id,geometry:new o.Geometry({drawMode:r.a.TRIANGLE_FAN,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,-1,1,0,1,1,0,1,-1,0])}}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}calculateInstancePositions64xyLow(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(2));const{data:n,getPosition:o}=this.props,{value:r}=t;let s=0;const{iterable:a,objectInfo:c}=Object(i.createIterable)(n);for(const t of a){c.index++;const e=o(t,c);r[s++]=nt(e[0]),r[s++]=nt(e[1])}}}rt.layerName="ScatterplotLayer",rt.defaultProps=ot;var st="\n#define SHADER_NAME column-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute float instanceElevations;\nattribute vec2 instancePositions64xyLow;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform float coverage;\nuniform float elevationScale;\n\n// Result\nvarying vec4 vColor;\n\nvoid main(void) {\n\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\n  float elevation = 0.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  }\n\n  // if ahpha == 0.0 or z < 0.0, do not render element\n  float shouldRender = float(instanceColors.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  // project center of column\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec2 centroidPosition64xyLow = instancePositions64xyLow;\n  vec3 pos = vec3(project_size(rotationMatrix * positions.xy + offset) * dotRadius, 0.);\n\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64xyLow, pos, position_commonspace);\n\n  // Light calculations\n  // Worldspace is the linear space after Mercator projection\n\n  vec3 normals_commonspace = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, position_commonspace.xyz, normals_commonspace);\n    vColor = vec4(lightColor, instanceColors.a * opacity) / 255.0;\n  } else {\n    vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.0;\n  }\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n",at="#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const{fp64LowPart:ct}=o.fp64,lt=new o.PhongMaterial,ut=[255,0,255,255],ft={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},extruded:!0,fp64:!1,getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:ut},getElevation:{type:"accessor",value:1e3},material:lt};class ht extends i.Layer{getShaders(){const t=this.use64bitProjection()?"project64":"project32";return{vs:st,fs:at,modules:[t,"gouraud-lighting","picking"]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instancePositions64xyLow:{size:2,accessor:"getPosition",update:this.calculateInstancePositions64xyLow},instanceColors:{size:4,type:r.a.UNSIGNED_BYTE,transition:!0,accessor:"getColor",defaultValue:ut}})}updateState({props:t,oldProps:e,changeFlags:n}){if(super.updateState({props:t,oldProps:e,changeFlags:n}),t.fp64!==e.fp64||t.diskResolution!==e.diskResolution){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),this.getAttributeManager().invalidateAll()}t.vertices!==e.vertices&&this._updateVertices(t.vertices)}getGeometry(t){return new o.CylinderGeometry({radius:1,topCap:!1,bottomCap:!0,height:2,verticalAxis:"z",nradial:t,nvertical:1})}_getModel(t){return new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:this.getGeometry(this.props.diskResolution),isInstanced:!0,shaderCache:this.context.shaderCache}))}_updateVertices(t){if(!t)return;const{diskResolution:e}=this.props;i.log.assert(t.length>=e);const{model:n}=this.state,o=this.getGeometry(this.props.diskResolution),r=o.attributes.POSITION;let s=0;for(let n=0;n<3;n++)for(let n=0;n<=e;n++){const e=t[n]||t[0];r.value[s++]=e[0],r.value[s++]=e[1],s++}n.setProps({geometry:o})}draw({uniforms:t}){const{elevationScale:e,extruded:n,offset:i,coverage:o,radius:r,angle:s}=this.props;this.state.model.setUniforms(Object.assign({},t,{radius:r,angle:s/180*Math.PI,offset:i,extruded:n,coverage:o,elevationScale:e})).draw()}calculateInstancePositions64xyLow(t){const e=this.use64bitPositions();if(t.constant=!e,!e)return void(t.value=new Float32Array(2));const{data:n,getPosition:o}=this.props,{value:r}=t;let s=0;const{iterable:a,objectInfo:c}=Object(i.createIterable)(n);for(const t of a){c.index++;const e=o(t,c);r[s++]=ct(e[0]),r[s++]=ct(e[1])}}}ht.layerName="ColumnLayer",ht.defaultProps=ft;class pt extends ht{getGeometry(t){return new o.CubeGeometry}draw({uniforms:t}){const{elevationScale:e,extruded:n,offset:i,coverage:o,cellSize:r,angle:s}=this.props;this.state.model.setUniforms(Object.assign({},t,{radius:r/2,angle:s,offset:i,extruded:n,coverage:o,elevationScale:e})).draw()}}pt.layerName="GridCellLayer",pt.defaultProps={cellSize:{type:"number",min:0,value:1e3},offset:{type:"array",min:0,value:[1,1]}};const{Tesselator:gt}=i.experimental,{fp64LowPart:dt}=o.fp64;class vt extends gt{constructor({data:t,getGeometry:e,positionFormat:n,fp64:i}){super({data:t,getGeometry:e,fp64:i,positionFormat:n,attributes:{startPositions:{size:3},endPositions:{size:3},leftDeltas:{size:3},rightDeltas:{size:3},startEndPositions64XyLow:{size:4,fp64Only:!0}}})}get(t,e,n){if(this.attributes[t])return this.attributes[t];switch(t){case"strokeWidths":return this._updateAttribute({target:e,size:1,getValue:(t,e)=>(e.target[0]=n(t,e),e.target)});case"dashArrays":return this._updateAttribute({target:e,size:2,getValue:n});case"colors":return this._updateAttribute({target:e,size:4,getValue:(t,e)=>{const i=n(t,e);if(4===i.length)return i;const o=e.target;return o[0]=i[0],o[1]=i[1],o[2]=i[2],o[3]=255,o}});case"pickingColors":return this._updateAttribute({target:e,size:3,getValue:(t,{index:e,target:i})=>n(e,i)});default:return null}}getGeometrySize(t){return Math.max(0,this.getPathLength(t)-1)}updateGeometryAttributes(t,e){const{attributes:{startPositions:n,endPositions:i,leftDeltas:o,rightDeltas:r,startEndPositions64XyLow:s},fp64:a}=this,c=e.geometrySize+1;if(c<2)return;const l=this.isClosed(t);let u,f=this.getPointOnPath(t,0),h=this.getPointOnPath(t,1),p=l?this.getPointOnPath(t,c-2):f;for(let g=e.vertexStart,d=1;d<c;g++,d++)u=d+1<c?this.getPointOnPath(t,d+1):l?this.getPointOnPath(t,1):h,n[3*g]=f[0],n[3*g+1]=f[1],n[3*g+2]=f[2]||0,i[3*g]=h[0],i[3*g+1]=h[1],i[3*g+2]=h[2]||0,o[3*g]=f[0]-p[0],o[3*g+1]=f[1]-p[1],o[3*g+2]=f[2]-p[2]||0,r[3*g]=u[0]-h[0],r[3*g+1]=u[1]-h[1],r[3*g+2]=u[2]-h[2]||0,a&&(s[4*g]=dt(f[0]),s[4*g+1]=dt(f[1]),s[4*g+2]=dt(h[0]),s[4*g+3]=dt(h[1])),p=f,f=h,h=u}getPathLength(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}getPointOnPath(t,e){if(Number.isFinite(t[0])){const{positionSize:n}=this;return[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return t[e]}isClosed(t){const e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}var yt="#define SHADER_NAME path-layer-vertex-shader-64\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  float width\n) {\n  vec2 deltaA = currPoint.xy - prevPoint.xy;\n  vec2 deltaB = nextPoint.xy - currPoint.xy;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  // when two points are closer than PIXEL_EPSILON in pixels,\n  // assume they are the same point to avoid precision issue\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n\n  // do not bevel if line segment is too short\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n\n  // trim if inside corner extends further than the line segment\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / width / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  // TODO - This has an issue. len is always positive because it is length.\n  // Step returns zero if -lenA<0, so practically this is a comparison of\n  // lenA with zero, with lots of problems because of the -lenA. Can we use EPSILON?\n  bool isStartCap = step(0.0, -lenA) > 0.5;\n  bool isEndCap = step(0.0, -lenB) > 0.5;\n  bool isCap = isStartCap || isEndCap;\n\n  // 0: center, 1: side\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n\n  // start of path: use next - curr\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n\n  // end of path: use curr - prev\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  // Generate variables for dash calculation\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  // vec2 offsetFromStartOfPath = isEnd ? vCornerOffset + deltaA / width : vCornerOffset;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA / width;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return currPoint + vec3(vCornerOffset * width, 0.0);\n}\n\n// calculate line join positions\n// extract params from attributes and uniforms\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    project_pixel_size(widthPixels)\n  );\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = instanceStartPositions;\n  vec2 prevPosition64xyLow = instanceStartEndPositions64xyLow.xy;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    // In auto offset mode, add delta to low part of the positions for better precision\n    prevPosition64xyLow += mix(-instanceLeftDeltas, vec3(0.0), isEnd).xy;\n  } else {\n    prevPosition += mix(-instanceLeftDeltas, vec3(0.0), isEnd);\n  }\n  prevPosition = project_position(prevPosition, prevPosition64xyLow);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  currPosition = project_position(currPosition, currPosition64xyLow);\n\n  vec3 nextPosition = instanceEndPositions;\n  vec2 nextPosition64xyLow = instanceStartEndPositions64xyLow.zw;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\n    // In auto offset mode, add delta to low part of the positions for better precision\n    nextPosition64xyLow += mix(vec3(0.0), instanceRightDeltas, isEnd).xy;\n  } else {\n    nextPosition += mix(vec3(0.0), instanceRightDeltas, isEnd);\n  }\n  nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n  vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\n\n  gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\n}\n",xt="\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec4 instanceStartEndPositions64xyLow;\nattribute vec3 instanceLeftDeltas;\nattribute vec3 instanceRightDeltas;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\n\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0;\n  float width = project_pixel_size(widthPixels);\n\n  vec2 deltaA64[2];\n  vec2 deltaB64[2];\n\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\n\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\n\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\n\n  float lenA = lengthA64.x;\n  float lenB = lengthB64.x;\n\n  vec2 offsetVec;\n  float offsetScale;\n  float offsetDirection;\n\n  // when two points are closer than PIXEL_EPSILON in pixels,\n  // assume they are the same point to avoid precision issue\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // width offset from current position\n  vec2 perp = mix(perpB, perpA, positions.x);\n  float L = mix(lenB, lenA, positions.x);\n\n  // cap super sharp angles\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = mix(\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\n    0.0,\n    positions.z\n  );\n\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  // do not bevel if line segment is too short\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\n  // trim if inside corner extends further than the line segment\n  offsetScale = mix(\n    offsetScale,\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\n    float(cornerPosition < 0.0)\n  );\n\n  vMiterLength = mix(\n    offsetScale * cornerPosition,\n    mix(offsetScale, 0.0, cornerPosition),\n    step(0.0, cornerPosition)\n  ) - sinHalfA * jointType;\n  offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n\n  // special treatment for start cap and end cap\n  // using a small number as the limit for determining if the lenA or lenB is 0\n  float isStartCap = step(lenA, 1.0e-5);\n  float isEndCap = step(lenB, 1.0e-5);\n  float isCap = max(isStartCap, isEndCap);\n\n  // 0: center, 1: side\n  cornerPosition = isCap * (1.0 - positions.z);\n\n  // start of path: use next - curr\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\n  // end of path: use curr - prev\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\n\n  // extend out a triangle to envelope the round cap\n  offsetScale = mix(\n    offsetScale,\n    mix(4.0 * jointType, 1.0, cornerPosition),\n    isCap\n  );\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\n\n  offsetDirection = mix(\n    offsetDirection,\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\n    isCap\n  );\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n\n  // Generate variables for dash calculation\n  vDashArray = instanceDashArrays;\n  vPathLength = L / width;\n  float isEnd = positions.x;\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\n  vec2 dir = mix(dirB, dirA, isEnd);\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n\n  return vec3(vCornerOffset * width, 0.0);\n}\n\nvoid main() {\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  // Calculate current position 64bit\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\n  vec2 projected_curr_position[2];\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\n  float projected_curr_position_z = project_size(currPosition.z);\n\n  // Calculate previous position\n\n  vec3 prevPosition = mix(-instanceLeftDeltas, vec3(0.0), isEnd) + instanceStartPositions;\n\n  // Calculate prev position 64bit\n\n  vec2 projected_prev_position[2];\n  project_position_fp64(prevPosition.xy, instanceStartEndPositions64xyLow.xy, projected_prev_position);\n\n  // Calculate next positions\n  vec3 nextPosition = mix(vec3(0.0), instanceRightDeltas, isEnd) + instanceEndPositions;\n\n  // Calculate next position 64bit\n\n  vec2 projected_next_position[2];\n  project_position_fp64(nextPosition.xy, instanceStartEndPositions64xyLow.zw, projected_next_position);\n\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\n  vec2 vertex_pos_modelspace[4];\n\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\n\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\n}\n",mt="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\n// mod doesn't work correctly for negative numbers\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n\n// if given position is in the gap part of the dashed line\n// dashArray.x: solid stroke length, relative to width\n// dashArray.y: gap length, relative to width\n// alignMode:\n// 0 - no adjustment\n// o----     ----     ----     ---- o----     -o----     ----     o\n// 1 - stretch to fit, draw half dash at each end for nicer joints\n// o--    ----    ----    ----    --o--      --o--     ----     --o\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  // if joint is rounded, test distance from the corner\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    // Enable to debug joints\n    // gl_FragColor = vec4(0., 1., 0., 1.);\n    // return;\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    // Enable to debug joints\n    // gl_FragColor = vec4(0., 0., 1., 1.);\n    // return;\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    // Enable to debug joints\n    // gl_FragColor = vec4(0., 1., 1., 1.);\n    // return;\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const Pt=[0,0,0,255],_t={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},fp64:!1,dashJustified:!1,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:Pt},getWidth:{type:"accessor",value:1},getDashArray:{type:"accessor",value:[0,0]}},bt={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class wt extends i.Layer{getShaders(){return this.use64bitProjection()?{vs:xt,fs:mt,modules:["project64","picking"]}:{vs:yt,fs:mt,modules:["picking"]}}initializeState(){this.getAttributeManager().addInstanced({instanceStartPositions:{size:3,transition:bt,accessor:"getPath",update:this.calculateStartPositions,noAlloc:!0},instanceEndPositions:{size:3,transition:bt,accessor:"getPath",update:this.calculateEndPositions,noAlloc:!0},instanceStartEndPositions64xyLow:{size:4,update:this.calculateInstanceStartEndPositions64xyLow,noAlloc:!0},instanceLeftDeltas:{size:3,update:this.calculateLeftDeltas,noAlloc:!0},instanceRightDeltas:{size:3,update:this.calculateRightDeltas,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:bt,update:this.calculateStrokeWidths,defaultValue:1},instanceDashArrays:{size:2,accessor:"getDashArray",update:this.calculateDashArrays},instanceColors:{size:4,type:r.a.UNSIGNED_BYTE,accessor:"getColor",transition:bt,update:this.calculateColors,defaultValue:Pt},instancePickingColors:{size:3,type:r.a.UNSIGNED_BYTE,update:this.calculatePickingColors}}),this.setState({pathTesselator:new vt({})})}updateState({oldProps:t,props:e,changeFlags:n}){super.updateState({props:e,oldProps:t,changeFlags:n});const i=this.getAttributeManager();if((n.dataChanged||e.fp64!==t.fp64||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath))&&(this.state.pathTesselator.updateGeometry({data:e.data,getGeometry:e.getPath,positionFormat:e.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:this.state.pathTesselator.instanceCount}),i.invalidateAll()),e.fp64!==t.fp64){const{gl:t}=this.context;this.state.model&&this.state.model.delete(),this.setState({model:this._getModel(t)}),i.invalidateAll()}}draw({uniforms:t}){const{viewport:e}=this.context,{rounded:n,miterLimit:i,widthUnits:o,widthScale:r,widthMinPixels:s,widthMaxPixels:a,dashJustified:c}=this.props,l="pixels"===o?e.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},t,{jointType:Number(n),alignMode:Number(c),widthScale:r*l,miterLimit:i,widthMinPixels:s,widthMaxPixels:a})).draw()}_getModel(t){return new o.Model(t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new o.Geometry({drawMode:r.a.TRIANGLES,attributes:{indices:new Uint16Array([0,2,1,1,2,4,1,4,3,3,4,5]),positions:new Float32Array([0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1])}}),isInstanced:!0,shaderCache:this.context.shaderCache}))}calculateStartPositions(t){const{pathTesselator:e}=this.state;t.bufferLayout=e.bufferLayout,t.value=e.get("startPositions")}calculateEndPositions(t){const{pathTesselator:e}=this.state;t.bufferLayout=e.bufferLayout,t.value=e.get("endPositions")}calculateInstanceStartEndPositions64xyLow(t){const e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.pathTesselator.get("startEndPositions64XyLow"):new Float32Array(4)}calculateLeftDeltas(t){const{pathTesselator:e}=this.state;t.value=e.get("leftDeltas")}calculateRightDeltas(t){const{pathTesselator:e}=this.state;t.value=e.get("rightDeltas")}calculateStrokeWidths(t){const{getWidth:e}=this.props,{pathTesselator:n}=this.state;t.bufferLayout=n.bufferLayout,t.value=n.get("strokeWidths",t.value,e)}calculateDashArrays(t){const{getDashArray:e}=this.props,{pathTesselator:n}=this.state;t.value=n.get("dashArrays",t.value,e)}calculateColors(t){const{getColor:e}=this.props,{pathTesselator:n}=this.state;t.bufferLayout=n.bufferLayout,t.value=n.get("colors",t.value,e)}calculatePickingColors(t){const{pathTesselator:e}=this.state;t.value=e.get("pickingColors",t.value,this.encodePickingColor)}clearPickingColor(t){const e=this.decodePickingColor(t),{bufferLayout:n}=this.state.pathTesselator,i=n[e];let o=0;for(let t=0;t<e;t++)o+=n[t];const{instancePickingColors:r}=this.getAttributeManager().attributes,{value:s}=r,a=o+i;s.fill(0,3*o,3*a),r.update({value:s})}}wt.layerName="PathLayer",wt.defaultProps=_t;var Ct=n(10),St=n.n(Ct);function At(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}function Lt(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}function Et(t){const e=t[0],n=t[t.length-1];return e[0]===n[0]&&e[1]===n[1]&&e[2]===n[2]}function Mt(t,e,n,i){for(let o=0;o<e;o++)if(t[n+o]!==t[i-e+o])return!1;return!0}function Tt(t,e,n,i){let o=e;const r=n.length;for(let e=0;e<r;e++)for(let r=0;r<i;r++)t[o++]=n[e][r]||0;if(!Et(n))for(let e=0;e<i;e++)t[o++]=n[0][e]||0;return o}function It(t,e,n,i,o=0,r){const s=(r=r||n.length)-o;if(s<=0)return e;let a=e;for(let e=0;e<s;e++)t[a++]=n[o+e];if(!Mt(n,i,o,r))for(let e=0;e<i;e++)t[a++]=n[o+e];return a}function zt(t){return(Et(t)?0:1)+t.length}function kt(t,e,n=0,i){return n>=(i=i||t.length)?0:(Mt(t,e,n,i)?0:1)+(i-n)/e}function Ft(t,e){if(At(t),t.positions){const{positions:n,holeIndices:i}=t;if(i){let n=0;for(let o=0;o<=i.length;o++)n+=kt(t.positions,e,i[o-1],i[o]);return n}t=n}if(Number.isFinite(t[0]))return kt(t,e);if(!Lt(t)){let e=0;for(const n of t)e+=zt(n);return e}return zt(t)}function Ot(t,e,n){At(t),n=n||Ft(t,e);const i=new Float64Array(n*e),o=[];if(t.positions){const{positions:n,holeIndices:r}=t;if(r){let t=0;for(let s=0;s<=r.length;s++)t=It(i,t,n,e,r[s-1],r[s]),o.push(t);return o.pop(),{positions:i,holeIndices:o}}t=n}if(Number.isFinite(t[0]))return It(i,0,t,e),{positions:i,holeIndices:null};if(!Lt(t)){let n=0;for(const r of t)n=Tt(i,n,r,e),o.push(n);return o.pop(),{positions:i,holeIndices:o}}return Tt(i,0,t,e),{positions:i,holeIndices:null}}const{Tesselator:jt}=i.experimental,{fp64LowPart:Rt}=o.fp64;class Nt extends jt{constructor({data:t,getGeometry:e,fp64:n,positionFormat:i,IndexType:o=Uint32Array}){super({data:t,getGeometry:e,fp64:n,positionFormat:i,attributes:{positions:{size:3},positions64xyLow:{size:2,fp64Only:!0},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:o,size:1}}})}get(t,e,n){if("indices"===t)return this.attributes.indices.subarray(0,this.vertexCount);if(this.attributes[t])return this.attributes[t];switch(t){case"elevations":return this._updateAttribute({target:e,size:1,getValue:(t,e)=>(e.target[0]=n(t,e),e.target)});case"colors":return this._updateAttribute({target:e,size:4,getValue:(t,e)=>{const i=n(t,e);if(4===i.length)return i;const o=e.target;return o[0]=i[0],o[1]=i[1],o[2]=i[2],o[3]=255,o}});case"pickingColors":return this._updateAttribute({target:e,size:3,getValue:(t,{index:e,target:i})=>n(e,i)});default:return null}}getGeometrySize(t){return Ft(t,this.positionSize)}updateGeometryAttributes(t,e){t=Ot(t,this.positionSize,e.geometrySize),this._updateIndices(t,e),this._updatePositions(t,e)}_updateIndices(t,{geometryIndex:e,vertexStart:n,indexStart:i}){const{attributes:o,indexLayout:r,typedArrayManager:s}=this;let a=o.indices,c=a.length,l=i;const u=function(t,e){let n=null;return t.holeIndices&&(n=t.holeIndices.map(t=>t/e)),St()(t.positions,n,e)}(t,this.positionSize);c<l+u.length&&(c=2*(l+u.length),a=s.allocate(a,c,{type:a.constructor,size:1,copy:!0}));for(let t=0;t<u.length;t++)a[l++]=u[t]+n;r[e]=u.length,o.indices=a}_updatePositions(t,{vertexStart:e,geometrySize:n}){const{attributes:{positions:i,positions64xyLow:o,vertexValid:r},fp64:s,positionSize:a}=this;let c=e;const{positions:l,holeIndices:u}=t;for(let t=0;t<n;t++){const e=l[t*a],n=l[t*a+1],u=a>2?l[t*a+2]:0;i[3*c]=e,i[3*c+1]=n,i[3*c+2]=u,s&&(o[2*c]=Rt(e),o[2*c+1]=Rt(n)),r[c]=1,c++}if(u)for(let t=0;t<u.length;t++)r[e+u[t]/a-1]=0;r[e+n-1]=0}}var Dt="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec2 positions64xyLow;\n  vec2 nextPositions64xyLow;\n  float elevations;\n};\n\nvoid calculatePosition(PolygonProps props) {\n  vec3 pos;\n  vec2 pos64xyLow;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64xyLow = mix(props.positions64xyLow, props.nextPositions64xyLow, vertexPositions.x);\n  isValid = vertexValid;\n#else\n  pos = props.positions;\n  pos64xyLow = props.positions64xyLow;\n  isValid = 1.0;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y;\n  }\n  pos.z *= elevationScale;\n\n  vec4 position_commonspace;\n  gl_Position = project_position_to_clipspace(pos, pos64xyLow, vec3(0.), position_commonspace);\n\n  if (extruded) {\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\n    normal = project_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity) / 255.0;\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity) / 255.0;\n  }\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(props.pickingColors);\n}\n",Bt=`#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec2 positions64xyLow;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n${Dt}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64xyLow = positions64xyLow;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n`,Ut=`#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute vec3 nextPositions;\nattribute vec2 nextPositions64xyLow;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n${Dt}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = instancePositions;\n  props.positions64xyLow = instancePositions64xyLow;\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n  props.nextPositions = nextPositions;\n  props.nextPositions64xyLow = nextPositions64xyLow;\n\n  calculatePosition(props);\n}\n`,Wt="#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid < 0.5) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const Gt=[0,0,0,255],Vt=new o.PhongMaterial,Yt={filled:!0,extruded:!1,wireframe:!1,fp64:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:Gt},getLineColor:{type:"accessor",value:Gt},material:Vt},Ht={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class Xt extends i.Layer{getShaders(t){const e=this.use64bitProjection()?"project64":"project32";return{vs:t,fs:Wt,modules:[e,"gouraud-lighting","picking"]}}initializeState(){const{gl:t}=this.context;this.setState({numInstances:0,polygonTesselator:new Nt({IndexType:!t||Object(o.hasFeature)(t,o.FEATURES.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const e=this.getAttributeManager();e.remove(["instancePickingColors"]),e.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:!0},positions:{size:3,transition:Ht,accessor:"getPolygon",update:this.calculatePositions,shaderAttributes:{positions:{offset:0,divisor:0},instancePositions:{offset:0,divisor:1},nextPositions:{offset:12,divisor:1}}},positions64xyLow:{size:2,update:this.calculatePositionsLow,shaderAttributes:{positions64xyLow:{offset:0,divisor:0},instancePositions64xyLow:{offset:0,divisor:1},nextPositions64xyLow:{offset:8,divisor:1}}},vertexValid:{size:1,divisor:1,type:r.a.UNSIGNED_BYTE,update:this.calculateVertexValid,noAlloc:!0},elevations:{size:1,transition:Ht,accessor:"getElevation",update:this.calculateElevations,shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{alias:"colors",size:4,type:r.a.UNSIGNED_BYTE,transition:Ht,accessor:"getFillColor",update:this.calculateFillColors,defaultValue:Gt,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{alias:"colors",size:4,type:r.a.UNSIGNED_BYTE,transition:Ht,accessor:"getLineColor",update:this.calculateLineColors,defaultValue:Gt,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:r.a.UNSIGNED_BYTE,update:this.calculatePickingColors,shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}draw({uniforms:t}){const{extruded:e,filled:n,wireframe:i,elevationScale:o}=this.props,{topModel:s,sideModel:a,polygonTesselator:c}=this.state,l=Object.assign({},t,{extruded:Boolean(e),elevationScale:o});a&&(a.setInstanceCount(c.instanceCount-1),a.setUniforms(l),i&&(a.setDrawMode(r.a.LINE_STRIP),a.setUniforms({isWireframe:!0}).draw()),n&&(a.setDrawMode(r.a.TRIANGLE_FAN),a.setUniforms({isWireframe:!1}).draw())),s&&(s.setVertexCount(c.get("indices").length),s.setUniforms(l).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:n}=t,i=this.getAttributeManager();(e.fp64!==n.fp64||e.filled!==n.filled||e.extruded!==n.extruded)&&(this.state.models&&this.state.models.forEach(t=>t.delete()),this.setState(this._getModels(this.context.gl)),i.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:n}){if(n.dataChanged||t.fp64!==e.fp64||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:e}=this.state;e.updateGeometry({data:t.data,getGeometry:t.getPolygon,positionFormat:t.positionFormat,fp64:this.use64bitPositions()}),this.setState({numInstances:e.instanceCount}),this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:n,extruded:i}=this.props;let s,a;return n&&(s=new o.Model(t,Object.assign({},this.getShaders(Bt),{id:`${e}-top`,drawMode:r.a.TRIANGLES,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0,shaderCache:this.context.shaderCache}))),i&&((a=new o.Model(t,Object.assign({},this.getShaders(Ut),{id:`${e}-side`,geometry:new o.Geometry({drawMode:r.a.LINES,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,1,0,1,0,0,1,0])}}}),instanceCount:0,isInstanced:1,shaderCache:this.context.shaderCache}))).userData.excludeAttributes={indices:!0}),{models:[a,s].filter(Boolean),topModel:s,sideModel:a}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.bufferLayout=e.indexLayout,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.bufferLayout=e.bufferLayout,t.value=e.get("positions")}calculatePositionsLow(t){const e=this.use64bitPositions();t.constant=!e,t.value=e?this.state.polygonTesselator.get("positions64xyLow"):new Float32Array(2)}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}calculateElevations(t){const{polygonTesselator:e}=this.state;t.bufferLayout=e.bufferLayout;const{extruded:n,getElevation:i}=this.props;n?(t.constant=!1,t.value=e.get("elevations",t.value,i)):(t.constant=!0,t.value=new Float32Array(1))}calculateFillColors(t){const{polygonTesselator:e}=this.state;t.bufferLayout=e.bufferLayout,t.value=e.get("colors",t.value,this.props.getFillColor)}calculateLineColors(t){const{polygonTesselator:e}=this.state;t.bufferLayout=e.bufferLayout,t.value=e.get("colors",t.value,this.props.getLineColor)}calculatePickingColors(t){const{polygonTesselator:e}=this.state;t.value=e.get("pickingColors",t.value,this.encodePickingColor)}clearPickingColor(t){const e=this.decodePickingColor(t),{bufferLayout:n}=this.state.polygonTesselator,i=n[e];let o=0;for(let t=0;t<e;t++)o+=n[t];const{pickingColors:r}=this.getAttributeManager().attributes,{value:s}=r,a=o+i;s.fill(0,3*o,3*a),r.update({value:s})}}Xt.layerName="SolidPolygonLayer",Xt.defaultProps=Yt;const Jt=new o.PhongMaterial,Zt={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,lineDashJustified:!1,fp64:!1,getPolygon:{type:"accessor",value:t=>t.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1},getLineDashArray:{type:"accessor",value:[0,0]},getElevation:{type:"accessor",value:1e3},material:Jt};class $t extends i.CompositeLayer{initializeState(){this.state={paths:[]}}updateState({oldProps:t,props:e,changeFlags:n}){(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon))&&(this.state.paths=this._getPaths(e))}getPickingInfo({info:t}){return Object.assign(t,{object:t.object&&t.object.object||t.object})}_getPaths({data:t,getPolygon:e,positionFormat:n}){const o=[],r="XY"===n?2:3,{iterable:s,objectInfo:a}=Object(i.createIterable)(t);for(const t of s){a.index++;const{positions:n,holeIndices:i}=Ot(e(t,a),r);if(i)for(let e=0;e<=i.length;e++){const r=n.subarray(i[e-1]||0,i[e]||n.length);o.push({path:r,object:t})}else o.push({path:n,object:t})}return o}_getAccessor(t){return"function"==typeof t?e=>t(e.object):t}renderLayers(){const{data:t,stroked:e,filled:n,extruded:i,wireframe:o,elevationScale:r,transitions:s}=this.props,{lineWidthUnits:a,lineWidthScale:c,lineWidthMinPixels:l,lineWidthMaxPixels:u,lineJointRounded:f,lineMiterLimit:h,lineDashJustified:p,fp64:g}=this.props,{getFillColor:d,getLineColor:v,getLineWidth:y,getLineDashArray:x,getElevation:m,getPolygon:P,updateTriggers:_,material:b}=this.props,{paths:w}=this.state,C=this.getSubLayerClass("fill",Xt),S=this.getSubLayerClass("stroke",wt),A=this.shouldRenderSubLayer("fill",w)&&new C({extruded:i,elevationScale:r,fp64:g,filled:n,wireframe:o,getElevation:m,getFillColor:d,getLineColor:v,material:b,transitions:s},this.getSubLayerProps({id:"fill",updateTriggers:{getPolygon:_.getPolygon,getElevation:_.getElevation,getFillColor:_.getFillColor,getLineColor:_.getLineColor}}),{data:t,getPolygon:P});return[!i&&A,!i&&e&&this.shouldRenderSubLayer("stroke",w)&&new S({fp64:g,widthUnits:a,widthScale:c,widthMinPixels:l,widthMaxPixels:u,rounded:f,miterLimit:h,dashJustified:p,transitions:s&&{getWidth:s.getLineWidth,getColor:s.getLineColor,getPath:s.getPolygon},getColor:this._getAccessor(v),getWidth:this._getAccessor(y),getDashArray:this._getAccessor(x)},this.getSubLayerProps({id:"stroke",updateTriggers:{getWidth:_.getLineWidth,getColor:_.getLineColor,getDashArray:_.getLineDashArray}}),{data:w,getPath:t=>t.path}),i&&A]}}function qt(t,e){if(!t)throw new Error(`deck.gl: ${e}`)}function Qt(t,e,n){const{type:i,coordinates:o}=t,{pointFeatures:r,lineFeatures:s,polygonFeatures:a,polygonOutlineFeatures:c}=e;switch(function(t,e){let n=te[t];qt(n,`Unknown GeoJSON type ${t}`);for(;e&&--n>0;)e=e[0];qt(e&&Number.isFinite(e[0]),`${t} coordinates are malformed`)}(i,o),i){case"Point":r.push({geometry:t,sourceFeature:n});break;case"MultiPoint":o.forEach(t=>{r.push({geometry:{type:"Point",coordinates:t},sourceFeature:n})});break;case"LineString":s.push({geometry:t,sourceFeature:n});break;case"MultiLineString":o.forEach(t=>{s.push({geometry:{type:"LineString",coordinates:t},sourceFeature:n})});break;case"Polygon":a.push({geometry:t,sourceFeature:n}),o.forEach(t=>{c.push({geometry:{type:"LineString",coordinates:t},sourceFeature:n})});break;case"MultiPolygon":o.forEach(t=>{a.push({geometry:{type:"Polygon",coordinates:t},sourceFeature:n}),t.forEach(t=>{c.push({geometry:{type:"LineString",coordinates:t},sourceFeature:n})})})}}function Kt(t){return t.sourceFeature.feature}$t.layerName="PolygonLayer",$t.defaultProps=Zt;const te={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};const ee=new o.PhongMaterial,ne={stroked:!0,filled:!0,extruded:!1,wireframe:!1,lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,elevationScale:1,pointRadiusScale:1,pointRadiusMinPixels:0,pointRadiusMaxPixels:Number.MAX_SAFE_INTEGER,lineDashJustified:!1,fp64:!1,getLineColor:{type:"accessor",value:[0,0,0,255]},getFillColor:{type:"accessor",value:[0,0,0,255]},getRadius:{type:"accessor",value:1},getLineWidth:{type:"accessor",value:1},getLineDashArray:{type:"accessor",value:[0,0]},getElevation:{type:"accessor",value:1e3},material:ee};function ie(t){return t.geometry.coordinates}function oe(t){return"function"!=typeof t?t:e=>t(Kt(e))}class re extends i.CompositeLayer{initializeState(){this.state={features:{}}}updateState({oldProps:t,props:e,changeFlags:n}){if(n.dataChanged){const{data:t}=e,n=function(t){if(Array.isArray(t))return t;switch(qt(t.type,"GeoJSON does not have type"),t.type){case"Feature":return[t];case"FeatureCollection":return qt(Array.isArray(t.features),"GeoJSON does not have features array"),t.features;default:return[{geometry:t}]}}(t);this.state.features=function(t){const e={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]};for(let n=0;n<t.length;n++){const i=t[n];qt(i&&i.geometry,"GeoJSON does not have geometry");const{geometry:o}=i,r={feature:i,index:n};if("GeometryCollection"===o.type){qt(Array.isArray(o.geometries),"GeoJSON does not have geometries array");const{geometries:t}=o;for(let n=0;n<t.length;n++)Qt(t[n],e,r)}else Qt(o,e,r)}return e}(n)}}getPickingInfo({info:t,sourceLayer:e}){return Object.assign(t,{object:t.object?Kt(t.object):t.object,index:t.object?(n=t.object,n.sourceFeature.index):t.index});var n}renderLayers(){const{features:t}=this.state,{pointFeatures:e,lineFeatures:n,polygonFeatures:i,polygonOutlineFeatures:o}=t,{stroked:r,filled:s,extruded:a,wireframe:c,material:l,transitions:u}=this.props,{lineWidthUnits:f,lineWidthScale:h,lineWidthMinPixels:p,lineWidthMaxPixels:g,lineJointRounded:d,lineMiterLimit:v,pointRadiusScale:y,pointRadiusMinPixels:x,pointRadiusMaxPixels:m,elevationScale:P,lineDashJustified:_,fp64:b}=this.props,{getLineColor:w,getFillColor:C,getRadius:S,getLineWidth:A,getLineDashArray:L,getElevation:E,updateTriggers:M}=this.props,T=this.getSubLayerClass("polygons-fill",Xt),I=this.getSubLayerClass("polygons-stroke",wt),z=this.getSubLayerClass("line-strings",wt),k=this.getSubLayerClass("points",rt),F=this.shouldRenderSubLayer("polygons-fill",i)&&new T({fp64:b,extruded:a,elevationScale:P,filled:s,wireframe:c,material:l,getElevation:oe(E),getFillColor:oe(C),getLineColor:oe(w),transitions:u&&{getPolygon:u.geometry,getElevation:u.getElevation,getFillColor:u.getFillColor,getLineColor:u.getLineColor}},this.getSubLayerProps({id:"polygons-fill",updateTriggers:{getElevation:M.getElevation,getFillColor:M.getFillColor,getLineColor:M.getLineColor}}),{data:i,getPolygon:ie});return[!a&&F,!a&&r&&this.shouldRenderSubLayer("polygons-stroke",o)&&new I({fp64:b,widthUnits:f,widthScale:h,widthMinPixels:p,widthMaxPixels:g,rounded:d,miterLimit:v,dashJustified:_,getColor:oe(w),getWidth:oe(A),getDashArray:oe(L),transitions:u&&{getPath:u.geometry,getColor:u.getLineColor,getWidth:u.getLineWidth}},this.getSubLayerProps({id:"polygons-stroke",updateTriggers:{getColor:M.getLineColor,getWidth:M.getLineWidth,getDashArray:M.getLineDashArray}}),{data:o,getPath:ie}),this.shouldRenderSubLayer("linestrings",n)&&new z({fp64:b,widthUnits:f,widthScale:h,widthMinPixels:p,widthMaxPixels:g,rounded:d,miterLimit:v,dashJustified:_,getColor:oe(w),getWidth:oe(A),getDashArray:oe(L),transitions:u&&{getPath:u.geometry,getColor:u.getLineColor,getWidth:u.getLineWidth}},this.getSubLayerProps({id:"line-strings",updateTriggers:{getColor:M.getLineColor,getWidth:M.getLineWidth,getDashArray:M.getLineDashArray}}),{data:n,getPath:ie}),this.shouldRenderSubLayer("points",e)&&new k({fp64:b,stroked:r,filled:s,radiusScale:y,radiusMinPixels:x,radiusMaxPixels:m,lineWidthUnits:f,lineWidthScale:h,lineWidthMinPixels:p,lineWidthMaxPixels:g,getFillColor:oe(C),getLineColor:oe(w),getRadius:oe(S),getLineWidth:oe(A),transitions:u&&{getPosition:u.geometry,getFillColor:u.getFillColor,getLineColor:u.getLineColor,getRadius:u.getRadius,getLineWidth:u.getLineWidth}},this.getSubLayerProps({id:"points",updateTriggers:{getFillColor:M.getFillColor,getLineColor:M.getLineColor,getRadius:M.getRadius,getLineWidth:M.getLineWidth}}),{data:e,getPosition:ie}),a&&F]}}re.layerName="GeoJsonLayer",re.defaultProps=ne;var se='#define SHADER_NAME multi-icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xyLow;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\n\n// the following three attributes are for the multi-icon layer\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec2 iconsTextureDim;\nuniform float gamma;\nuniform float opacity;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  vec2 iconSize = instanceIconFrames.zw;\n \n  // project meters to pixels and clamp to limits \n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n\n  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  \n  if (billboard)  {\n    pixelOffset.y *= -1.0;\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.0)); \n    gl_Position.xy += project_pixel_size_to_clipspace(pixelOffset);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset_common); \n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vTextureCoords.y = 1.0 - vTextureCoords.y;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\n  picking_setPickingColor(instancePickingColors);\n\n  vGamma = gamma / (sizeScale * iconSize.y);\n}\n',ae="#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform sampler2D iconsTexture;\nuniform float buffer;\nuniform bool sdf;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\n\nconst float MIN_ALPHA = 0.05;\n\nvoid main(void) {\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  \n  float alpha = texColor.a;\n  // if enable sdf (signed distance fields)\n  if (sdf) {\n    float distance = texture2D(iconsTexture, vTextureCoords).a;\n    alpha = smoothstep(buffer - vGamma, buffer + vGamma, distance);\n  }\n\n  // Take the global opacity and the alpha from vColor into account for the alpha component\n  float a = alpha * vColor.a;\n\n  if (a < MIN_ALPHA) {\n    discard;\n  }\n\n  gl_FragColor = vec4(vColor.rgb, a);\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n";const ce=.2,le=.75;class ue extends B{getShaders(){return Object.assign({},super.getShaders(),{vs:se,fs:ae})}initializeState(){super.initializeState(),this.getAttributeManager().addInstanced({instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(t){super.updateState(t);const{changeFlags:e}=t;e.updateTriggersChanged&&(e.updateTriggersChanged.getAnchorX||e.updateTriggersChanged.getAnchorY)&&this.getAttributeManager().invalidate("instanceOffsets")}draw({uniforms:t}){const{sdf:e}=this.props;super.draw({uniforms:Object.assign({},t,{buffer:le,gamma:ce,sdf:Boolean(e)})})}calculateInstanceOffsets(t){const{data:e,iconMapping:n,getIcon:i,getAnchorX:o,getAnchorY:r,getLengthOfQueue:s,getShiftInQueue:a}=this.props,{value:c}=t;let l=0;for(const t of e){const e=n[i(t)]||{},u=s(t),f=a(t);c[l++]=(o(t)-1)*u/2+e.width/2+f||0,c[l++]=e.height/2*r(t)||0}}calculateInstancePickingColors(t){const{data:e,getPickingIndex:n}=this.props,{value:i}=t;let o=0;const r=[];for(const t of e){const e=n(t);this.encodePickingColor(e,r),i[o++]=r[0],i[o++]=r[1],i[o++]=r[2]}}}ue.layerName="MultiIconLayer",ue.defaultProps={getShiftInQueue:{type:"accessor",value:t=>t.shift||0},getLengthOfQueue:{type:"accessor",value:t=>t.len||1},getAnchorX:{type:"accessor",value:t=>t.anchorX||0},getAnchorY:{type:"accessor",value:t=>t.anchorY||0},getPixelOffset:{type:"accessor",value:[0,0]},getPickingIndex:{type:"accessor",value:t=>t.objectIndex}};var fe=n(11),he=n.n(fe);const pe=function(){const t=[];for(let e=32;e<128;e++)t.push(String.fromCharCode(e));return t}(),ge="Monaco, monospace",de="normal",ve=64,ye=2,xe=.25,me=3,Pe=10242,_e=10243,be=33071,we=1024,Ce=.9,Se=1.2,Ae=new class{constructor(t=5){this.limit=t,this.clear()}clear(){this._cache={},this._order=[]}get(t){const e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(this._deleteCache(t),this._deleteOrder(t))}_deleteCache(t){delete this._cache[t]}_deleteOrder(t){const e=this._order.findIndex(e=>e===t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}}(3),Le=["fontFamily","fontWeight","characterSet","fontSize","sdf","buffer","cutoff","radius"];function Ee(t,e){for(let n=0;n<t.length;n++)e.data[4*n+3]=t[n]}function Me(t,e,n,i){t.font=`${i} ${n}px ${e}`,t.fillStyle="#000",t.textBaseline="baseline",t.textAlign="left"}class Te{constructor(t){this.gl=t,this.props={fontFamily:ge,fontWeight:de,characterSet:pe,fontSize:ve,buffer:ye,sdf:!1,cutoff:xe,radius:me},this._key=null,this._texture=new o.Texture2D(this.gl)}get texture(){return this._texture}get mapping(){const t=Ae.get(this._key);return t&&t.mapping}get scale(){return Se}setProps(t={}){Le.forEach(e=>{e in t&&(this.props[e]=t[e])});const e=this._key;this._key=this._getKey();const n=function(t,e){const n=Ae.get(t);if(!n)return e;const i=[],o=n.mapping;let r=Object.keys(o);r=new Set(r);let s=e;return s instanceof Array&&(s=new Set(s)),s.forEach(t=>{r.has(t)||i.push(t)}),i}(this._key,this.props.characterSet),i=Ae.get(this._key);if(i&&0===n.length)return void(this._key!==e&&this._updateTexture(i));const o=this._generateFontAtlas(this._key,n,i);this._updateTexture(o),Ae.set(this._key,o)}_updateTexture({data:t,width:e,height:n}){this._texture.width===e&&this._texture.height===n||this._texture.resize({width:e,height:n}),this._texture.setImageData({data:t,width:e,height:n,parameters:{[Pe]:be,[_e]:be,[r.a.UNPACK_FLIP_Y_WEBGL]:!0}}),this._texture.generateMipmap()}_generateFontAtlas(t,e,n){const{fontFamily:i,fontWeight:o,fontSize:r,buffer:s,sdf:a,radius:c,cutoff:l}=this.props;let u=n&&n.data;u||((u=document.createElement("canvas")).width=we);const f=u.getContext("2d");Me(f,i,r,o);const{mapping:h,canvasHeight:p,xOffset:g,yOffset:d}=function({characterSet:t,getFontWidth:e,fontHeight:n,buffer:i,maxCanvasWidth:o,mapping:r={},xOffset:s=0,yOffset:a=0}){let c=0,l=s;Array.from(t).forEach((t,s)=>{if(!r[t]){const u=e(t,s);l+u+2*i>o&&(l=0,c++),r[t]={x:l+i,y:a+c*(n+2*i)+i,width:u,height:n,mask:!0},l+=u+2*i}});const u=n+2*i;return{mapping:r,xOffset:l,yOffset:a+c*u,canvasHeight:(f=a+(c+1)*u,Math.pow(2,Math.ceil(Math.log2(f))))};var f}(Object.assign({getFontWidth:t=>f.measureText(t).width,fontHeight:r*Se,buffer:s,characterSet:e,maxCanvasWidth:we},n&&{mapping:n.mapping,xOffset:n.xOffset,yOffset:n.yOffset}));if(u.height!==p){const t=f.getImageData(0,0,u.width,u.height);u.height=p,f.putImageData(t,0,0)}if(Me(f,i,r,o),a){const t=new he.a(r,s,c,l,i,o),n=f.getImageData(0,0,t.size,t.size);for(const i of e)Ee(t.draw(i),n),f.putImageData(n,h[i].x-s,h[i].y-s)}else for(const t of e)f.fillText(t,h[t].x,h[t].y+r*Ce);return{xOffset:g,yOffset:d,mapping:h,data:u,width:u.width,height:u.height}}_getKey(){const{gl:t,fontFamily:e,fontWeight:n,fontSize:i,buffer:o,sdf:r,radius:s,cutoff:a}=this.props;return r?`${t} ${e} ${n} ${i} ${o} ${s} ${a}`:`${t} ${e} ${n} ${i} ${o}`}}const Ie={fontSize:ve,buffer:ye,sdf:!1,radius:me,cutoff:xe},ze={start:1,middle:0,end:-1},ke={top:1,center:0,bottom:-1},Fe=32,Oe=["fontSize","buffer","sdf","radius","cutoff"],je={fp64:!1,billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,characterSet:pe,fontFamily:ge,fontWeight:de,fontSettings:{},getText:{type:"accessor",value:t=>t.text},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:[0,0,0,255]},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]}};class Re extends i.CompositeLayer{initializeState(){this.state={fontAtlasManager:new Te(this.context.gl)}}updateState({props:t,oldProps:e,changeFlags:n}){const i=this.fontChanged(e,t);i&&this.updateFontAtlas({oldProps:e,props:t}),(n.dataChanged||i||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this.transformStringToLetters()}updateFontAtlas({oldProps:t,props:e}){const{characterSet:n,fontSettings:i,fontFamily:o,fontWeight:r}=e,s=this.state.fontAtlasManager;s.setProps(Object.assign({},Ie,i,{characterSet:n,fontFamily:o,fontWeight:r}));const{scale:a,texture:c,mapping:l}=s;this.setState({scale:a,iconAtlas:c,iconMapping:l}),this.setNeedsRedraw(!0)}fontChanged(t,e){if(t.fontFamily!==e.fontFamily||t.characterSet!==e.characterSet||t.fontWeight!==e.fontWeight)return!0;if(t.fontSettings===e.fontSettings)return!1;const n=t.fontSettings||{},i=e.fontSettings||{};return Oe.some(t=>n[t]!==i[t])}getPickingInfo({info:t}){return Object.assign(t,{object:t.index>=0?this.props.data[t.index]:null})}transformStringToLetters(){const{data:t,getText:e}=this.props,{iconMapping:n}=this.state,o=[],{iterable:r,objectInfo:s}=Object(i.createIterable)(t);for(const t of r){s.index++;const r=e(t,s);if(r){const e=Array.from(r),a=[0];let c=0;e.forEach((e,l)=>{const u={text:e,index:l,offsets:a,len:r.length,object:t,objectIndex:s.index},f=n[e];f?c+=f.width:(i.log.warn(`Missing character: ${e}`)(),c+=Fe),a.push(c),o.push(u)})}}this.setState({data:o})}getLetterOffset(t){return t.offsets[t.index]}getTextLength(t){return t.offsets[t.offsets.length-1]}_getAccessor(t){return"function"==typeof t?e=>t(e.object):t}getAnchorXFromTextAnchor(t){return e=>{const n="function"==typeof t?t(e.object):t;if(!ze.hasOwnProperty(n))throw new Error(`Invalid text anchor parameter: ${n}`);return ze[n]}}getAnchorYFromAlignmentBaseline(t){return e=>{const n="function"==typeof t?t(e.object):t;if(!ke.hasOwnProperty(n))throw new Error(`Invalid alignment baseline parameter: ${n}`);return ke[n]}}renderLayers(){const{data:t,scale:e,iconAtlas:n,iconMapping:i}=this.state,{getPosition:o,getColor:r,getSize:s,getAngle:a,getTextAnchor:c,getAlignmentBaseline:l,getPixelOffset:u,fp64:f,billboard:h,sdf:p,sizeScale:g,sizeUnits:d,sizeMinPixels:v,sizeMaxPixels:y,transitions:x,updateTriggers:m}=this.props;return new(this.getSubLayerClass("characters",ue))({sdf:p,iconAtlas:n,iconMapping:i,getPosition:t=>o(t.object),getColor:this._getAccessor(r),getSize:this._getAccessor(s),getAngle:this._getAccessor(a),getAnchorX:this.getAnchorXFromTextAnchor(c),getAnchorY:this.getAnchorYFromAlignmentBaseline(l),getPixelOffset:this._getAccessor(u),fp64:f,billboard:h,sizeScale:g*e,sizeUnits:d,sizeMinPixels:v*e,sizeMaxPixels:y*e,transitions:x&&{getPosition:x.getPosition,getAngle:x.getAngle,getColor:x.getColor,getSize:x.getSize,getPixelOffset:m.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{getPosition:m.getPosition,getAngle:m.getAngle,getColor:m.getColor,getSize:m.getSize,getPixelOffset:m.getPixelOffset,getAnchorX:m.getTextAnchor,getAnchorY:m.getAlignmentBaseline}}),{data:t,getIcon:t=>t.text,getShiftInQueue:t=>this.getLetterOffset(t),getLengthOfQueue:t=>this.getTextLength(t)})}}Re.layerName="TextLayer",Re.defaultProps=je,n.d(e,"ArcLayer",function(){return h}),n.d(e,"BitmapLayer",function(){return A}),n.d(e,"IconLayer",function(){return B}),n.d(e,"LineLayer",function(){return Y}),n.d(e,"PointCloudLayer",function(){return K}),n.d(e,"ScatterplotLayer",function(){return rt}),n.d(e,"ColumnLayer",function(){return ht}),n.d(e,"GridCellLayer",function(){return pt}),n.d(e,"PathLayer",function(){return wt}),n.d(e,"PolygonLayer",function(){return $t}),n.d(e,"GeoJsonLayer",function(){return re}),n.d(e,"TextLayer",function(){return Re}),n.d(e,"SolidPolygonLayer",function(){return Xt}),n.d(e,"_MultiIconLayer",function(){return ue})}])});