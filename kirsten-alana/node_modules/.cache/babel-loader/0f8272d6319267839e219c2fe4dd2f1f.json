{"ast":null,"code":"export function flatten(array) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$filter = _ref.filter,\n      filter = _ref$filter === void 0 ? function () {\n    return true;\n  } : _ref$filter,\n      _ref$map = _ref.map,\n      map = _ref$map === void 0 ? function (x) {\n    return x;\n  } : _ref$map,\n      _ref$result = _ref.result,\n      result = _ref$result === void 0 ? [] : _ref$result;\n\n  if (!Array.isArray(array)) {\n    return filter(array) ? [map(array)] : [];\n  }\n\n  return flattenArray(array, filter, map, result);\n}\n\nfunction flattenArray(array, filter, map, result) {\n  var index = -1;\n\n  while (++index < array.length) {\n    var value = array[index];\n\n    if (Array.isArray(value)) {\n      flattenArray(value, filter, map, result);\n    } else if (filter(value)) {\n      result.push(map(value));\n    }\n  }\n\n  return result;\n}\n\nexport function countVertices(nestedArray) {\n  var count = 0;\n  var index = -1;\n\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      count += countVertices(value);\n    } else {\n      count++;\n    }\n  }\n\n  return count;\n}\nexport function flattenVertices(nestedArray) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$result = _ref2.result,\n      result = _ref2$result === void 0 ? [] : _ref2$result,\n      _ref2$dimensions = _ref2.dimensions,\n      dimensions = _ref2$dimensions === void 0 ? 3 : _ref2$dimensions;\n\n  var index = -1;\n  var vertexLength = 0;\n\n  while (++index < nestedArray.length) {\n    var value = nestedArray[index];\n\n    if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      flattenVertices(value, {\n        result: result,\n        dimensions: dimensions\n      });\n    } else {\n      if (vertexLength < dimensions) {\n        result.push(value);\n        vertexLength++;\n      }\n    }\n  }\n\n  if (vertexLength > 0 && vertexLength < dimensions) {\n    result.push(0);\n  }\n\n  return result;\n}\nexport function fillArray(_ref3) {\n  var target = _ref3.target,\n      source = _ref3.source,\n      _ref3$start = _ref3.start,\n      start = _ref3$start === void 0 ? 0 : _ref3$start,\n      _ref3$count = _ref3.count,\n      count = _ref3$count === void 0 ? 1 : _ref3$count;\n  var length = source.length;\n  var total = count * length;\n  var copied = 0;\n\n  for (var i = start; copied < length; copied++) {\n    target[i++] = source[copied];\n  }\n\n  while (copied < total) {\n    if (copied < total - copied) {\n      target.copyWithin(start + copied, start, start + copied);\n      copied *= 2;\n    } else {\n      target.copyWithin(start + copied, start, start + total - copied);\n      copied = total;\n    }\n  }\n\n  return target;\n}","map":null,"metadata":{},"sourceType":"module"}