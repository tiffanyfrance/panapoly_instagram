{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { isWebGL, Query, Program, VertexArray, clear as _clear } from '@luma.gl/webgl';\nimport { MODULAR_SHADERS, assembleShaders } from '@luma.gl/shadertools';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { addModel, removeModel, logModel, getOverrides } from '../debug/seer-integration';\nimport { log, isObjectEmpty, uid, assert } from '../utils';\nvar LOG_DRAW_PRIORITY = 2;\nvar LOG_DRAW_TIMEOUT = 10000;\nvar DEPRECATED_PICKING_UNIFORMS = ['renderPickingBuffer', 'pickingEnabled'];\n\nvar BaseModel = function () {\n  function BaseModel(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, BaseModel);\n\n    assert(isWebGL(gl));\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('base-model') : _props$id;\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.initialize(props);\n\n    this._setBaseModelProps(props);\n  }\n\n  _createClass(BaseModel, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.props = {};\n      this.program = this._createProgram(props);\n      this.vertexArray = new VertexArray(this.gl, {\n        program: this.program\n      });\n      this.userData = {};\n      this.needsRedraw = true;\n      this._attributes = {};\n      this.attributes = {};\n      this.animatedUniforms = {};\n      this.animated = false;\n      this.animationLoop = null;\n      this.timerQueryEnabled = false;\n      this.timeElapsedQuery = undefined;\n      this.lastQueryReturned = true;\n      this.stats = {\n        accumulatedFrameTime: 0,\n        averageFrameTime: 0,\n        profileFrameCount: 0\n      };\n      this.pickable = true;\n\n      this._setBaseModelProps(props);\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms(), this.getModuleUniforms(props.moduleSettings)));\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._setBaseModelProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key][\"delete\"]();\n        }\n      }\n\n      this.program[\"delete\"]();\n      this.vertexArray[\"delete\"]();\n      removeModel(this.id);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this[\"delete\"]();\n    }\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return this.animated;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.program.getUniforms();\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var _this = this;\n\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      uniforms = Object.assign({}, uniforms);\n      getOverrides(this.id, uniforms);\n      uniforms = this._extractAnimatedUniforms(uniforms);\n      this.program.setUniforms(uniforms, function () {\n        _this._checkForDeprecatedUniforms(uniforms);\n      });\n      return this;\n    }\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts || {});\n      return this.setUniforms(uniforms);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(opts) {\n      _clear(this.program.gl, opts);\n\n      return this;\n    }\n  }, {\n    key: \"drawGeometry\",\n    value: function drawGeometry() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$moduleSettings = opts.moduleSettings,\n          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,\n          framebuffer = opts.framebuffer,\n          _opts$uniforms = opts.uniforms,\n          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,\n          _opts$attributes = opts.attributes,\n          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,\n          _opts$transformFeedba = opts.transformFeedback,\n          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,\n          _opts$parameters = opts.parameters,\n          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,\n          _opts$vertexArray = opts.vertexArray,\n          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray,\n          animationProps = opts.animationProps;\n      addModel(this);\n      this.setAttributes(attributes);\n      this.updateModuleSettings(moduleSettings);\n      this.setUniforms(uniforms);\n\n      this._refreshAnimationProps(animationProps);\n\n      var logPriority = this._logDrawCallStart(2);\n\n      var drawParams = this.vertexArray.getDrawParams(this.props);\n\n      if (drawParams.isInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model', this.id)();\n      }\n\n      var isIndexed = drawParams.isIndexed,\n          indexType = drawParams.indexType,\n          indexOffset = drawParams.indexOffset;\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n\n      var noop = function noop() {};\n\n      var _this$props = this.props,\n          _this$props$onBeforeR = _this$props.onBeforeRender,\n          onBeforeRender = _this$props$onBeforeR === void 0 ? noop : _this$props$onBeforeR,\n          _this$props$onAfterRe = _this$props.onAfterRender,\n          onAfterRender = _this$props$onAfterRe === void 0 ? noop : _this$props$onAfterRe;\n      onBeforeRender();\n\n      this._timerQueryStart();\n\n      var didDraw = this.program.draw(Object.assign({}, opts, {\n        logPriority: logPriority,\n        uniforms: null,\n        framebuffer: framebuffer,\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      }));\n\n      this._timerQueryEnd();\n\n      onAfterRender();\n\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n      return didDraw;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$discard = opts.discard,\n          discard = _opts$discard === void 0 ? true : _opts$discard,\n          feedbackBuffers = opts.feedbackBuffers,\n          _opts$unbindModels = opts.unbindModels,\n          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;\n      var parameters = opts.parameters;\n\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n\n      try {\n        this.draw(Object.assign({}, opts, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_setBaseModelProps\",\n    value: function _setBaseModelProps(props) {\n      Object.assign(this.props, props);\n\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n\n      if ('pickable' in props) {\n        this.pickable = props.pickable;\n      }\n\n      if ('timerQueryEnabled' in props) {\n        this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n\n        if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n          log.warn('GPU timer not supported')();\n        }\n      }\n\n      if ('_animationProps' in props) {\n        this._setAnimationProps(props._animationProps);\n      }\n\n      if ('_animationLoop' in props) {\n        this.animationLoop = props._animationLoop;\n      }\n    }\n  }, {\n    key: \"_createProgram\",\n    value: function _createProgram(_ref) {\n      var _ref$vs = _ref.vs,\n          vs = _ref$vs === void 0 ? null : _ref$vs,\n          _ref$fs = _ref.fs,\n          fs = _ref$fs === void 0 ? null : _ref$fs,\n          _ref$modules = _ref.modules,\n          modules = _ref$modules === void 0 ? null : _ref$modules,\n          _ref$defines = _ref.defines,\n          defines = _ref$defines === void 0 ? {} : _ref$defines,\n          _ref$inject = _ref.inject,\n          inject = _ref$inject === void 0 ? {} : _ref$inject,\n          _ref$shaderCache = _ref.shaderCache,\n          shaderCache = _ref$shaderCache === void 0 ? null : _ref$shaderCache,\n          _ref$varyings = _ref.varyings,\n          varyings = _ref$varyings === void 0 ? null : _ref$varyings,\n          _ref$bufferMode = _ref.bufferMode,\n          bufferMode = _ref$bufferMode === void 0 ? 35981 : _ref$bufferMode,\n          _ref$program = _ref.program,\n          program = _ref$program === void 0 ? null : _ref$program;\n\n      this.getModuleUniforms = function (x) {};\n\n      var id = this.id;\n\n      if (!program) {\n        vs = vs || MODULAR_SHADERS.vs;\n        fs = fs || MODULAR_SHADERS.fs;\n        var assembleResult = assembleShaders(this.gl, {\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          log: log\n        });\n        vs = assembleResult.vs;\n        fs = assembleResult.fs;\n\n        if (shaderCache) {\n          program = shaderCache.getProgram(this.gl, {\n            id: id,\n            vs: vs,\n            fs: fs\n          });\n        } else {\n          program = new Program(this.gl, {\n            id: id,\n            vs: vs,\n            fs: fs,\n            varyings: varyings,\n            bufferMode: bufferMode\n          });\n        }\n\n        this.getModuleUniforms = assembleResult.getUniforms || function (x) {};\n      }\n\n      assert(program instanceof Program, 'Model needs a program');\n      return program;\n    }\n  }, {\n    key: \"_checkForDeprecatedUniforms\",\n    value: function _checkForDeprecatedUniforms(uniforms) {\n      DEPRECATED_PICKING_UNIFORMS.forEach(function (uniform) {\n        if (uniform in uniforms) {\n          log.deprecated(uniform, 'use picking shader module and Model class updateModuleSettings()')();\n        }\n      });\n    }\n  }, {\n    key: \"_refreshAnimationProps\",\n    value: function _refreshAnimationProps(animationProps) {\n      animationProps = animationProps || this.animationLoop && this.animationLoop.animationProps;\n\n      if (animationProps) {\n        this._setAnimationProps(animationProps);\n      }\n    }\n  }, {\n    key: \"_evaluateAnimateUniforms\",\n    value: function _evaluateAnimateUniforms(animationProps) {\n      if (!this.animated) {\n        return {};\n      }\n\n      var animatedUniforms = {};\n\n      for (var uniformName in this.animatedUniforms) {\n        var valueFunction = this.animatedUniforms[uniformName];\n        animatedUniforms[uniformName] = valueFunction(animationProps);\n      }\n\n      return animatedUniforms;\n    }\n  }, {\n    key: \"_extractAnimatedUniforms\",\n    value: function _extractAnimatedUniforms(uniforms) {\n      var foundAnimated = false;\n\n      for (var uniformName in uniforms) {\n        var newValue = uniforms[uniformName];\n\n        if (typeof newValue === 'function') {\n          this.animatedUniforms[uniformName] = newValue;\n          foundAnimated = true;\n        } else {\n          delete this.animatedUniforms[uniformName];\n        }\n      }\n\n      this.animated = !isObjectEmpty(this.animatedUniforms);\n\n      if (!foundAnimated) {\n        return uniforms;\n      }\n\n      var staticUniforms = {};\n\n      for (var _uniformName in uniforms) {\n        if (!this.animatedUniforms[_uniformName]) {\n          staticUniforms[_uniformName] = uniforms[_uniformName];\n        }\n      }\n\n      return staticUniforms;\n    }\n  }, {\n    key: \"_timerQueryStart\",\n    value: function _timerQueryStart() {\n      if (this.timerQueryEnabled === true) {\n        if (!this.timeElapsedQuery) {\n          this.timeElapsedQuery = new Query(this.gl);\n        }\n\n        if (this.lastQueryReturned) {\n          this.lastQueryReturned = false;\n          this.timeElapsedQuery.beginTimeElapsedQuery();\n        }\n      }\n    }\n  }, {\n    key: \"_timerQueryEnd\",\n    value: function _timerQueryEnd() {\n      if (this.timerQueryEnabled === true) {\n        this.timeElapsedQuery.end();\n\n        if (this.timeElapsedQuery.isResultAvailable()) {\n          this.lastQueryReturned = true;\n          var elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n          this.stats.lastFrameTime = elapsedTime;\n          this.stats.accumulatedFrameTime += elapsedTime;\n          this.stats.profileFrameCount++;\n          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n          log.log(LOG_DRAW_PRIORITY, \"GPU time \".concat(this.program.id, \": \").concat(this.stats.lastFrameTime, \"ms average \").concat(this.stats.averageFrameTime, \"ms accumulated: \").concat(this.stats.accumulatedFrameTime, \"ms count: \").concat(this.stats.profileFrameCount))();\n        }\n      }\n    }\n  }, {\n    key: \"_logDrawCallStart\",\n    value: function _logDrawCallStart(priority) {\n      var logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n      if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n        return undefined;\n      }\n\n      this.lastLogTime = Date.now();\n      log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n        collapsed: log.priority <= 2\n      })();\n      return priority;\n    }\n  }, {\n    key: \"_logDrawCallEnd\",\n    value: function _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n      if (priority === undefined) {\n        return;\n      }\n\n      var attributeTable = getDebugTableForVertexArray({\n        vertexArray: vertexArray,\n        header: \"\".concat(this.id, \" attributes\"),\n        attributes: this._attributes\n      });\n\n      var _getDebugTableForUnif = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms)\n      }),\n          uniformTable = _getDebugTableForUnif.table,\n          unusedTable = _getDebugTableForUnif.unusedTable,\n          unusedCount = _getDebugTableForUnif.unusedCount;\n\n      var _getDebugTableForUnif2 = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms),\n        undefinedOnly: true\n      }),\n          missingTable = _getDebugTableForUnif2.table,\n          missingCount = _getDebugTableForUnif2.count;\n\n      if (missingCount > 0) {\n        log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      }\n\n      if (unusedCount > 0) {\n        log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      }\n\n      var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n      log.table(priority, attributeTable)();\n      log.table(priority, uniformTable)();\n      log.table(priority + 1, configTable)();\n      logModel(this, uniforms);\n\n      if (framebuffer) {\n        framebuffer.log({\n          priority: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n\n      log.groupEnd(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id))();\n    }\n  }]);\n\n  return BaseModel;\n}();\n\nexport { BaseModel as default };","map":null,"metadata":{},"sourceType":"module"}