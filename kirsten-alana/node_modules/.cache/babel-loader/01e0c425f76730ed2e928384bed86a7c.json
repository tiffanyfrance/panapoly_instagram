{"ast":null,"code":"'use strict';\n\nmodule.exports = TinySDF;\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n  this.fontSize = fontSize || 24;\n  this.buffer = buffer === undefined ? 3 : buffer;\n  this.cutoff = cutoff || 0.25;\n  this.fontFamily = fontFamily || 'sans-serif';\n  this.fontWeight = fontWeight || 'normal';\n  this.radius = radius || 8;\n  var size = this.size = this.fontSize + this.buffer * 2;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = this.canvas.height = size;\n  this.ctx = this.canvas.getContext('2d');\n  this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n  this.ctx.textBaseline = 'middle';\n  this.ctx.fillStyle = 'black'; // temporary arrays for the distance transform\n\n  this.gridOuter = new Float64Array(size * size);\n  this.gridInner = new Float64Array(size * size);\n  this.f = new Float64Array(size);\n  this.d = new Float64Array(size);\n  this.z = new Float64Array(size + 1);\n  this.v = new Int16Array(size); // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n\n  this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\n\nTinySDF.prototype.draw = function (char) {\n  this.ctx.clearRect(0, 0, this.size, this.size);\n  this.ctx.fillText(char, this.buffer, this.middle);\n  var imgData = this.ctx.getImageData(0, 0, this.size, this.size);\n  var alphaChannel = new Uint8ClampedArray(this.size * this.size);\n\n  for (var i = 0; i < this.size * this.size; i++) {\n    var a = imgData.data[i * 4 + 3] / 255; // alpha value\n\n    this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);\n    this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);\n  }\n\n  edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);\n  edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);\n\n  for (i = 0; i < this.size * this.size; i++) {\n    var d = this.gridOuter[i] - this.gridInner[i];\n    alphaChannel[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));\n  }\n\n  return alphaChannel;\n}; // 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/\n\n\nfunction edt(data, width, height, f, d, v, z) {\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      f[y] = data[y * width + x];\n    }\n\n    edt1d(f, d, v, z, height);\n\n    for (y = 0; y < height; y++) {\n      data[y * width + x] = d[y];\n    }\n  }\n\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      f[x] = data[y * width + x];\n    }\n\n    edt1d(f, d, v, z, width);\n\n    for (x = 0; x < width; x++) {\n      data[y * width + x] = Math.sqrt(d[x]);\n    }\n  }\n} // 1D squared distance transform\n\n\nfunction edt1d(f, d, v, z, n) {\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = +INF;\n\n  for (var q = 1, k = 0; q < n; q++) {\n    var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);\n\n    while (s <= z[k]) {\n      k--;\n      s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);\n    }\n\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = +INF;\n  }\n\n  for (q = 0, k = 0; q < n; q++) {\n    while (z[k + 1] < q) {\n      k++;\n    }\n\n    d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}