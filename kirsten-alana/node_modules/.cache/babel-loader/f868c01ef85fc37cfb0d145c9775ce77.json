{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar R_EARTH = 6378000;\nexport function pointToDensityGridData(points, cellSize, getPosition) {\n  var _pointsToGridHashing2 = _pointsToGridHashing(points, cellSize, getPosition),\n      gridHash = _pointsToGridHashing2.gridHash,\n      gridOffset = _pointsToGridHashing2.gridOffset;\n\n  var layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n\n  return {\n    gridOffset: gridOffset,\n    layerData: layerData\n  };\n}\n\nfunction _pointsToGridHashing() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var cellSize = arguments.length > 1 ? arguments[1] : undefined;\n  var getPosition = arguments.length > 2 ? arguments[2] : undefined;\n  var latMin = Infinity;\n  var latMax = -Infinity;\n  var pLat;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var pt = _step.value;\n      pLat = getPosition(pt)[1];\n\n      if (Number.isFinite(pLat)) {\n        latMin = pLat < latMin ? pLat : latMin;\n        latMax = pLat > latMax ? pLat : latMax;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var centerLat = (latMin + latMax) / 2;\n\n  var gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {\n      gridHash: {},\n      gridOffset: gridOffset\n    };\n  }\n\n  var gridHash = {};\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = points[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _pt = _step2.value;\n\n      var _getPosition = getPosition(_pt),\n          _getPosition2 = _slicedToArray(_getPosition, 2),\n          lng = _getPosition2[0],\n          lat = _getPosition2[1];\n\n      if (Number.isFinite(lat) && Number.isFinite(lng)) {\n        var latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n        var lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n        var key = \"\".concat(latIdx, \"-\").concat(lonIdx);\n        gridHash[key] = gridHash[key] || {\n          count: 0,\n          points: []\n        };\n        gridHash[key].count += 1;\n        gridHash[key].points.push(_pt);\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    gridHash: gridHash,\n    gridOffset: gridOffset\n  };\n}\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce(function (accu, key, i) {\n    var idxs = key.split('-');\n    var latIdx = parseInt(idxs[0], 10);\n    var lonIdx = parseInt(idxs[1], 10);\n    accu.push(Object.assign({\n      index: i,\n      position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]\n    }, gridHash[key]));\n    return accu;\n  }, []);\n}\n\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  var yOffset = _calculateLatOffset(cellSize);\n\n  var xOffset = _calculateLonOffset(latitude, cellSize);\n\n  return {\n    yOffset: yOffset,\n    xOffset: xOffset\n  };\n}\n\nfunction _calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n\nfunction _calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}","map":null,"metadata":{},"sourceType":"module"}