{"ast":null,"code":"import { Matrix4 } from 'math.gl';\nimport { fp64 as fp64Utils } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, log, createIterable, experimental } from '@deck.gl/core';\nvar count = experimental.count;\nimport { AGGREGATION_OPERATION } from './gpu-grid-aggregator-constants';\nvar fp64LowPart = fp64Utils.fp64LowPart;\nvar R_EARTH = 6378000;\nvar DEFAULT_WEIGHT = [1, 0, 0];\nexport function pointToDensityGridData(_ref) {\n  var data = _ref.data,\n      getPosition = _ref.getPosition,\n      cellSizeMeters = _ref.cellSizeMeters,\n      gpuGridAggregator = _ref.gpuGridAggregator,\n      gpuAggregation = _ref.gpuAggregation,\n      aggregationFlags = _ref.aggregationFlags,\n      getWeight = _ref.getWeight,\n      _ref$fp = _ref.fp64,\n      fp64 = _ref$fp === void 0 ? false : _ref$fp,\n      _ref$coordinateSystem = _ref.coordinateSystem,\n      coordinateSystem = _ref$coordinateSystem === void 0 ? COORDINATE_SYSTEM.LNGLAT : _ref$coordinateSystem,\n      _ref$viewport = _ref.viewport,\n      viewport = _ref$viewport === void 0 ? null : _ref$viewport,\n      _ref$boundingBox = _ref.boundingBox,\n      boundingBox = _ref$boundingBox === void 0 ? null : _ref$boundingBox;\n  var gridData = {};\n  log.assert(aggregationFlags.dataChanged || aggregationFlags.cellSizeChanged || aggregationFlags.viewportChanged);\n\n  if (aggregationFlags.dataChanged) {\n    gridData = parseGridData(data, getPosition, getWeight);\n    boundingBox = gridData.boundingBox;\n  }\n\n  var cellSize = [cellSizeMeters, cellSizeMeters];\n  var worldOrigin = [0, 0];\n  log.assert(coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.IDENTITY);\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n    case COORDINATE_SYSTEM.LNGLAT_DEPRECATED:\n      var gridOffset = getGridOffset(boundingBox, cellSizeMeters);\n      cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      worldOrigin = [-180, -90];\n      break;\n\n    case COORDINATE_SYSTEM.IDENTITY:\n      var width = viewport.width,\n          height = viewport.height;\n      worldOrigin = [-width / 2, -height / 2];\n      break;\n\n    default:\n      log.assert(false);\n  }\n\n  var opts = getGPUAggregationParams({\n    boundingBox: boundingBox,\n    cellSize: cellSize,\n    worldOrigin: worldOrigin\n  });\n  var aggregatedData = gpuGridAggregator.run({\n    positions: gridData.positions,\n    positions64xyLow: gridData.positions64xyLow,\n    weights: gridData.weights,\n    cellSize: cellSize,\n    width: opts.width,\n    height: opts.height,\n    gridTransformMatrix: opts.gridTransformMatrix,\n    useGPU: gpuAggregation,\n    changeFlags: aggregationFlags,\n    fp64: fp64\n  });\n  return {\n    countsBuffer: aggregatedData.weight1.aggregationBuffer,\n    maxCountBuffer: aggregatedData.weight1.maxBuffer,\n    countsData: aggregatedData.weight1.aggregationData,\n    maxCountData: aggregatedData.weight1.maxData,\n    gridSize: opts.gridSize,\n    gridOrigin: opts.gridOrigin,\n    cellSize: cellSize,\n    boundingBox: boundingBox\n  };\n}\n\nfunction parseGridData(data, getPosition) {\n  var getWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var pointCount = count(data);\n  var positions = new Float32Array(pointCount * 2);\n  var positions64xyLow = new Float32Array(pointCount * 2);\n  var weightValues = new Float32Array(pointCount * 3);\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  var _createIterable = createIterable(data),\n      iterable = _createIterable.iterable,\n      objectInfo = _createIterable.objectInfo;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var object = _step.value;\n      objectInfo.index++;\n      var position = getPosition(object, objectInfo);\n      var index = objectInfo.index;\n      x = position[0];\n      y = position[1];\n      positions[index * 2] = x;\n      positions[index * 2 + 1] = y;\n      positions64xyLow[index * 2] = fp64LowPart(x);\n      positions64xyLow[index * 2 + 1] = fp64LowPart(y);\n      var weight = getWeight ? getWeight(object, objectInfo) : DEFAULT_WEIGHT;\n\n      if (Array.isArray(weight)) {\n        weightValues[index * 3] = weight[0];\n        weightValues[index * 3 + 1] = weight[1];\n        weightValues[index * 3 + 2] = weight[2];\n      } else {\n        weightValues[index * 3] = weight;\n      }\n\n      if (Number.isFinite(y) && Number.isFinite(x)) {\n        yMin = y < yMin ? y : yMin;\n        yMax = y > yMax ? y : yMax;\n        xMin = x < xMin ? x : xMin;\n        xMax = x > xMax ? x : xMax;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var weights = {\n    weight1: {\n      size: 1,\n      operation: AGGREGATION_OPERATION.SUM,\n      needMax: true,\n      values: weightValues\n    }\n  };\n  var boundingBox = {\n    xMin: xMin,\n    xMax: xMax,\n    yMin: yMin,\n    yMax: yMax\n  };\n  return {\n    positions: positions,\n    positions64xyLow: positions64xyLow,\n    weights: weights,\n    boundingBox: boundingBox\n  };\n}\n\nfunction getGridOffset(boundingBox, cellSize) {\n  var yMin = boundingBox.yMin,\n      yMax = boundingBox.yMax;\n  var latMin = yMin;\n  var latMax = yMax;\n  var centerLat = (latMin + latMax) / 2;\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  var yOffset = calculateLatOffset(cellSize);\n  var xOffset = calculateLonOffset(latitude, cellSize);\n  return {\n    yOffset: yOffset,\n    xOffset: xOffset\n  };\n}\n\nfunction calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n\nfunction calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n}\n\nexport function alignToCell(inValue, cellSize) {\n  var sign = inValue < 0 ? -1 : 1;\n  var value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n  value = Math.floor(value / cellSize) * cellSize;\n  return value * sign;\n}\n\nfunction getGPUAggregationParams(_ref2) {\n  var boundingBox = _ref2.boundingBox,\n      cellSize = _ref2.cellSize,\n      worldOrigin = _ref2.worldOrigin;\n  var yMin = boundingBox.yMin,\n      yMax = boundingBox.yMax,\n      xMin = boundingBox.xMin,\n      xMax = boundingBox.xMax;\n  var originX = alignToCell(xMin - worldOrigin[0], cellSize[0]) + worldOrigin[0];\n  var originY = alignToCell(yMin - worldOrigin[1], cellSize[1]) + worldOrigin[1];\n  var gridTransformMatrix = new Matrix4().translate([-1 * originX, -1 * originY, 0]);\n  var gridOrigin = [originX, originY];\n  var width = xMax - xMin + cellSize[0];\n  var height = yMax - yMin + cellSize[1];\n  var gridSize = [Math.ceil(width / cellSize[0]), Math.ceil(height / cellSize[1])];\n  return {\n    gridOrigin: gridOrigin,\n    gridSize: gridSize,\n    width: width,\n    height: height,\n    gridTransformMatrix: gridTransformMatrix\n  };\n}","map":null,"metadata":{},"sourceType":"module"}