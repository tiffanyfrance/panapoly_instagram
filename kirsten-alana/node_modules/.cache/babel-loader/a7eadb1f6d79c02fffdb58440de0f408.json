{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Matrix4 } from 'math.gl';\nimport { log, assert } from '../../utils';\nimport ScenegraphNode from './scenegraph-node';\n\nvar GroupNode = function (_ScenegraphNode) {\n  _inherits(GroupNode, _ScenegraphNode);\n\n  function GroupNode() {\n    var _this;\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GroupNode);\n\n    props = Array.isArray(props) ? {\n      children: props\n    } : props;\n    var _props = props,\n        _props$children = _props.children,\n        children = _props$children === void 0 ? [] : _props$children;\n    children.every(function (child) {\n      return assert(child instanceof ScenegraphNode);\n    });\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GroupNode).call(this, props));\n    _this.children = children;\n    return _this;\n  }\n\n  _createClass(GroupNode, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n        children[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _children = children; _i < _children.length; _i++) {\n        var child = _children[_i];\n\n        if (Array.isArray(child)) {\n          this.add.apply(this, _toConsumableArray(child));\n        } else {\n          this.children.push(child);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(child) {\n      var children = this.children;\n      var indexOf = children.indexOf(child);\n\n      if (indexOf > -1) {\n        children.splice(indexOf, 1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      this.children = [];\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      this.children.forEach(function (child) {\n        return child[\"delete\"]();\n      });\n      this.removeAll();\n\n      _get(_getPrototypeOf(GroupNode.prototype), \"delete\", this).call(this);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(visitor) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$worldMatrix = _ref.worldMatrix,\n          worldMatrix = _ref$worldMatrix === void 0 ? new Matrix4() : _ref$worldMatrix;\n\n      var modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n\n          if (child instanceof GroupNode) {\n            child.traverse(visitor, {\n              worldMatrix: modelMatrix\n            });\n          } else {\n            visitor(child, {\n              worldMatrix: modelMatrix\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"traverseReverse\",\n    value: function traverseReverse(visitor, opts) {\n      log.warn('traverseReverse is not reverse')();\n      return this.traverse(visitor, opts);\n    }\n  }]);\n\n  return GroupNode;\n}(ScenegraphNode);\n\nexport { GroupNode as default };","map":null,"metadata":{},"sourceType":"module"}