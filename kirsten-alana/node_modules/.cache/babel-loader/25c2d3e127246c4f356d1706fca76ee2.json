{"ast":null,"code":"import earcut from 'earcut';\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (var i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  var targetIndex = targetStartIndex;\n  var len = simplePolygon.length;\n\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (var _j = 0; _j < size; _j++) {\n      target[targetIndex++] = simplePolygon[0][_j] || 0;\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  var srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  var targetIndex = targetStartIndex;\n\n  for (var i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (var _i = 0; _i < size; _i++) {\n      target[targetIndex++] = positions[srcStartIndex + _i];\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\nfunction getFlatVertexCount(positions, size) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIndex = arguments.length > 3 ? arguments[3] : undefined;\n  endIndex = endIndex || positions.length;\n\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n\n  return (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) + (endIndex - startIndex) / size;\n}\n\nexport function getVertexCount(polygon, positionSize) {\n  validate(polygon);\n\n  if (polygon.positions) {\n    var _polygon = polygon,\n        positions = _polygon.positions,\n        holeIndices = _polygon.holeIndices;\n\n    if (holeIndices) {\n      var vertexCount = 0;\n\n      for (var i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(polygon.positions, positionSize, holeIndices[i - 1], holeIndices[i]);\n      }\n\n      return vertexCount;\n    }\n\n    polygon = positions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    return getFlatVertexCount(polygon, positionSize);\n  }\n\n  if (!isSimple(polygon)) {\n    var _vertexCount = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var simplePolygon = _step.value;\n        _vertexCount += getNestedVertexCount(simplePolygon);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _vertexCount;\n  }\n\n  return getNestedVertexCount(polygon);\n}\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n  var positions = new Float64Array(vertexCount * positionSize);\n  var holeIndices = [];\n\n  if (polygon.positions) {\n    var _polygon2 = polygon,\n        srcPositions = _polygon2.positions,\n        srcHoleIndices = _polygon2.holeIndices;\n\n    if (srcHoleIndices) {\n      var targetIndex = 0;\n\n      for (var i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions: positions,\n        holeIndices: holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return {\n      positions: positions,\n      holeIndices: null\n    };\n  }\n\n  if (!isSimple(polygon)) {\n    var _targetIndex = 0;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var simplePolygon = _step2.value;\n        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);\n        holeIndices.push(_targetIndex);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    holeIndices.pop();\n    return {\n      positions: positions,\n      holeIndices: holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return {\n    positions: positions,\n    holeIndices: null\n  };\n}\nexport function getSurfaceIndices(normalizedPolygon, positionSize) {\n  var holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {\n      return positionIndex / positionSize;\n    });\n  }\n\n  return earcut(normalizedPolygon.positions, holeIndices, positionSize);\n}","map":null,"metadata":{},"sourceType":"module"}