{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { parseGLSLCompilerError, getShaderName } from '../glsl-utils';\nimport { assertWebGLContext } from '../webgl-utils';\nimport { uid, log, assert } from '../utils';\nimport Resource from './resource';\nvar ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\nexport var Shader = function (_Resource) {\n  _inherits(Shader, _Resource);\n\n  _createClass(Shader, null, [{\n    key: \"getTypeName\",\n    value: function getTypeName(shaderType) {\n      switch (shaderType) {\n        case 35633:\n          return 'vertex-shader';\n\n        case 35632:\n          return 'fragment-shader';\n\n        default:\n          assert(false);\n          return 'unknown';\n      }\n    }\n  }]);\n\n  function Shader(gl, props) {\n    var _this;\n\n    _classCallCheck(this, Shader);\n\n    assertWebGLContext(gl);\n    assert(typeof props.source === 'string', ERR_SOURCE);\n    var id = getShaderName(props.source, null) || props.id || uid(\"unnamed \".concat(Shader.getTypeName(props.shaderType)));\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Shader).call(this, gl, {\n      id: id\n    }));\n    _this.shaderType = props.shaderType;\n    _this.source = props.source;\n\n    _this.initialize(props);\n\n    return _this;\n  }\n\n  _createClass(Shader, [{\n    key: \"initialize\",\n    value: function initialize(_ref) {\n      var source = _ref.source;\n      var shaderName = getShaderName(source, null);\n\n      if (shaderName) {\n        this.id = uid(shaderName);\n      }\n\n      this._compile(source);\n    }\n  }, {\n    key: \"getParameter\",\n    value: function getParameter(pname) {\n      return this.gl.getShaderParameter(this.handle, pname);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(Shader.getTypeName(this.shaderType), \":\").concat(this.id);\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return getShaderName(this.source) || 'unnamed-shader';\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.gl.getShaderSource(this.handle);\n    }\n  }, {\n    key: \"getTranslatedSource\",\n    value: function getTranslatedSource() {\n      var extension = this.gl.getExtension('WEBGL.debug_shaders');\n      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL.debug_shaders not implemented';\n    }\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      this.gl.shaderSource(this.handle, this.source);\n      this.gl.compileShader(this.handle);\n      var compileStatus = this.getParameter(35713);\n\n      if (!compileStatus) {\n        var infoLog = this.gl.getShaderInfoLog(this.handle);\n\n        var _parseGLSLCompilerErr = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id),\n            shaderName = _parseGLSLCompilerErr.shaderName,\n            errors = _parseGLSLCompilerErr.errors,\n            warnings = _parseGLSLCompilerErr.warnings;\n\n        log.error(\"GLSL compilation errors in \".concat(shaderName, \"\\n\").concat(errors))();\n        log.warn(\"GLSL compilation warnings in \".concat(shaderName, \"\\n\").concat(warnings))();\n        throw new Error(\"GLSL compilation errors in \".concat(shaderName));\n      }\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteShader(this.handle);\n    }\n  }, {\n    key: \"_getOptsFromHandle\",\n    value: function _getOptsFromHandle() {\n      return {\n        type: this.getParameter(35663),\n        source: this.getSource()\n      };\n    }\n  }]);\n\n  return Shader;\n}(Resource);\nexport var VertexShader = function (_Shader) {\n  _inherits(VertexShader, _Shader);\n\n  function VertexShader(gl, props) {\n    _classCallCheck(this, VertexShader);\n\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VertexShader).call(this, gl, Object.assign({}, props, {\n      shaderType: 35633\n    })));\n  }\n\n  _createClass(VertexShader, [{\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createShader(35633);\n    }\n  }]);\n\n  return VertexShader;\n}(Shader);\nexport var FragmentShader = function (_Shader2) {\n  _inherits(FragmentShader, _Shader2);\n\n  function FragmentShader(gl, props) {\n    _classCallCheck(this, FragmentShader);\n\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FragmentShader).call(this, gl, Object.assign({}, props, {\n      shaderType: 35632\n    })));\n  }\n\n  _createClass(FragmentShader, [{\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createShader(35632);\n    }\n  }]);\n\n  return FragmentShader;\n}(Shader);","map":null,"metadata":{},"sourceType":"module"}