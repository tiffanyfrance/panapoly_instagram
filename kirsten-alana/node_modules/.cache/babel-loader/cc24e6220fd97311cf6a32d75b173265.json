{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { getPageLoadPromise, getCanvas } from '@luma.gl/webgl';\nimport { requestAnimationFrame, cancelAnimationFrame } from '@luma.gl/webgl';\nimport { log, assert } from '../utils';\n\nvar AnimationLoopProxy = function () {\n  _createClass(AnimationLoopProxy, null, [{\n    key: \"createWorker\",\n    value: function createWorker(animationLoop) {\n      return function (self) {\n        animationLoop.setProps({\n          useDevicePixels: false,\n          autoResizeDrawingBuffer: false\n        });\n        self.canvas = null;\n\n        function initializeCanvas(canvas) {\n          var eventHandlers = new Map();\n\n          canvas.addEventListener = function (type, handler) {\n            self.postMessage({\n              command: 'addEventListener',\n              type: type\n            });\n\n            if (!eventHandlers.has(type)) {\n              eventHandlers.set(type, []);\n            }\n\n            eventHandlers.get(type).push(handler);\n          };\n\n          canvas.removeEventListener = function (type, handler) {\n            self.postMessage({\n              command: 'removeEventListener',\n              type: type\n            });\n            var handlers = eventHandlers.get(type);\n\n            if (handlers) {\n              handlers.splice(handlers.indexOf(handler), 1);\n            }\n          };\n\n          canvas.dispatchEvent = function (type, event) {\n            var handlers = eventHandlers.get(type);\n\n            if (handlers) {\n              handlers.forEach(function (handler) {\n                return handler(event);\n              });\n            }\n          };\n\n          self.canvas = canvas;\n        }\n\n        self.addEventListener('message', function (evt) {\n          switch (evt.data.command) {\n            case 'start':\n              initializeCanvas(evt.data.opts.canvas);\n              animationLoop.start(evt.data.opts);\n              break;\n\n            case 'stop':\n              animationLoop.stop();\n              break;\n\n            case 'resize':\n              self.canvas.width = evt.data.width;\n              self.canvas.height = evt.data.height;\n              break;\n\n            case 'event':\n              self.canvas.dispatchEvent(evt.data.type, evt.data.event);\n              break;\n\n            default:\n          }\n        });\n      };\n    }\n  }]);\n\n  function AnimationLoopProxy(worker) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, AnimationLoopProxy);\n\n    var _opts$onInitialize = opts.onInitialize,\n        onInitialize = _opts$onInitialize === void 0 ? function () {} : _opts$onInitialize,\n        _opts$onFinalize = opts.onFinalize,\n        onFinalize = _opts$onFinalize === void 0 ? function () {} : _opts$onFinalize,\n        _opts$useDevicePixels = opts.useDevicePixels,\n        useDevicePixels = _opts$useDevicePixels === void 0 ? true : _opts$useDevicePixels,\n        _opts$autoResizeDrawi = opts.autoResizeDrawingBuffer,\n        autoResizeDrawingBuffer = _opts$autoResizeDrawi === void 0 ? true : _opts$autoResizeDrawi;\n    this.props = {\n      onInitialize: onInitialize,\n      onFinalize: onFinalize\n    };\n    this.setProps({\n      autoResizeDrawingBuffer: autoResizeDrawingBuffer,\n      useDevicePixels: useDevicePixels\n    });\n    assert(worker instanceof Worker);\n    this.worker = worker;\n    this.canvas = null;\n    this.width = null;\n    this.height = null;\n    this._running = false;\n    this._animationFrameId = null;\n    this._resolveNextFrame = null;\n    this._nextFramePromise = null;\n    this._onMessage = this._onMessage.bind(this);\n    this._onEvent = this._onEvent.bind(this);\n    this._updateFrame = this._updateFrame.bind(this);\n  }\n\n  _createClass(AnimationLoopProxy, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('autoResizeDrawingBuffer' in props) {\n        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n      }\n\n      if ('useDevicePixels' in props) {\n        this.useDevicePixels = props.useDevicePixels;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._running) {\n        return this;\n      }\n\n      this._running = true;\n      this.worker.onmessage = this._onMessage;\n      getPageLoadPromise().then(function () {\n        if (!_this._running) {\n          return null;\n        }\n\n        _this._createAndTransferCanvas(opts);\n\n        return _this.props.onInitialize(_this);\n      }).then(function () {\n        if (_this._running) {\n          _this._animationFrameId = requestAnimationFrame(_this._updateFrame);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._running) {\n        cancelAnimationFrame(this._animationFrameId);\n        this._animationFrameId = null;\n        this._nextFramePromise = null;\n        this._resolveNextFrame = null;\n        this._running = false;\n        this.props.onFinalize(this);\n      }\n\n      this.worker.postMessage({\n        command: 'stop'\n      });\n      return this;\n    }\n  }, {\n    key: \"waitForRender\",\n    value: function waitForRender() {\n      var _this2 = this;\n\n      if (!this._nextFramePromise) {\n        this._nextFramePromise = new Promise(function (resolve) {\n          _this2._resolveNextFrame = resolve;\n        });\n      }\n\n      return this._nextFramePromise;\n    }\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(evt) {\n      switch (evt.data.command) {\n        case 'addEventListener':\n          this.canvas.addEventListener(evt.data.type, this._onEvent);\n          break;\n\n        case 'removeEventListener':\n          this.canvas.removeEventListener(evt.data.type, this._onEvent);\n          break;\n\n        default:\n      }\n    }\n  }, {\n    key: \"_onEvent\",\n    value: function _onEvent(evt) {\n      var devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;\n      var type = evt.type;\n      var safeEvent = {};\n\n      for (var key in evt) {\n        var value = evt[key];\n\n        var valueType = _typeof(value);\n\n        if (key === 'offsetX' || key === 'offsetY') {\n          value *= devicePixelRatio;\n        }\n\n        if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {\n          safeEvent[key] = value;\n        }\n      }\n\n      this.worker.postMessage({\n        command: 'event',\n        type: type,\n        event: safeEvent\n      });\n    }\n  }, {\n    key: \"_updateFrame\",\n    value: function _updateFrame() {\n      this._resizeCanvasDrawingBuffer();\n\n      if (this._resolveNextFrame) {\n        this._resolveNextFrame(this);\n\n        this._nextFramePromise = null;\n        this._resolveNextFrame = null;\n      }\n\n      this._animationFrameId = requestAnimationFrame(this._updateFrame);\n    }\n  }, {\n    key: \"_createAndTransferCanvas\",\n    value: function _createAndTransferCanvas(opts) {\n      var screenCanvas = getCanvas(opts);\n\n      if (!screenCanvas.transferControlToOffscreen) {\n        log.error('OffscreenCanvas is not available in your browser.')();\n      }\n\n      var offscreenCanvas = screenCanvas.transferControlToOffscreen();\n      this.worker.postMessage({\n        command: 'start',\n        opts: Object.assign({}, opts, {\n          canvas: offscreenCanvas\n        })\n      }, [offscreenCanvas]);\n      this.canvas = screenCanvas;\n    }\n  }, {\n    key: \"_resizeCanvasDrawingBuffer\",\n    value: function _resizeCanvasDrawingBuffer() {\n      if (this.autoResizeDrawingBuffer) {\n        var devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;\n        var width = this.canvas.clientWidth * devicePixelRatio;\n        var height = this.canvas.clientHeight * devicePixelRatio;\n\n        if (this.width !== width || this.height !== height) {\n          this.width = width;\n          this.height = height;\n          this.worker.postMessage({\n            command: 'resize',\n            width: width,\n            height: height\n          });\n        }\n      }\n    }\n  }]);\n\n  return AnimationLoopProxy;\n}();\n\nexport { AnimationLoopProxy as default };","map":null,"metadata":{},"sourceType":"module"}