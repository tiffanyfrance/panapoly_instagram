{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Query, TransformFeedback, Buffer } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nimport BaseModel from './base-model';\nimport { log, isObjectEmpty, uid, assert } from '../utils';\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\nvar LOG_DRAW_PRIORITY = 2;\n\nvar Model = function (_BaseModel) {\n  _inherits(Model, _BaseModel);\n\n  function Model(gl, props) {\n    _classCallCheck(this, Model);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('model') : _props$id;\n    return _possibleConstructorReturn(this, _getPrototypeOf(Model).call(this, gl, _objectSpread({}, props, {\n      id: id\n    })));\n  }\n\n  _createClass(Model, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _get(_getPrototypeOf(Model.prototype), \"initialize\", this).call(this, props);\n\n      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n      this.vertexCount = props.vertexCount || 0;\n      this.geometryBuffers = {};\n      this.isInstanced = props.isInstanced || props.instanced;\n\n      this._setModelProps(props);\n\n      this.geometry = {};\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      _get(_getPrototypeOf(Model.prototype), \"setProps\", this).call(this, props);\n\n      this._setModelProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      _get(_getPrototypeOf(Model.prototype), \"delete\", this).call(this);\n\n      this._deleteGeometryBuffers();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this[\"delete\"]();\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.drawMode = drawMode;\n      return this;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(geometry) {\n      this.drawMode = geometry.drawMode;\n      this.vertexCount = geometry.getVertexCount();\n\n      this._deleteGeometryBuffers();\n\n      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n      this.vertexArray.setAttributes(this.geometryBuffers);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n\n      var normalizedAttributes = {};\n\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n      }\n\n      this.vertexArray.setAttributes(normalizedAttributes);\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.drawGeometry(options);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$discard = options.discard,\n          discard = _options$discard === void 0 ? true : _options$discard,\n          feedbackBuffers = options.feedbackBuffers,\n          _options$unbindModels = options.unbindModels,\n          unbindModels = _options$unbindModels === void 0 ? [] : _options$unbindModels;\n      var parameters = options.parameters;\n\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n\n      try {\n        this.draw(Object.assign({}, options, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n      return this.setUniforms(uniforms).draw();\n    }\n  }, {\n    key: \"_setModelProps\",\n    value: function _setModelProps(props) {\n      if ('instanceCount' in props) {\n        this.instanceCount = props.instanceCount;\n      }\n\n      if ('geometry' in props) {\n        this.setGeometry(props.geometry);\n      }\n\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n\n      if ('_feedbackBuffers' in props) {\n        this._setFeedbackBuffers(props._feedbackBuffers);\n      }\n    }\n  }, {\n    key: \"_deleteGeometryBuffers\",\n    value: function _deleteGeometryBuffers() {\n      for (var name in this.geometryBuffers) {\n        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n        if (buffer instanceof Buffer) {\n          buffer[\"delete\"]();\n        }\n      }\n    }\n  }, {\n    key: \"_setAnimationProps\",\n    value: function _setAnimationProps(animationProps) {\n      var _this = this;\n\n      if (this.animated) {\n        assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n\n        var animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n\n        this.program.setUniforms(animatedUniforms, function () {\n          _this._checkForDeprecatedUniforms(animatedUniforms);\n        });\n      }\n    }\n  }, {\n    key: \"_setFeedbackBuffers\",\n    value: function _setFeedbackBuffers() {\n      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(feedbackBuffers)) {\n        return this;\n      }\n\n      var gl = this.program.gl;\n      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n        program: this.program\n      });\n      this.transformFeedback.setBuffers(feedbackBuffers);\n      return this;\n    }\n  }, {\n    key: \"_timerQueryStart\",\n    value: function _timerQueryStart() {\n      if (this.timerQueryEnabled === true) {\n        if (!this.timeElapsedQuery) {\n          this.timeElapsedQuery = new Query(this.gl);\n        }\n\n        if (this.lastQueryReturned) {\n          this.lastQueryReturned = false;\n          this.timeElapsedQuery.beginTimeElapsedQuery();\n        }\n      }\n    }\n  }, {\n    key: \"_timerQueryEnd\",\n    value: function _timerQueryEnd() {\n      if (this.timerQueryEnabled === true) {\n        this.timeElapsedQuery.end();\n\n        if (this.timeElapsedQuery.isResultAvailable()) {\n          this.lastQueryReturned = true;\n          var elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();\n          this.stats.lastFrameTime = elapsedTime;\n          this.stats.accumulatedFrameTime += elapsedTime;\n          this.stats.profileFrameCount++;\n          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount;\n          log.log(LOG_DRAW_PRIORITY, \"GPU time \".concat(this.program.id, \": \").concat(this.stats.lastFrameTime, \"ms average \").concat(this.stats.averageFrameTime, \"ms accumulated: \").concat(this.stats.accumulatedFrameTime, \"ms count: \").concat(this.stats.profileFrameCount))();\n        }\n      }\n    }\n  }]);\n\n  return Model;\n}(BaseModel);\n\nexport { Model as default };","map":null,"metadata":{},"sourceType":"module"}