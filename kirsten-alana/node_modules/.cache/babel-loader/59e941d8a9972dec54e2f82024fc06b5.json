{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { S2 } from 's2-geometry';\n\nfunction getLevelFromToken(token) {\n  var lastHex = token.substr(token.length - 1);\n  var level = 2 * (token.length - 1) - ((lastHex & 1) === 0);\n  return level;\n}\n\nfunction getIdFromToken(token) {\n  var paddedToken = token.padEnd(16, '0');\n  return String(parseInt(paddedToken, 16));\n}\n\nvar RADIAN_TO_DEGREE = 180 / Math.PI;\nvar MAX_RESOLUTION = 100;\n\nfunction XYZToLngLat(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      x = _ref2[0],\n      y = _ref2[1],\n      z = _ref2[2];\n\n  var lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n  var lng = Math.atan2(y, x);\n  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\n\nfunction getGeoBounds(_ref3) {\n  var face = _ref3.face,\n      ij = _ref3.ij,\n      level = _ref3.level;\n  var result = [];\n  var offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n  var resolution = Math.max(1, MAX_RESOLUTION * Math.pow(2, -level));\n\n  for (var i = 0; i < 4; i++) {\n    var offset = offsets[i].slice(0);\n    var nextOffset = offsets[i + 1];\n    var stepI = (nextOffset[0] - offset[0]) / resolution;\n    var stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (var j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      var st = S2.IJToST(ij, level, offset);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(face, uv);\n      result.push(XYZToLngLat(xyz));\n    }\n  }\n\n  return result;\n}\n\nexport function getS2Polygon(token) {\n  var id = getIdFromToken(token);\n  var level = getLevelFromToken(token);\n  var s2cell = S2.S2Cell.FromLatLng(S2.idToLatLng(id), level);\n  return getGeoBounds(s2cell);\n}","map":null,"metadata":{},"sourceType":"module"}