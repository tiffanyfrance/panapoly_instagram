{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer } from '@deck.gl/core';\nimport { fp64, ScenegraphNode, log } from '@luma.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { MATRIX_ATTRIBUTES } from '../utils/matrix';\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\nvar fp64LowPart = fp64.fp64LowPart;\nvar DEFAULT_COLOR = [255, 255, 255, 255];\nvar defaultProps = {\n  scenegraph: {\n    type: 'object',\n    value: null,\n    async: true\n  },\n  fetch: function (_fetch) {\n    function fetch(_x, _x2) {\n      return _fetch.apply(this, arguments);\n    }\n\n    fetch.toString = function () {\n      return _fetch.toString();\n    };\n\n    return fetch;\n  }(function (url, _ref) {\n    var propName = _ref.propName,\n        layer = _ref.layer;\n\n    if (propName === 'scenegraph') {\n      return load(url, layer.getLoadOptions()).then(function (_ref2) {\n        var scenes = _ref2.scenes;\n        return scenes[0];\n      });\n    }\n\n    return fetch(url).then(function (response) {\n      return response.json();\n    });\n  }),\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getOrientation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getScale: {\n    type: 'accessor',\n    value: [1, 1, 1]\n  },\n  getTranslation: {\n    type: 'accessor',\n    value: [0, 0, 0]\n  },\n  getTransformMatrix: {\n    type: 'accessor',\n    value: []\n  }\n};\n\nvar ScenegraphLayer = function (_Layer) {\n  _inherits(ScenegraphLayer, _Layer);\n\n  function ScenegraphLayer() {\n    _classCallCheck(this, ScenegraphLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScenegraphLayer).apply(this, arguments));\n  }\n\n  _createClass(ScenegraphLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          accessor: 'getPosition',\n          transition: true\n        },\n        instancePositions64xy: {\n          size: 2,\n          accessor: 'getPosition',\n          update: this.calculateInstancePositions64xyLow\n        },\n        instanceColors: {\n          size: 4,\n          accessor: 'getColor',\n          defaultValue: DEFAULT_COLOR,\n          transition: true\n        },\n        instanceModelMatrix: MATRIX_ATTRIBUTES\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions64xyLow\",\n    value: function calculateInstancePositions64xyLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      var _this$props = this.props,\n          data = _this$props.data,\n          getPosition = _this$props.getPosition;\n      var value = attribute.value;\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n          var position = getPosition(point);\n          value[i++] = fp64LowPart(position[0]);\n          value[i++] = fp64LowPart(position[1]);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(params) {\n      _get(_getPrototypeOf(ScenegraphLayer.prototype), \"updateState\", this).call(this, params);\n\n      var props = params.props,\n          oldProps = params.oldProps;\n\n      if (props.scenegraph !== oldProps.scenegraph) {\n        if (props.scenegraph instanceof ScenegraphNode) {\n          this._deleteScenegraph();\n\n          this._applyAllAttributes(props.scenegraph);\n\n          this.setState({\n            scenegraph: props.scenegraph\n          });\n        } else if (props.scenegraph !== null) {\n          log.warn('bad scenegraph:', props.scenegraph)();\n        }\n      }\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      this._deleteScenegraph();\n    }\n  }, {\n    key: \"_applyAllAttributes\",\n    value: function _applyAllAttributes(scenegraph) {\n      var _this = this;\n\n      var allAttributes = this.getAttributeManager().getAttributes();\n      scenegraph.traverse(function (model) {\n        _this._setModelAttributes(model.model, allAttributes);\n      });\n    }\n  }, {\n    key: \"_deleteScenegraph\",\n    value: function _deleteScenegraph() {\n      var scenegraph = this.state.scenegraph;\n\n      if (scenegraph instanceof ScenegraphNode) {\n        scenegraph.delete();\n      }\n    }\n  }, {\n    key: \"getLoadOptions\",\n    value: function getLoadOptions() {\n      return {\n        gl: this.context.gl,\n        waitForFullLoad: true,\n        modelOptions: {\n          vs: vs,\n          fs: fs,\n          modules: ['project32', 'picking'],\n          isInstanced: true\n        }\n      };\n    }\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(props) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(ScenegraphLayer.prototype), \"updateAttributes\", this).call(this, props);\n\n      if (!this.state.scenegraph) return;\n      var attributeManager = this.getAttributeManager();\n      var changedAttributes = attributeManager.getChangedAttributes({\n        clearChangedFlags: true\n      });\n      this.state.scenegraph.traverse(function (model) {\n        _this2._setModelAttributes(model.model, changedAttributes);\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var _ref3$moduleParameter = _ref3.moduleParameters,\n          moduleParameters = _ref3$moduleParameter === void 0 ? null : _ref3$moduleParameter,\n          _ref3$parameters = _ref3.parameters,\n          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;\n      if (!this.state.scenegraph) return;\n      var sizeScale = this.props.sizeScale;\n      var numInstances = this.getNumInstances();\n      this.state.scenegraph.traverse(function (model) {\n        model.model.setInstanceCount(numInstances);\n        model.updateModuleSettings(moduleParameters);\n        model.draw({\n          parameters: parameters,\n          uniforms: {\n            sizeScale: sizeScale\n          }\n        });\n      });\n    }\n  }]);\n\n  return ScenegraphLayer;\n}(Layer);\n\nexport { ScenegraphLayer as default };\nScenegraphLayer.layerName = 'ScenegraphLayer';\nScenegraphLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}