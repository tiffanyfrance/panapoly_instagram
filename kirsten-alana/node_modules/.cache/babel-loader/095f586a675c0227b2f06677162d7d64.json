{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { isWebGL, createGLContext, instrumentGLContext, resizeGLContext, resetParameters, requestAnimationFrame, cancelAnimationFrame, getPageLoadPromise, Query, lumaStats, Framebuffer } from '@luma.gl/webgl';\nimport { log, assert } from '../utils';\nvar statIdCounter = 0;\n\nvar AnimationLoop = function () {\n  function AnimationLoop() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, AnimationLoop);\n\n    var _props$onCreateContex = props.onCreateContext,\n        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {\n      return createGLContext(opts);\n    } : _props$onCreateContex,\n        _props$onAddHTML = props.onAddHTML,\n        onAddHTML = _props$onAddHTML === void 0 ? null : _props$onAddHTML,\n        _props$onInitialize = props.onInitialize,\n        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,\n        _props$onRender = props.onRender,\n        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,\n        _props$onFinalize = props.onFinalize,\n        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,\n        _props$gl = props.gl,\n        gl = _props$gl === void 0 ? null : _props$gl,\n        _props$glOptions = props.glOptions,\n        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,\n        _props$debug = props.debug,\n        debug = _props$debug === void 0 ? false : _props$debug,\n        _props$createFramebuf = props.createFramebuffer,\n        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,\n        _props$autoResizeView = props.autoResizeViewport,\n        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,\n        _props$autoResizeDraw = props.autoResizeDrawingBuffer,\n        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw,\n        _props$stats = props.stats,\n        stats = _props$stats === void 0 ? lumaStats.get(\"animation-loop-\".concat(statIdCounter++)) : _props$stats;\n    var _props$useDevicePixel = props.useDevicePixels,\n        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext: onCreateContext,\n      onAddHTML: onAddHTML,\n      onInitialize: onInitialize,\n      onRender: onRender,\n      onFinalize: onFinalize,\n      gl: gl,\n      glOptions: glOptions,\n      debug: debug,\n      createFramebuffer: createFramebuffer\n    };\n    this.gl = gl;\n    this.needsRedraw = null;\n    this.stats = stats;\n    this.cpuTime = this.stats.get('CPU Time');\n    this.gpuTime = this.stats.get('GPU Time');\n    this.frameRate = this.stats.get('Frame Rate');\n    this._initialized = false;\n    this._running = false;\n    this._animationFrameId = null;\n    this._nextFramePromise = null;\n    this._resolveNextFrame = null;\n    this._cpuStartTime = 0;\n    this.setProps({\n      autoResizeViewport: autoResizeViewport,\n      autoResizeDrawingBuffer: autoResizeDrawingBuffer,\n      useDevicePixels: useDevicePixels\n    });\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._onMousemove = this._onMousemove.bind(this);\n    this._onMouseleave = this._onMouseleave.bind(this);\n  }\n\n  _createClass(AnimationLoop, [{\n    key: \"delete\",\n    value: function _delete() {\n      this.stop();\n\n      this._setDisplay(null);\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      assert(typeof reason === 'string');\n      this.needsRedraw = this.needsRedraw || reason;\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('autoResizeViewport' in props) {\n        this.autoResizeViewport = props.autoResizeViewport;\n      }\n\n      if ('autoResizeDrawingBuffer' in props) {\n        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n      }\n\n      if ('useDevicePixels' in props) {\n        this.useDevicePixels = props.useDevicePixels;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._running) {\n        return this;\n      }\n\n      this._running = true;\n      getPageLoadPromise().then(function () {\n        if (!_this._running || _this._initialized) {\n          return null;\n        }\n\n        _this._createWebGLContext(opts);\n\n        _this._createFramebuffer();\n\n        _this._startEventHandling();\n\n        _this._initializeCallbackData();\n\n        _this._updateCallbackData();\n\n        _this._resizeCanvasDrawingBuffer();\n\n        _this._resizeViewport();\n\n        _this._gpuTimeQuery = Query.isSupported(_this.gl, ['timers']) ? new Query(_this.gl) : null;\n        _this._initialized = true;\n        return _this.onInitialize(_this.animationProps);\n      }).then(function (appContext) {\n        if (_this._running) {\n          _this._addCallbackData(appContext || {});\n\n          if (appContext !== false) {\n            _this._startLoop();\n          }\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this._beginTimers();\n\n      this._setupFrame();\n\n      this._updateCallbackData();\n\n      this._renderFrame(this.animationProps);\n\n      this._clearNeedsRedraw();\n\n      if (this.offScreen && this.gl.commit) {\n        this.gl.commit();\n      }\n\n      if (this._resolveNextFrame) {\n        this._resolveNextFrame(this);\n\n        this._nextFramePromise = null;\n        this._resolveNextFrame = null;\n      }\n\n      this._endTimers();\n\n      return this;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._running) {\n        this._finalizeCallbackData();\n\n        cancelAnimationFrame(this._animationFrameId);\n        this._nextFramePromise = null;\n        this._resolveNextFrame = null;\n        this._animationFrameId = null;\n        this._running = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"waitForRender\",\n    value: function waitForRender() {\n      var _this2 = this;\n\n      this.setNeedsRedraw('waitForRender');\n\n      if (!this._nextFramePromise) {\n        this._nextFramePromise = new Promise(function (resolve) {\n          _this2._resolveNextFrame = resolve;\n        });\n      }\n\n      return this._nextFramePromise;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function () {\n      var _toDataURL = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.setNeedsRedraw('toDataURL');\n                _context.next = 3;\n                return this.waitForRender();\n\n              case 3:\n                return _context.abrupt(\"return\", this.gl.canvas.toDataURL());\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function toDataURL() {\n        return _toDataURL.apply(this, arguments);\n      }\n\n      return toDataURL;\n    }()\n  }, {\n    key: \"onCreateContext\",\n    value: function onCreateContext() {\n      var _this$props;\n\n      return (_this$props = this.props).onCreateContext.apply(_this$props, arguments);\n    }\n  }, {\n    key: \"onInitialize\",\n    value: function onInitialize() {\n      var _this$props2;\n\n      return (_this$props2 = this.props).onInitialize.apply(_this$props2, arguments);\n    }\n  }, {\n    key: \"onRender\",\n    value: function onRender() {\n      var _this$props3;\n\n      return (_this$props3 = this.props).onRender.apply(_this$props3, arguments);\n    }\n  }, {\n    key: \"onFinalize\",\n    value: function onFinalize() {\n      var _this$props4;\n\n      return (_this$props4 = this.props).onFinalize.apply(_this$props4, arguments);\n    }\n  }, {\n    key: \"getHTMLControlValue\",\n    value: function getHTMLControlValue(id) {\n      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var element = document.getElementById(id);\n      return element ? Number(element.value) : defaultValue;\n    }\n  }, {\n    key: \"setViewParameters\",\n    value: function setViewParameters() {\n      log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n      return this;\n    }\n  }, {\n    key: \"_startLoop\",\n    value: function _startLoop() {\n      var _this3 = this;\n\n      var renderFrame = function renderFrame() {\n        if (!_this3._running) {\n          return;\n        }\n\n        _this3.redraw();\n\n        _this3._animationFrameId = _this3._requestAnimationFrame(renderFrame);\n      };\n\n      cancelAnimationFrame(this._animationFrameId);\n      this._animationFrameId = this._requestAnimationFrame(renderFrame);\n    }\n  }, {\n    key: \"_setDisplay\",\n    value: function _setDisplay(display) {\n      if (this.display) {\n        this.display[\"delete\"]();\n        this.display.animationLoop = null;\n      }\n\n      if (display) {\n        display.animationLoop = this;\n      }\n\n      this.display = display;\n    }\n  }, {\n    key: \"_requestAnimationFrame\",\n    value: function _requestAnimationFrame(renderFrameCallback) {\n      if (this.display && this.display.requestAnimationFrame(renderFrameCallback)) {\n        return;\n      }\n\n      requestAnimationFrame(renderFrameCallback);\n    }\n  }, {\n    key: \"_renderFrame\",\n    value: function _renderFrame() {\n      if (this.display) {\n        var _this$display;\n\n        (_this$display = this.display)._renderFrame.apply(_this$display, arguments);\n\n        return;\n      }\n\n      this.onRender.apply(this, arguments);\n    }\n  }, {\n    key: \"_clearNeedsRedraw\",\n    value: function _clearNeedsRedraw() {\n      this.needsRedraw = null;\n    }\n  }, {\n    key: \"_setupFrame\",\n    value: function _setupFrame() {\n      if (this._onSetupFrame) {\n        this._onSetupFrame(this.animationProps);\n      } else {\n        this._resizeCanvasDrawingBuffer();\n\n        this._resizeViewport();\n\n        this._resizeFramebuffer();\n      }\n    }\n  }, {\n    key: \"_initializeCallbackData\",\n    value: function _initializeCallbackData() {\n      this.animationProps = {\n        gl: this.gl,\n        stop: this.stop,\n        canvas: this.gl.canvas,\n        framebuffer: this.framebuffer,\n        useDevicePixels: this.useDevicePixels,\n        needsRedraw: null,\n        startTime: Date.now(),\n        time: 0,\n        tick: 0,\n        tock: 0,\n        _loop: this,\n        _animationLoop: this,\n        _mousePosition: null\n      };\n    }\n  }, {\n    key: \"_updateCallbackData\",\n    value: function _updateCallbackData() {\n      var _this$_getSizeAndAspe = this._getSizeAndAspect(),\n          width = _this$_getSizeAndAspe.width,\n          height = _this$_getSizeAndAspe.height,\n          aspect = _this$_getSizeAndAspe.aspect;\n\n      if (width !== this.animationProps.width || height !== this.animationProps.height) {\n        this.setNeedsRedraw('drawing buffer resized');\n      }\n\n      if (aspect !== this.animationProps.aspect) {\n        this.setNeedsRedraw('drawing buffer aspect changed');\n      }\n\n      this.animationProps.width = width;\n      this.animationProps.height = height;\n      this.animationProps.aspect = aspect;\n      this.animationProps.needsRedraw = this.needsRedraw;\n      this.animationProps.time = Date.now() - this.animationProps.startTime;\n      this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);\n      this.animationProps.tock++;\n      this.animationProps._offScreen = this.offScreen;\n    }\n  }, {\n    key: \"_finalizeCallbackData\",\n    value: function _finalizeCallbackData() {\n      this.onFinalize(this.animationProps);\n    }\n  }, {\n    key: \"_addCallbackData\",\n    value: function _addCallbackData(appContext) {\n      if (_typeof(appContext) === 'object' && appContext !== null) {\n        this.animationProps = Object.assign({}, this.animationProps, appContext);\n      }\n    }\n  }, {\n    key: \"_createWebGLContext\",\n    value: function _createWebGLContext(opts) {\n      this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;\n      opts = Object.assign({}, opts, this.props.glOptions);\n      this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);\n\n      if (!isWebGL(this.gl)) {\n        throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n      }\n\n      resetParameters(this.gl);\n\n      this._createInfoDiv();\n    }\n  }, {\n    key: \"_createInfoDiv\",\n    value: function _createInfoDiv() {\n      if (this.gl.canvas && this.props.onAddHTML) {\n        var wrapperDiv = document.createElement('div');\n        document.body.appendChild(wrapperDiv);\n        wrapperDiv.style.position = 'relative';\n        var div = document.createElement('div');\n        div.style.position = 'absolute';\n        div.style.left = '10px';\n        div.style.bottom = '10px';\n        div.style.width = '300px';\n        div.style.background = 'white';\n        wrapperDiv.appendChild(this.gl.canvas);\n        wrapperDiv.appendChild(div);\n        var html = this.props.onAddHTML(div);\n\n        if (html) {\n          div.innerHTML = html;\n        }\n      }\n    }\n  }, {\n    key: \"_getSizeAndAspect\",\n    value: function _getSizeAndAspect() {\n      var width = this.gl.drawingBufferWidth;\n      var height = this.gl.drawingBufferHeight;\n      var aspect = 1;\n      var _this$gl$canvas = this.gl.canvas,\n          clientWidth = _this$gl$canvas.clientWidth,\n          clientHeight = _this$gl$canvas.clientHeight;\n\n      if (clientWidth > 0 && clientHeight > 0) {\n        aspect = clientWidth / clientHeight;\n      } else if (width > 0 && height > 0) {\n        aspect = width / height;\n      }\n\n      return {\n        width: width,\n        height: height,\n        aspect: aspect\n      };\n    }\n  }, {\n    key: \"_resizeViewport\",\n    value: function _resizeViewport() {\n      if (this.autoResizeViewport) {\n        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n      }\n    }\n  }, {\n    key: \"_resizeCanvasDrawingBuffer\",\n    value: function _resizeCanvasDrawingBuffer() {\n      if (this.autoResizeDrawingBuffer) {\n        resizeGLContext(this.gl, {\n          useDevicePixels: this.useDevicePixels\n        });\n      }\n    }\n  }, {\n    key: \"_createFramebuffer\",\n    value: function _createFramebuffer() {\n      if (this.props.createFramebuffer) {\n        this.framebuffer = new Framebuffer(this.gl);\n      }\n    }\n  }, {\n    key: \"_resizeFramebuffer\",\n    value: function _resizeFramebuffer() {\n      if (this.framebuffer) {\n        this.framebuffer.resize({\n          width: this.gl.drawingBufferWidth,\n          height: this.gl.drawingBufferHeight\n        });\n      }\n    }\n  }, {\n    key: \"_beginTimers\",\n    value: function _beginTimers() {\n      this.frameRate.timeEnd();\n      this.frameRate.timeStart();\n\n      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {\n        this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n      }\n\n      if (this._gpuTimeQuery) {\n        this._gpuTimeQuery.beginTimeElapsedQuery();\n      }\n\n      this.cpuTime.timeStart();\n    }\n  }, {\n    key: \"_endTimers\",\n    value: function _endTimers() {\n      this.cpuTime.timeEnd();\n\n      if (this._gpuTimeQuery) {\n        this._gpuTimeQuery.end();\n      }\n    }\n  }, {\n    key: \"_startEventHandling\",\n    value: function _startEventHandling() {\n      this.gl.canvas.addEventListener('mousemove', this._onMousemove);\n      this.gl.canvas.addEventListener('mouseleave', this._onMouseleave);\n    }\n  }, {\n    key: \"_onMousemove\",\n    value: function _onMousemove(e) {\n      this.animationProps._mousePosition = [e.offsetX, e.offsetY];\n    }\n  }, {\n    key: \"_onMouseleave\",\n    value: function _onMouseleave(e) {\n      this.animationProps._mousePosition = null;\n    }\n  }]);\n\n  return AnimationLoop;\n}();\n\nexport { AnimationLoop as default };","map":null,"metadata":{},"sourceType":"module"}