{"ast":null,"code":"/// S2 Geometry functions\n// the regional scoreboard is based on a level 6 S2 Cell\n// - https://docs.google.com/presentation/d/1Hl4KapfAENAOf4gv-pSngKwvS_jwNVHRPZTTDzXXn6Q/view?pli=1#slide=id.i22\n// at the time of writing there's no actual API for the intel map to retrieve scoreboard data,\n// but it's still useful to plot the score cells on the intel map\n// the S2 geometry is based on projecting the earth sphere onto a cube, with some scaling of face coordinates to\n// keep things close to approximate equal area for adjacent cells\n// to convert a lat,lng into a cell id:\n// - convert lat,lng to x,y,z\n// - convert x,y,z into face,u,v\n// - u,v scaled to s,t with quadratic formula\n// - s,t converted to integer i,j offsets\n// - i,j converted to a position along a Hubbert space-filling curve\n// - combine face,position to get the cell id\n//NOTE: compared to the google S2 geometry library, we vary from their code in the following ways\n// - cell IDs: they combine face and the hilbert curve position into a single 64 bit number. this gives efficient space\n//             and speed. javascript doesn't have appropriate data types, and speed is not cricical, so we use\n//             as [face,[bitpair,bitpair,...]] instead\n// - i,j: they always use 30 bits, adjusting as needed. we use 0 to (1<<level)-1 instead\n//        (so GetSizeIJ for a cell is always 1)\n(function (exports) {\n  'use strict';\n\n  var S2 = exports.S2 = {\n    L: {}\n  };\n\n  S2.L.LatLng = function (\n  /*Number*/\n  rawLat,\n  /*Number*/\n  rawLng,\n  /*Boolean*/\n  noWrap) {\n    var lat = parseFloat(rawLat, 10);\n    var lng = parseFloat(rawLng, 10);\n\n    if (isNaN(lat) || isNaN(lng)) {\n      throw new Error('Invalid LatLng object: (' + rawLat + ', ' + rawLng + ')');\n    }\n\n    if (noWrap !== true) {\n      lat = Math.max(Math.min(lat, 90), -90); // clamp latitude into -90..90\n\n      lng = (lng + 180) % 360 + (lng < -180 || lng === 180 ? 180 : -180); // wrap longtitude into -180..180\n    }\n\n    return {\n      lat: lat,\n      lng: lng\n    };\n  };\n\n  S2.L.LatLng.DEG_TO_RAD = Math.PI / 180;\n  S2.L.LatLng.RAD_TO_DEG = 180 / Math.PI;\n  /*\n  S2.LatLngToXYZ = function(latLng) {\n    // http://stackoverflow.com/questions/8981943/lat-long-to-x-y-z-position-in-js-not-working\n    var lat = latLng.lat;\n    var lon = latLng.lng;\n    var DEG_TO_RAD = Math.PI / 180.0;\n  \n    var phi = lat * DEG_TO_RAD;\n    var theta = lon * DEG_TO_RAD;\n  \n    var cosLat = Math.cos(phi);\n    var sinLat = Math.sin(phi);\n    var cosLon = Math.cos(theta);\n    var sinLon = Math.sin(theta);\n    var rad = 500.0;\n  \n    return [\n      rad * cosLat * cosLon\n    , rad * cosLat * sinLon\n    , rad * sinLat\n    ];\n  };\n  */\n\n  S2.LatLngToXYZ = function (latLng) {\n    var d2r = S2.L.LatLng.DEG_TO_RAD;\n    var phi = latLng.lat * d2r;\n    var theta = latLng.lng * d2r;\n    var cosphi = Math.cos(phi);\n    return [Math.cos(theta) * cosphi, Math.sin(theta) * cosphi, Math.sin(phi)];\n  };\n\n  S2.XYZToLatLng = function (xyz) {\n    var r2d = S2.L.LatLng.RAD_TO_DEG;\n    var lat = Math.atan2(xyz[2], Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1]));\n    var lng = Math.atan2(xyz[1], xyz[0]);\n    return S2.L.LatLng(lat * r2d, lng * r2d);\n  };\n\n  var largestAbsComponent = function largestAbsComponent(xyz) {\n    var temp = [Math.abs(xyz[0]), Math.abs(xyz[1]), Math.abs(xyz[2])];\n\n    if (temp[0] > temp[1]) {\n      if (temp[0] > temp[2]) {\n        return 0;\n      } else {\n        return 2;\n      }\n    } else {\n      if (temp[1] > temp[2]) {\n        return 1;\n      } else {\n        return 2;\n      }\n    }\n  };\n\n  var faceXYZToUV = function faceXYZToUV(face, xyz) {\n    var u, v;\n\n    switch (face) {\n      case 0:\n        u = xyz[1] / xyz[0];\n        v = xyz[2] / xyz[0];\n        break;\n\n      case 1:\n        u = -xyz[0] / xyz[1];\n        v = xyz[2] / xyz[1];\n        break;\n\n      case 2:\n        u = -xyz[0] / xyz[2];\n        v = -xyz[1] / xyz[2];\n        break;\n\n      case 3:\n        u = xyz[2] / xyz[0];\n        v = xyz[1] / xyz[0];\n        break;\n\n      case 4:\n        u = xyz[2] / xyz[1];\n        v = -xyz[0] / xyz[1];\n        break;\n\n      case 5:\n        u = -xyz[1] / xyz[2];\n        v = -xyz[0] / xyz[2];\n        break;\n\n      default:\n        throw {\n          error: 'Invalid face'\n        };\n    }\n\n    return [u, v];\n  };\n\n  S2.XYZToFaceUV = function (xyz) {\n    var face = largestAbsComponent(xyz);\n\n    if (xyz[face] < 0) {\n      face += 3;\n    }\n\n    var uv = faceXYZToUV(face, xyz);\n    return [face, uv];\n  };\n\n  S2.FaceUVToXYZ = function (face, uv) {\n    var u = uv[0];\n    var v = uv[1];\n\n    switch (face) {\n      case 0:\n        return [1, u, v];\n\n      case 1:\n        return [-u, 1, v];\n\n      case 2:\n        return [-u, -v, 1];\n\n      case 3:\n        return [-1, -v, -u];\n\n      case 4:\n        return [v, -1, -u];\n\n      case 5:\n        return [v, u, -1];\n\n      default:\n        throw {\n          error: 'Invalid face'\n        };\n    }\n  };\n\n  var singleSTtoUV = function singleSTtoUV(st) {\n    if (st >= 0.5) {\n      return 1 / 3.0 * (4 * st * st - 1);\n    } else {\n      return 1 / 3.0 * (1 - 4 * (1 - st) * (1 - st));\n    }\n  };\n\n  S2.STToUV = function (st) {\n    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n  };\n\n  var singleUVtoST = function singleUVtoST(uv) {\n    if (uv >= 0) {\n      return 0.5 * Math.sqrt(1 + 3 * uv);\n    } else {\n      return 1 - 0.5 * Math.sqrt(1 - 3 * uv);\n    }\n  };\n\n  S2.UVToST = function (uv) {\n    return [singleUVtoST(uv[0]), singleUVtoST(uv[1])];\n  };\n\n  S2.STToIJ = function (st, order) {\n    var maxSize = 1 << order;\n\n    var singleSTtoIJ = function singleSTtoIJ(st) {\n      var ij = Math.floor(st * maxSize);\n      return Math.max(0, Math.min(maxSize - 1, ij));\n    };\n\n    return [singleSTtoIJ(st[0]), singleSTtoIJ(st[1])];\n  };\n\n  S2.IJToST = function (ij, order, offsets) {\n    var maxSize = 1 << order;\n    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n  };\n\n  var rotateAndFlipQuadrant = function rotateAndFlipQuadrant(n, point, rx, ry) {\n    var newX, newY;\n\n    if (ry == 0) {\n      if (rx == 1) {\n        point.x = n - 1 - point.x;\n        point.y = n - 1 - point.y;\n      }\n\n      var x = point.x;\n      point.x = point.y;\n      point.y = x;\n    }\n  }; // hilbert space-filling curve\n  // based on http://blog.notdot.net/2009/11/Damn-Cool-Algorithms-Spatial-indexing-with-Quadtrees-and-Hilbert-Curves\n  // note: rather then calculating the final integer hilbert position, we just return the list of quads\n  // this ensures no precision issues whth large orders (S3 cell IDs use up to 30), and is more\n  // convenient for pulling out the individual bits as needed later\n\n\n  var pointToHilbertQuadList = function pointToHilbertQuadList(x, y, order, face) {\n    var hilbertMap = {\n      'a': [[0, 'd'], [1, 'a'], [3, 'b'], [2, 'a']],\n      'b': [[2, 'b'], [1, 'b'], [3, 'a'], [0, 'c']],\n      'c': [[2, 'c'], [3, 'd'], [1, 'c'], [0, 'b']],\n      'd': [[0, 'a'], [3, 'c'], [1, 'd'], [2, 'd']]\n    };\n\n    if ('number' !== typeof face) {\n      console.warn(new Error(\"called pointToHilbertQuadList without face value, defaulting to '0'\").stack);\n    }\n\n    var currentSquare = face % 2 ? 'd' : 'a';\n    var positions = [];\n\n    for (var i = order - 1; i >= 0; i--) {\n      var mask = 1 << i;\n      var quad_x = x & mask ? 1 : 0;\n      var quad_y = y & mask ? 1 : 0;\n      var t = hilbertMap[currentSquare][quad_x * 2 + quad_y];\n      positions.push(t[0]);\n      currentSquare = t[1];\n    }\n\n    return positions;\n  }; // S2Cell class\n\n\n  S2.S2Cell = function () {};\n\n  S2.S2Cell.FromHilbertQuadKey = function (hilbertQuadkey) {\n    var parts = hilbertQuadkey.split('/');\n    var face = parseInt(parts[0]);\n    var position = parts[1];\n    var maxLevel = position.length;\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var i;\n    var level;\n    var bit;\n    var rx, ry;\n    var val;\n\n    for (i = maxLevel - 1; i >= 0; i--) {\n      level = maxLevel - i;\n      bit = position[i];\n      rx = 0;\n      ry = 0;\n\n      if (bit === '1') {\n        ry = 1;\n      } else if (bit === '2') {\n        rx = 1;\n        ry = 1;\n      } else if (bit === '3') {\n        rx = 1;\n      }\n\n      val = Math.pow(2, level - 1);\n      rotateAndFlipQuadrant(val, point, rx, ry);\n      point.x += val * rx;\n      point.y += val * ry;\n    }\n\n    if (face % 2 === 1) {\n      var t = point.x;\n      point.x = point.y;\n      point.y = t;\n    }\n\n    return S2.S2Cell.FromFaceIJ(parseInt(face), [point.x, point.y], level);\n  }; //static method to construct\n\n\n  S2.S2Cell.FromLatLng = function (latLng, level) {\n    if (!latLng.lat && latLng.lat !== 0 || !latLng.lng && latLng.lng !== 0) {\n      throw new Error(\"Pass { lat: lat, lng: lng } to S2.S2Cell.FromLatLng\");\n    }\n\n    var xyz = S2.LatLngToXYZ(latLng);\n    var faceuv = S2.XYZToFaceUV(xyz);\n    var st = S2.UVToST(faceuv[1]);\n    var ij = S2.STToIJ(st, level);\n    return S2.S2Cell.FromFaceIJ(faceuv[0], ij, level);\n  };\n  /*\n  S2.faceIjLevelToXyz = function (face, ij, level) {\n    var st = S2.IJToST(ij, level, [0.5, 0.5]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(face, uv);\n  \n    return S2.XYZToLatLng(xyz);\n    return xyz;\n  };\n  */\n\n\n  S2.S2Cell.FromFaceIJ = function (face, ij, level) {\n    var cell = new S2.S2Cell();\n    cell.face = face;\n    cell.ij = ij;\n    cell.level = level;\n    return cell;\n  };\n\n  S2.S2Cell.prototype.toString = function () {\n    return 'F' + this.face + 'ij[' + this.ij[0] + ',' + this.ij[1] + ']@' + this.level;\n  };\n\n  S2.S2Cell.prototype.getLatLng = function () {\n    var st = S2.IJToST(this.ij, this.level, [0.5, 0.5]);\n    var uv = S2.STToUV(st);\n    var xyz = S2.FaceUVToXYZ(this.face, uv);\n    return S2.XYZToLatLng(xyz);\n  };\n\n  S2.S2Cell.prototype.getCornerLatLngs = function () {\n    var result = [];\n    var offsets = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0]];\n\n    for (var i = 0; i < 4; i++) {\n      var st = S2.IJToST(this.ij, this.level, offsets[i]);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(this.face, uv);\n      result.push(S2.XYZToLatLng(xyz));\n    }\n\n    return result;\n  };\n\n  S2.S2Cell.prototype.getFaceAndQuads = function () {\n    var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n    return [this.face, quads];\n  };\n\n  S2.S2Cell.prototype.toHilbertQuadkey = function () {\n    var quads = pointToHilbertQuadList(this.ij[0], this.ij[1], this.level, this.face);\n    return this.face.toString(10) + '/' + quads.join('');\n  };\n\n  S2.latLngToNeighborKeys = S2.S2Cell.latLngToNeighborKeys = function (lat, lng, level) {\n    return S2.S2Cell.FromLatLng({\n      lat: lat,\n      lng: lng\n    }, level).getNeighbors().map(function (cell) {\n      return cell.toHilbertQuadkey();\n    });\n  };\n\n  S2.S2Cell.prototype.getNeighbors = function () {\n    var fromFaceIJWrap = function fromFaceIJWrap(face, ij, level) {\n      var maxSize = 1 << level;\n\n      if (ij[0] >= 0 && ij[1] >= 0 && ij[0] < maxSize && ij[1] < maxSize) {\n        // no wrapping out of bounds\n        return S2.S2Cell.FromFaceIJ(face, ij, level);\n      } else {\n        // the new i,j are out of range.\n        // with the assumption that they're only a little past the borders we can just take the points as\n        // just beyond the cube face, project to XYZ, then re-create FaceUV from the XYZ vector\n        var st = S2.IJToST(ij, level, [0.5, 0.5]);\n        var uv = S2.STToUV(st);\n        var xyz = S2.FaceUVToXYZ(face, uv);\n        var faceuv = S2.XYZToFaceUV(xyz);\n        face = faceuv[0];\n        uv = faceuv[1];\n        st = S2.UVToST(uv);\n        ij = S2.STToIJ(st, level);\n        return S2.S2Cell.FromFaceIJ(face, ij, level);\n      }\n    };\n\n    var face = this.face;\n    var i = this.ij[0];\n    var j = this.ij[1];\n    var level = this.level;\n    return [fromFaceIJWrap(face, [i - 1, j], level), fromFaceIJWrap(face, [i, j - 1], level), fromFaceIJWrap(face, [i + 1, j], level), fromFaceIJWrap(face, [i, j + 1], level)];\n  }; //\n  // Functional Style\n  //\n\n\n  S2.FACE_BITS = 3;\n  S2.MAX_LEVEL = 30;\n  S2.POS_BITS = 2 * S2.MAX_LEVEL + 1; // 61 (60 bits of data, 1 bit lsb marker)\n\n  S2.facePosLevelToId = S2.S2Cell.facePosLevelToId = S2.fromFacePosLevel = function (faceN, posS, levelN) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n\n    var faceB;\n    var posB;\n    var bin;\n\n    if (!levelN) {\n      levelN = posS.length;\n    }\n\n    if (posS.length > levelN) {\n      posS = posS.substr(0, levelN);\n    } // 3-bit face value\n\n\n    faceB = Long.fromString(faceN.toString(10), true, 10).toString(2);\n\n    while (faceB.length < S2.FACE_BITS) {\n      faceB = '0' + faceB;\n    } // 60-bit position value\n\n\n    posB = Long.fromString(posS, true, 4).toString(2);\n\n    while (posB.length < 2 * levelN) {\n      posB = '0' + posB;\n    }\n\n    bin = faceB + posB; // 1-bit lsb marker\n\n    bin += '1'; // n-bit padding to 64-bits\n\n    while (bin.length < S2.FACE_BITS + S2.POS_BITS) {\n      bin += '0';\n    }\n\n    return Long.fromString(bin, true, 2).toString(10);\n  };\n\n  S2.keyToId = S2.S2Cell.keyToId = S2.toId = S2.toCellId = S2.fromKey = function (key) {\n    var parts = key.split('/');\n    return S2.fromFacePosLevel(parts[0], parts[1], parts[1].length);\n  };\n\n  S2.idToKey = S2.S2Cell.idToKey = S2.S2Cell.toKey = S2.toKey = S2.fromId = S2.fromCellId = S2.S2Cell.toHilbertQuadkey = S2.toHilbertQuadkey = function (idS) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n\n    var bin = Long.fromString(idS, true, 10).toString(2);\n\n    while (bin.length < S2.FACE_BITS + S2.POS_BITS) {\n      bin = '0' + bin;\n    } // MUST come AFTER binstr has been left-padded with '0's\n\n\n    var lsbIndex = bin.lastIndexOf('1'); // substr(start, len)\n    // substring(start, end) // includes start, does not include end\n\n    var faceB = bin.substring(0, 3); // posB will always be a multiple of 2 (or it's invalid)\n\n    var posB = bin.substring(3, lsbIndex);\n    var levelN = posB.length / 2;\n    var faceS = Long.fromString(faceB, true, 2).toString(10);\n    var posS = Long.fromString(posB, true, 2).toString(4);\n\n    while (posS.length < levelN) {\n      posS = '0' + posS;\n    }\n\n    return faceS + '/' + posS;\n  };\n\n  S2.keyToLatLng = S2.S2Cell.keyToLatLng = function (key) {\n    var cell2 = S2.S2Cell.FromHilbertQuadKey(key);\n    return cell2.getLatLng();\n  };\n\n  S2.idToLatLng = S2.S2Cell.idToLatLng = function (id) {\n    var key = S2.idToKey(id);\n    return S2.keyToLatLng(key);\n  };\n\n  S2.S2Cell.latLngToKey = S2.latLngToKey = S2.latLngToQuadkey = function (lat, lng, level) {\n    if (isNaN(level) || level < 1 || level > 30) {\n      throw new Error(\"'level' is not a number between 1 and 30 (but it should be)\");\n    } // TODO\n    //\n    // S2.idToLatLng(id)\n    // S2.keyToLatLng(key)\n    // S2.nextFace(key)     // prevent wrapping on nextKey\n    // S2.prevFace(key)     // prevent wrapping on prevKey\n    //\n    // .toKeyArray(id)  // face,quadtree\n    // .toKey(id)       // hilbert\n    // .toPoint(id)     // ij\n    // .toId(key)       // uint64 (as string)\n    // .toLong(key)     // long.js\n    // .toLatLng(id)    // object? or array?, or string (with comma)?\n    //\n    // maybe S2.HQ.x, S2.GPS.x, S2.CI.x?\n\n\n    return S2.S2Cell.FromLatLng({\n      lat: lat,\n      lng: lng\n    }, level).toHilbertQuadkey();\n  };\n\n  S2.stepKey = function (key, num) {\n    var Long = exports.dcodeIO && exports.dcodeIO.Long || require('long');\n\n    var parts = key.split('/');\n    var faceS = parts[0];\n    var posS = parts[1];\n    var level = parts[1].length;\n    var posL = Long.fromString(posS, true, 4); // TODO handle wrapping (0 === pos + 1)\n    // (only on the 12 edges of the globe)\n\n    var otherL;\n\n    if (num > 0) {\n      otherL = posL.add(Math.abs(num));\n    } else if (num < 0) {\n      otherL = posL.subtract(Math.abs(num));\n    }\n\n    var otherS = otherL.toString(4);\n\n    if ('0' === otherS) {\n      console.warning(new Error(\"face/position wrapping is not yet supported\"));\n    }\n\n    while (otherS.length < level) {\n      otherS = '0' + otherS;\n    }\n\n    return faceS + '/' + otherS;\n  };\n\n  S2.S2Cell.prevKey = S2.prevKey = function (key) {\n    return S2.stepKey(key, -1);\n  };\n\n  S2.S2Cell.nextKey = S2.nextKey = function (key) {\n    return S2.stepKey(key, 1);\n  };\n})('undefined' !== typeof module ? module.exports : window);","map":null,"metadata":{},"sourceType":"script"}