{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { equals } from 'math.gl';\nimport { CompositeLayer } from '@deck.gl/core';\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from './contour-utils';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { pointToDensityGridData } from '../utils/gpu-grid-aggregation/grid-aggregation-utils';\nvar DEFAULT_COLOR = [255, 255, 255, 255];\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_THRESHOLD = 1;\nvar defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getWeight: {\n    type: 'accessor',\n    value: function value(x) {\n      return 1;\n    }\n  },\n  contours: [{\n    threshold: DEFAULT_THRESHOLD\n  }],\n  fp64: false,\n  zOffset: 0.005\n};\n\nvar ContourLayer = function (_CompositeLayer) {\n  _inherits(ContourLayer, _CompositeLayer);\n\n  function ContourLayer() {\n    _classCallCheck(this, ContourLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ContourLayer).apply(this, arguments));\n  }\n\n  _createClass(ContourLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var options = {\n        id: \"\".concat(this.id, \"-gpu-aggregator\"),\n        shaderCache: this.context.shaderCache\n      };\n      this.state = {\n        contourData: {},\n        gridAggregator: new GPUGridAggregator(gl, options),\n        colorTrigger: 0,\n        strokeWidthTrigger: 0\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var dataChanged = false;\n      var contoursChanged = false;\n\n      var aggregationFlags = this._getAggregationFlags({\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n\n      if (aggregationFlags) {\n        dataChanged = true;\n        this.setState({\n          countsData: null\n        });\n\n        this._aggregateData(aggregationFlags);\n      }\n\n      if (this._shouldRebuildContours({\n        oldProps: oldProps,\n        props: props\n      })) {\n        contoursChanged = true;\n\n        this._updateThresholdData(props);\n      }\n\n      if (dataChanged || contoursChanged) {\n        this._generateContours();\n      } else {\n        this._updateSubLayerTriggers(oldProps, props);\n      }\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this$state$contourDa = this.state.contourData,\n          contourSegments = _this$state$contourDa.contourSegments,\n          contourPolygons = _this$state$contourDa.contourPolygons;\n      var hasIsolines = contourSegments && contourSegments.length > 0;\n      var hasIsobands = contourPolygons && contourPolygons.length > 0;\n      var lineLayer = hasIsolines && new LineLayer(this._getLineLayerProps());\n      var solidPolygonLayer = hasIsobands && new SolidPolygonLayer(this._getSolidPolygonLayerProps());\n      return [lineLayer, solidPolygonLayer];\n    }\n  }, {\n    key: \"_aggregateData\",\n    value: function _aggregateData(aggregationFlags) {\n      var _this$props = this.props,\n          data = _this$props.data,\n          cellSizeMeters = _this$props.cellSize,\n          getPosition = _this$props.getPosition,\n          getWeight = _this$props.getWeight,\n          gpuAggregation = _this$props.gpuAggregation,\n          fp64 = _this$props.fp64,\n          coordinateSystem = _this$props.coordinateSystem;\n\n      var _pointToDensityGridDa = pointToDensityGridData({\n        data: data,\n        cellSizeMeters: cellSizeMeters,\n        getPosition: getPosition,\n        getWeight: getWeight,\n        gpuAggregation: gpuAggregation,\n        gpuGridAggregator: this.state.gridAggregator,\n        fp64: fp64,\n        coordinateSystem: coordinateSystem,\n        viewport: this.context.viewport,\n        boundingBox: this.state.boundingBox,\n        aggregationFlags: aggregationFlags\n      }),\n          countsData = _pointToDensityGridDa.countsData,\n          countsBuffer = _pointToDensityGridDa.countsBuffer,\n          gridSize = _pointToDensityGridDa.gridSize,\n          gridOrigin = _pointToDensityGridDa.gridOrigin,\n          cellSize = _pointToDensityGridDa.cellSize,\n          boundingBox = _pointToDensityGridDa.boundingBox;\n\n      this.setState({\n        countsData: countsData,\n        countsBuffer: countsBuffer,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        cellSize: cellSize,\n        boundingBox: boundingBox\n      });\n    }\n  }, {\n    key: \"_generateContours\",\n    value: function _generateContours() {\n      var _this$state = this.state,\n          gridSize = _this$state.gridSize,\n          gridOrigin = _this$state.gridOrigin,\n          cellSize = _this$state.cellSize,\n          thresholdData = _this$state.thresholdData;\n      var countsData = this.state.countsData;\n\n      if (!countsData) {\n        var countsBuffer = this.state.countsBuffer;\n        countsData = countsBuffer.getData();\n        this.setState({\n          countsData: countsData\n        });\n      }\n\n      var _GPUGridAggregator$ge = GPUGridAggregator.getCellData({\n        countsData: countsData\n      }),\n          cellWeights = _GPUGridAggregator$ge.cellWeights;\n\n      var contourData = generateContours({\n        thresholdData: thresholdData,\n        cellWeights: cellWeights,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        cellSize: cellSize\n      });\n      this.setState({\n        contourData: contourData\n      });\n    }\n  }, {\n    key: \"_getAggregationFlags\",\n    value: function _getAggregationFlags(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n      var aggregationFlags = null;\n\n      if (changeFlags.dataChanged || oldProps.gpuAggregation !== props.gpuAggregation || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition)) {\n        aggregationFlags = Object.assign({}, aggregationFlags, {\n          dataChanged: true\n        });\n      }\n\n      if (oldProps.cellSize !== props.cellSize) {\n        aggregationFlags = Object.assign({}, aggregationFlags, {\n          cellSizeChanged: true\n        });\n      }\n\n      return aggregationFlags;\n    }\n  }, {\n    key: \"_getLineLayerProps\",\n    value: function _getLineLayerProps() {\n      var fp64 = this.props.fp64;\n      var _this$state2 = this.state,\n          colorTrigger = _this$state2.colorTrigger,\n          strokeWidthTrigger = _this$state2.strokeWidthTrigger;\n      return this.getSubLayerProps({\n        id: 'contour-line-layer',\n        data: this.state.contourData.contourSegments,\n        fp64: fp64,\n        getSourcePosition: function getSourcePosition(d) {\n          return d.start;\n        },\n        getTargetPosition: function getTargetPosition(d) {\n          return d.end;\n        },\n        getColor: this._onGetSublayerColor.bind(this),\n        getWidth: this._onGetSublayerStrokeWidth.bind(this),\n        widthUnits: 'pixels',\n        updateTriggers: {\n          getColor: colorTrigger,\n          getWidth: strokeWidthTrigger\n        }\n      });\n    }\n  }, {\n    key: \"_getSolidPolygonLayerProps\",\n    value: function _getSolidPolygonLayerProps() {\n      var fp64 = this.props.fp64;\n      var colorTrigger = this.state.colorTrigger;\n      return this.getSubLayerProps({\n        id: 'contour-solid-polygon-layer',\n        data: this.state.contourData.contourPolygons,\n        fp64: fp64,\n        getPolygon: function getPolygon(d) {\n          return d.vertices;\n        },\n        getFillColor: this._onGetSublayerColor.bind(this),\n        updateTriggers: {\n          getFillColor: colorTrigger\n        }\n      });\n    }\n  }, {\n    key: \"_onGetSublayerColor\",\n    value: function _onGetSublayerColor(element) {\n      var contours = this.props.contours;\n      var color = DEFAULT_COLOR;\n      contours.forEach(function (data) {\n        if (equals(data.threshold, element.threshold)) {\n          color = data.color || DEFAULT_COLOR;\n        }\n      });\n      return color;\n    }\n  }, {\n    key: \"_onGetSublayerStrokeWidth\",\n    value: function _onGetSublayerStrokeWidth(segment) {\n      var contours = this.props.contours;\n      var strokeWidth = DEFAULT_STROKE_WIDTH;\n      contours.some(function (contour) {\n        if (contour.threshold === segment.threshold) {\n          strokeWidth = contour.strokeWidth || DEFAULT_STROKE_WIDTH;\n          return true;\n        }\n\n        return false;\n      });\n      return strokeWidth;\n    }\n  }, {\n    key: \"_shouldRebuildContours\",\n    value: function _shouldRebuildContours(_ref3) {\n      var oldProps = _ref3.oldProps,\n          props = _ref3.props;\n\n      if (!oldProps.contours || !oldProps.zOffset || oldProps.contours.length !== props.contours.length || oldProps.zOffset !== props.zOffset) {\n        return true;\n      }\n\n      var oldThresholds = oldProps.contours.map(function (x) {\n        return x.threshold;\n      });\n      var thresholds = props.contours.map(function (x) {\n        return x.threshold;\n      });\n      return thresholds.some(function (_, i) {\n        return !equals(thresholds[i], oldThresholds[i]);\n      });\n    }\n  }, {\n    key: \"_updateSubLayerTriggers\",\n    value: function _updateSubLayerTriggers(oldProps, props) {\n      if (oldProps && oldProps.contours && props && props.contours) {\n        if (props.contours.some(function (contour, i) {\n          return contour.color !== oldProps.contours[i].color;\n        })) {\n          this.state.colorTrigger++;\n        }\n\n        if (props.contours.some(function (contour, i) {\n          return contour.strokeWidth !== oldProps.contours[i].strokeWidth;\n        })) {\n          this.state.strokeWidthTrigger++;\n        }\n      }\n    }\n  }, {\n    key: \"_updateThresholdData\",\n    value: function _updateThresholdData(props) {\n      var thresholdData = props.contours.map(function (x, index) {\n        return {\n          threshold: x.threshold,\n          zIndex: x.zIndex || index,\n          zOffset: props.zOffset\n        };\n      });\n      this.setState({\n        thresholdData: thresholdData\n      });\n    }\n  }]);\n\n  return ContourLayer;\n}(CompositeLayer);\n\nexport { ContourLayer as default };\nContourLayer.layerName = 'ContourLayer';\nContourLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}