{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer, log, createIterable } from '@deck.gl/core';\nimport { Model, CylinderGeometry, fp64, PhongMaterial } from '@luma.gl/core';\nvar fp64LowPart = fp64.fp64LowPart;\nvar defaultMaterial = new PhongMaterial();\nimport vs from './column-layer-vertex.glsl';\nimport fs from './column-layer-fragment.glsl';\nvar DEFAULT_COLOR = [255, 0, 255, 255];\nvar defaultProps = {\n  diskResolution: {\n    type: 'number',\n    min: 4,\n    value: 20\n  },\n  vertices: null,\n  radius: {\n    type: 'number',\n    min: 0,\n    value: 1000\n  },\n  angle: {\n    type: 'number',\n    value: 0\n  },\n  offset: {\n    type: 'array',\n    value: [0, 0]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  extruded: true,\n  fp64: false,\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: defaultMaterial\n};\n\nvar ColumnLayer = function (_Layer) {\n  _inherits(ColumnLayer, _Layer);\n\n  function ColumnLayer() {\n    _classCallCheck(this, ColumnLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ColumnLayer).apply(this, arguments));\n  }\n\n  _createClass(ColumnLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [projectModule, 'gouraud-lighting', 'picking']\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          transition: true,\n          accessor: 'getPosition'\n        },\n        instanceElevations: {\n          size: 1,\n          transition: true,\n          accessor: 'getElevation'\n        },\n        instancePositions64xyLow: {\n          size: 2,\n          accessor: 'getPosition',\n          update: this.calculateInstancePositions64xyLow\n        },\n        instanceColors: {\n          size: 4,\n          type: 5121,\n          transition: true,\n          accessor: 'getColor',\n          defaultValue: DEFAULT_COLOR\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      _get(_getPrototypeOf(ColumnLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      if (props.fp64 !== oldProps.fp64 || props.diskResolution !== oldProps.diskResolution) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model.delete();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n\n      if (props.vertices !== oldProps.vertices) {\n        this._updateVertices(props.vertices);\n      }\n    }\n  }, {\n    key: \"getGeometry\",\n    value: function getGeometry(diskResolution) {\n      return new CylinderGeometry({\n        radius: 1,\n        topCap: false,\n        bottomCap: true,\n        height: 2,\n        verticalAxis: 'z',\n        nradial: diskResolution,\n        nvertical: 1\n      });\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: this.getGeometry(this.props.diskResolution),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      }));\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(vertices) {\n      if (!vertices) {\n        return;\n      }\n\n      var diskResolution = this.props.diskResolution;\n      log.assert(vertices.length >= diskResolution);\n      var model = this.state.model;\n      var geometry = this.getGeometry(this.props.diskResolution);\n      var positions = geometry.attributes.POSITION;\n      var i = 0;\n\n      for (var loopIndex = 0; loopIndex < 3; loopIndex++) {\n        for (var j = 0; j <= diskResolution; j++) {\n          var p = vertices[j] || vertices[0];\n          positions.value[i++] = p[0];\n          positions.value[i++] = p[1];\n          i++;\n        }\n      }\n\n      model.setProps({\n        geometry: geometry\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          extruded = _this$props.extruded,\n          offset = _this$props.offset,\n          coverage = _this$props.coverage,\n          radius = _this$props.radius,\n          angle = _this$props.angle;\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        radius: radius,\n        angle: angle / 180 * Math.PI,\n        offset: offset,\n        extruded: extruded,\n        coverage: coverage,\n        elevationScale: elevationScale\n      })).draw();\n    }\n  }, {\n    key: \"calculateInstancePositions64xyLow\",\n    value: function calculateInstancePositions64xyLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getPosition = _this$props2.getPosition;\n      var value = attribute.value;\n      var i = 0;\n\n      var _createIterable = createIterable(data),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          objectInfo.index++;\n          var position = getPosition(object, objectInfo);\n          value[i++] = fp64LowPart(position[0]);\n          value[i++] = fp64LowPart(position[1]);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ColumnLayer;\n}(Layer);\n\nexport { ColumnLayer as default };\nColumnLayer.layerName = 'ColumnLayer';\nColumnLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}