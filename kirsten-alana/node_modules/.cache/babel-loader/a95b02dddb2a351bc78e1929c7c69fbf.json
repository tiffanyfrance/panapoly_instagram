{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Attribute from './attribute';\nimport log from '../utils/log';\nimport AttributeTransitionManager from './attribute-transition-manager';\nvar LOG_START_END_PRIORITY = 2;\nvar LOG_DETAIL_PRIORITY = 3;\n\nfunction noop() {}\n\nvar logFunctions = {\n  savedMessages: null,\n  timeStart: null,\n  onLog: function onLog(_ref) {\n    var level = _ref.level,\n        message = _ref.message;\n    log.log(level, message)();\n  },\n  onUpdateStart: function onUpdateStart(_ref2) {\n    var level = _ref2.level,\n        numInstances = _ref2.numInstances;\n    logFunctions.savedMessages = [];\n    logFunctions.timeStart = new Date();\n  },\n  onUpdate: function onUpdate(_ref3) {\n    var level = _ref3.level,\n        message = _ref3.message;\n\n    if (logFunctions.savedMessages) {\n      logFunctions.savedMessages.push(message);\n    }\n  },\n  onUpdateEnd: function onUpdateEnd(_ref4) {\n    var level = _ref4.level,\n        id = _ref4.id,\n        numInstances = _ref4.numInstances;\n    var timeMs = Math.round(new Date() - logFunctions.timeStart);\n    var time = \"\".concat(timeMs, \"ms\");\n    log.group(level, \"Updated attributes for \".concat(numInstances, \" instances in \").concat(id, \" in \").concat(time), {\n      collapsed: true\n    })();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var message = _step.value;\n        log.log(level, message)();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    log.groupEnd(level, \"Updated attributes for \".concat(numInstances, \" instances in \").concat(id, \" in \").concat(time))();\n    logFunctions.savedMessages = null;\n  }\n};\n\nvar AttributeManager = function () {\n  _createClass(AttributeManager, null, [{\n    key: \"setDefaultLogFunctions\",\n    value: function setDefaultLogFunctions() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          onLog = _ref5.onLog,\n          onUpdateStart = _ref5.onUpdateStart,\n          onUpdate = _ref5.onUpdate,\n          onUpdateEnd = _ref5.onUpdateEnd;\n\n      if (onLog !== undefined) {\n        logFunctions.onLog = onLog || noop;\n      }\n\n      if (onUpdateStart !== undefined) {\n        logFunctions.onUpdateStart = onUpdateStart || noop;\n      }\n\n      if (onUpdate !== undefined) {\n        logFunctions.onUpdate = onUpdate || noop;\n      }\n\n      if (onUpdateEnd !== undefined) {\n        logFunctions.onUpdateEnd = onUpdateEnd || noop;\n      }\n    }\n  }]);\n\n  function AttributeManager(gl) {\n    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref6$id = _ref6.id,\n        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,\n        stats = _ref6.stats;\n\n    _classCallCheck(this, AttributeManager);\n\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\")\n    });\n    Object.seal(this);\n  }\n\n  _createClass(AttributeManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].delete();\n      }\n\n      this.attributeTransitionManager.finalize();\n    }\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;\n      return redraw && this.id;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = true;\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(attributes, updaters) {\n      this._add(attributes, updaters);\n    }\n  }, {\n    key: \"addInstanced\",\n    value: function addInstanced(attributes, updaters) {\n      this._add(attributes, updaters, {\n        instanced: 1\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(attributeNameArray) {\n      for (var i = 0; i < attributeNameArray.length; i++) {\n        var name = attributeNameArray[i];\n\n        if (this.attributes[name] !== undefined) {\n          this.attributes[name].delete();\n          delete this.attributes[name];\n        }\n      }\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(triggerName) {\n      var invalidatedAttributes = this._invalidateTrigger(triggerName);\n\n      logFunctions.onLog({\n        level: LOG_DETAIL_PRIORITY,\n        message: \"invalidated attributes \".concat(invalidatedAttributes, \" (\").concat(triggerName, \") for \").concat(this.id)\n      });\n    }\n  }, {\n    key: \"invalidateAll\",\n    value: function invalidateAll() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].setNeedsUpdate();\n      }\n\n      logFunctions.onLog({\n        level: LOG_DETAIL_PRIORITY,\n        message: \"invalidated all attributes for \".concat(this.id)\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref7.data,\n          numInstances = _ref7.numInstances,\n          transitions = _ref7.transitions,\n          _ref7$props = _ref7.props,\n          props = _ref7$props === void 0 ? {} : _ref7$props,\n          _ref7$buffers = _ref7.buffers,\n          buffers = _ref7$buffers === void 0 ? {} : _ref7$buffers,\n          _ref7$context = _ref7.context,\n          context = _ref7$context === void 0 ? {} : _ref7$context;\n\n      var updated = false;\n      logFunctions.onUpdateStart({\n        level: LOG_START_END_PRIORITY,\n        id: this.id,\n        numInstances: numInstances\n      });\n\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeStart();\n      }\n\n      for (var attributeName in this.attributes) {\n        var attribute = this.attributes[attributeName];\n\n        if (attribute.setExternalBuffer(buffers[attributeName], this.numInstances)) {} else if (attribute.setGenericValue(props[attribute.getAccessor()])) {} else if (attribute.needsUpdate()) {\n          updated = true;\n\n          this._updateAttribute({\n            attribute: attribute,\n            numInstances: numInstances,\n            data: data,\n            props: props,\n            context: context\n          });\n        }\n\n        this.needsRedraw |= attribute.needsRedraw();\n      }\n\n      if (updated) {\n        logFunctions.onUpdateEnd({\n          level: LOG_START_END_PRIORITY,\n          id: this.id,\n          numInstances: numInstances\n        });\n      }\n\n      if (this.stats) {\n        this.stats.get('Update Attributes').timeEnd();\n      }\n\n      this.attributeTransitionManager.update({\n        attributes: this.attributes,\n        numInstances: numInstances,\n        transitions: transitions\n      });\n    }\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition(timestamp) {\n      var attributeTransitionManager = this.attributeTransitionManager;\n      var transitionUpdated = attributeTransitionManager.setCurrentTime(timestamp);\n      this.needsRedraw = this.needsRedraw || transitionUpdated;\n      return transitionUpdated;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getChangedAttributes\",\n    value: function getChangedAttributes() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearChangedFlags: false\n      };\n      var attributes = this.attributes,\n          attributeTransitionManager = this.attributeTransitionManager;\n      var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {\n          changedAttributes[attributeName] = attribute;\n        }\n      }\n\n      return changedAttributes;\n    }\n  }, {\n    key: \"getAccessors\",\n    value: function getAccessors() {\n      return this.updateTriggers;\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(attributes, updaters) {\n      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (updaters) {\n        log.warn('AttributeManager.add({updaters}) - updater map no longer supported')();\n      }\n\n      var newAttributes = {};\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        var newAttribute = this._createAttribute(attributeName, attribute, extraProps);\n\n        newAttributes[attributeName] = newAttribute;\n      }\n\n      Object.assign(this.attributes, newAttributes);\n\n      this._mapUpdateTriggersToAttributes();\n    }\n  }, {\n    key: \"_createAttribute\",\n    value: function _createAttribute(name, attribute, extraProps) {\n      var props = {\n        id: name,\n        constant: attribute.constant || false,\n        isIndexed: attribute.isIndexed || attribute.elements,\n        size: attribute.elements && 1 || attribute.size,\n        value: attribute.value || null,\n        divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor\n      };\n      return new Attribute(this.gl, Object.assign({}, attribute, props));\n    }\n  }, {\n    key: \"_mapUpdateTriggersToAttributes\",\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n\n      var triggers = {};\n\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        attribute.getUpdateTriggers().forEach(function (triggerName) {\n          if (!triggers[triggerName]) {\n            triggers[triggerName] = [];\n          }\n\n          triggers[triggerName].push(attributeName);\n        });\n      };\n\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: \"_invalidateTrigger\",\n    value: function _invalidateTrigger(triggerName) {\n      var attributes = this.attributes,\n          updateTriggers = this.updateTriggers;\n      var invalidatedAttributes = updateTriggers[triggerName];\n\n      if (invalidatedAttributes) {\n        invalidatedAttributes.forEach(function (name) {\n          var attribute = attributes[name];\n\n          if (attribute) {\n            attribute.setNeedsUpdate();\n          }\n        });\n      } else {\n        var message = \"invalidating non-existent trigger \".concat(triggerName, \" for \").concat(this.id, \"\\n\");\n        message += \"Valid triggers: \".concat(Object.keys(attributes).join(', '));\n        log.warn(message, invalidatedAttributes)();\n      }\n\n      return invalidatedAttributes;\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(_ref8) {\n      var attribute = _ref8.attribute,\n          numInstances = _ref8.numInstances,\n          data = _ref8.data,\n          props = _ref8.props,\n          context = _ref8.context;\n\n      if (attribute.allocate(numInstances)) {\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: \"\".concat(attribute.id, \" allocated \").concat(numInstances),\n          id: this.id\n        });\n      }\n\n      var timeStart = Date.now();\n      var updated = attribute.updateBuffer({\n        numInstances: numInstances,\n        data: data,\n        props: props,\n        context: context\n      });\n\n      if (updated) {\n        this.needsRedraw = true;\n        var timeMs = Math.round(Date.now() - timeStart);\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: \"\".concat(attribute.id, \" updated \").concat(numInstances, \" in \").concat(timeMs, \"ms\")\n        });\n      }\n    }\n  }]);\n\n  return AttributeManager;\n}();\n\nexport { AttributeManager as default };","map":null,"metadata":{},"sourceType":"module"}