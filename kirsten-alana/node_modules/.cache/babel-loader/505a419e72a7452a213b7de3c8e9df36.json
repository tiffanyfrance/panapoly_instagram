{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer } from '@deck.gl/core';\nimport { Model, CubeGeometry, fp64, PhongMaterial } from '@luma.gl/core';\nvar fp64LowPart = fp64.fp64LowPart;\nvar defaultMaterial = new PhongMaterial();\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\nvar DEFAULT_MINCOLOR = [0, 0, 0, 255];\nvar DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nvar AGGREGATION_DATA_UBO_INDEX = 0;\nvar defaultProps = {\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  extruded: true,\n  fp64: false,\n  pickable: false,\n  minColor: {\n    type: 'color',\n    value: DEFAULT_MINCOLOR\n  },\n  maxColor: {\n    type: 'color',\n    value: DEFAULT_MAXCOLOR\n  },\n  material: defaultMaterial\n};\n\nvar GPUGridCellLayer = function (_Layer) {\n  _inherits(GPUGridCellLayer, _Layer);\n\n  function GPUGridCellLayer() {\n    _classCallCheck(this, GPUGridCellLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GPUGridCellLayer).apply(this, arguments));\n  }\n\n  _createClass(GPUGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return {\n        vs: vs,\n        fs: fs,\n        modules: ['project32', 'gouraud-lighting', 'picking', 'fp64']\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instanceCounts: {\n          size: 4,\n          update: this.calculateInstanceCounts,\n          noAlloc: true\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      _get(_getPrototypeOf(GPUGridCellLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model.delete();\n        }\n\n        var model = this._getModel(gl);\n\n        this._setupUniformBuffer(model);\n\n        this.setState({\n          model: model\n        });\n        this.state.attributeManager.invalidate('instanceCounts');\n      }\n\n      if (props.countsBuffer !== oldProps.countsBuffer) {\n        this.state.attributeManager.invalidate('instanceCounts');\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new CubeGeometry(),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n          cellSize = _this$props.cellSize,\n          extruded = _this$props.extruded,\n          elevationScale = _this$props.elevationScale,\n          coverage = _this$props.coverage,\n          gridSize = _this$props.gridSize,\n          gridOrigin = _this$props.gridOrigin,\n          gridOffset = _this$props.gridOffset,\n          minColor = _this$props.minColor,\n          maxColor = _this$props.maxColor,\n          maxCountBuffer = _this$props.maxCountBuffer;\n      var gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n      var gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n      maxCountBuffer.bind({\n        target: 35345,\n        index: AGGREGATION_DATA_UBO_INDEX\n      });\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        cellSize: cellSize,\n        extruded: extruded,\n        elevationScale: elevationScale,\n        coverage: coverage,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        gridOriginLow: gridOriginLow,\n        gridOffset: gridOffset,\n        gridOffsetLow: gridOffsetLow,\n        minColor: minColor,\n        maxColor: maxColor\n      })).draw();\n      maxCountBuffer.unbind({\n        target: 35345,\n        index: AGGREGATION_DATA_UBO_INDEX\n      });\n    }\n  }, {\n    key: \"calculateInstanceCounts\",\n    value: function calculateInstanceCounts(attribute) {\n      var countsBuffer = this.props.countsBuffer;\n      attribute.update({\n        buffer: countsBuffer\n      });\n    }\n  }, {\n    key: \"_setupUniformBuffer\",\n    value: function _setupUniformBuffer(model) {\n      var gl = this.context.gl;\n      var programHandle = model.program.handle;\n      var uniformBlockIndex = gl.getUniformBlockIndex(programHandle, 'AggregationData');\n      gl.uniformBlockBinding(programHandle, uniformBlockIndex, AGGREGATION_DATA_UBO_INDEX);\n    }\n  }]);\n\n  return GPUGridCellLayer;\n}(Layer);\n\nexport { GPUGridCellLayer as default };\nGPUGridCellLayer.layerName = 'GPUGridCellLayer';\nGPUGridCellLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}