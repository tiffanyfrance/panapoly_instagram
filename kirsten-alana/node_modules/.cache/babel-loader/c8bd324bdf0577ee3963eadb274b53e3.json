{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon } from 'h3-js';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { PhongMaterial } from '@luma.gl/core';\nimport { ColumnLayer, SolidPolygonLayer } from '@deck.gl/layers';\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  var hexagonId = getHexagon(object, objectInfo);\n\n  var _h3ToGeo = h3ToGeo(hexagonId),\n      _h3ToGeo2 = _slicedToArray(_h3ToGeo, 2),\n      lat = _h3ToGeo2[0],\n      lng = _h3ToGeo2[1];\n\n  return [lng, lat];\n}\n\nvar defaultProps = {\n  highPrecision: false,\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  extruded: true,\n  fp64: false,\n  getHexagon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.hexagon;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: [255, 0, 255, 255]\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: new PhongMaterial()\n};\n\nvar H3HexagonLayer = function (_CompositeLayer) {\n  _inherits(H3HexagonLayer, _CompositeLayer);\n\n  function H3HexagonLayer() {\n    _classCallCheck(this, H3HexagonLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(H3HexagonLayer).apply(this, arguments));\n  }\n\n  _createClass(H3HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (changeFlags.dataChanged || changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon) {\n        var resolution = -1;\n        var hasPentagon = false;\n\n        var _createIterable = createIterable(props.data),\n            iterable = _createIterable.iterable,\n            objectInfo = _createIterable.objectInfo;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var object = _step.value;\n            objectInfo.index++;\n            var hexId = props.getHexagon(object, objectInfo);\n            resolution = resolution < 0 ? h3GetResolution(hexId) : resolution;\n\n            if (h3IsPentagon(hexId)) {\n              hasPentagon = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        this.setState({\n          resolution: resolution,\n          hasPentagon: hasPentagon,\n          vertices: null\n        });\n      }\n\n      this._updateVertices(this.context.viewport);\n    }\n  }, {\n    key: \"_shouldUseHighPrecision\",\n    value: function _shouldUseHighPrecision() {\n      var _this$state = this.state,\n          resolution = _this$state.resolution,\n          hasPentagon = _this$state.hasPentagon;\n      return this.props.highPrecision || hasPentagon || resolution >= 0 && resolution <= 5;\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(viewport) {\n      if (this._shouldUseHighPrecision()) {\n        return;\n      }\n\n      var _this$state2 = this.state,\n          resolution = _this$state2.resolution,\n          centerHex = _this$state2.centerHex;\n\n      if (resolution < 0) {\n        return;\n      }\n\n      var hex = geoToH3(viewport.latitude, viewport.longitude, resolution);\n\n      if (centerHex === hex) {\n        return;\n      }\n\n      var pixelsPerMeter = viewport.distanceScales.pixelsPerMeter;\n      var vertices = h3ToGeoBoundary(hex, true);\n\n      var _h3ToGeo3 = h3ToGeo(hex),\n          _h3ToGeo4 = _slicedToArray(_h3ToGeo3, 2),\n          centerLat = _h3ToGeo4[0],\n          centerLng = _h3ToGeo4[1];\n\n      var _viewport$projectFlat = viewport.projectFlat([centerLng, centerLat]),\n          _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n          centerX = _viewport$projectFlat2[0],\n          centerY = _viewport$projectFlat2[1];\n\n      vertices = vertices.map(function (p) {\n        var worldPosition = viewport.projectFlat(p);\n        worldPosition[0] = (worldPosition[0] - centerX) / pixelsPerMeter[0];\n        worldPosition[1] = (worldPosition[1] - centerY) / pixelsPerMeter[1];\n        return worldPosition;\n      });\n      this.setState({\n        centerHex: hex,\n        vertices: vertices\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props = this.props,\n          data = _this$props.data,\n          getHexagon = _this$props.getHexagon,\n          updateTriggers = _this$props.updateTriggers,\n          elevationScale = _this$props.elevationScale,\n          extruded = _this$props.extruded,\n          fp64 = _this$props.fp64,\n          getColor = _this$props.getColor,\n          getElevation = _this$props.getElevation,\n          material = _this$props.material;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', SolidPolygonLayer);\n      return new SubLayerClass({\n        filled: true,\n        elevationScale: elevationScale,\n        extruded: extruded,\n        fp64: fp64,\n        getFillColor: getColor,\n        getElevation: getElevation,\n        material: material\n      }, this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getElevation: updateTriggers.getElevation\n        }\n      }), {\n        data: data,\n        getPolygon: function getPolygon(object, objectInfo) {\n          var hexagonId = getHexagon(object, objectInfo);\n          return h3ToGeoBoundary(hexagonId, true);\n        }\n      });\n    }\n  }, {\n    key: \"_renderColumnLayer\",\n    value: function _renderColumnLayer() {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getHexagon = _this$props2.getHexagon,\n          updateTriggers = _this$props2.updateTriggers,\n          coverage = _this$props2.coverage,\n          elevationScale = _this$props2.elevationScale,\n          extruded = _this$props2.extruded,\n          fp64 = _this$props2.fp64,\n          getColor = _this$props2.getColor,\n          getElevation = _this$props2.getElevation,\n          material = _this$props2.material;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n      return new SubLayerClass({\n        coverage: coverage,\n        elevationScale: elevationScale,\n        extruded: extruded,\n        fp64: fp64,\n        getColor: getColor,\n        getElevation: getElevation,\n        material: material\n      }, this.getSubLayerProps({\n        id: 'hexagon-cell',\n        updateTriggers: updateTriggers\n      }), {\n        data: data,\n        diskResolution: 6,\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      });\n    }\n  }]);\n\n  return H3HexagonLayer;\n}(CompositeLayer);\n\nexport { H3HexagonLayer as default };\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';","map":null,"metadata":{},"sourceType":"module"}