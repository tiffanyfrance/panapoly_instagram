(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/process/browser.js":
/*!******************************************************************!*\
  !*** /Users/georgios/loaders.gl/node_modules/process/browser.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../core/src/categories/mesh/mesh-utils.js":
/*!*************************************************!*\
  !*** ../core/src/categories/mesh/mesh-utils.js ***!
  \*************************************************/
/*! exports provided: getMeshSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
function getMeshSize(attributes) {
  let size = 0;
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    if (ArrayBuffer.isView(attribute)) {
      size += attribute.length * attribute.BYTES_PER_ELEMENT;
    }
  }
  return size;
}


/***/ }),

/***/ "../core/src/index.js":
/*!****************************!*\
  !*** ../core/src/index.js ***!
  \****************************/
/*! exports provided: setPathPrefix, getPathPrefix, resolvePath, fetchFile, readFileSync, writeFile, writeFileSync, registerLoaders, parse, parseSync, parseInBatches, parseInBatchesSync, load, loadInBatches, encode, encodeSync, encodeInBatches, save, saveSync, isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isReadableStream, isWritableStream, isArrayBuffer, isBlob, toArrayBuffer, blobToArrayBuffer, toDataView, padTo4Bytes, copyToArray, copyArrayBuffer, flattenToTypedArray, TextDecoder, TextEncoder, getStreamIterator, forEach, concatenateAsyncIterator, lineAsyncIterator, textDecoderAsyncIterator, numberedLineAsyncIterator, createWorker, isBrowser, self, window, global, document, assert, _getMeshSize, createReadStream, parseFile, parseFileSync, loadFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFile", function() { return parseFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFileSync", function() { return parseFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony import */ var _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch/file-aliases.js */ "../core/src/lib/fetch/file-aliases.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__["resolvePath"]; });

/* harmony import */ var _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/fetch/fetch-file */ "../core/src/lib/fetch/fetch-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["fetchFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["readFileSync"]; });

/* harmony import */ var _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/fetch/write-file */ "../core/src/lib/fetch/write-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_2__["writeFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"]; });

/* harmony import */ var _lib_register_loaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/register-loaders */ "../core/src/lib/register-loaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return _lib_register_loaders__WEBPACK_IMPORTED_MODULE_3__["registerLoaders"]; });

/* harmony import */ var _lib_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/parse */ "../core/src/lib/parse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseInBatches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseInBatchesSync"]; });

/* harmony import */ var _lib_load__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/load */ "../core/src/lib/load.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "load", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_5__["load"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_5__["loadInBatches"]; });

/* harmony import */ var _lib_encode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/encode */ "../core/src/lib/encode.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_6__["encode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_6__["encodeSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_6__["encodeInBatches"]; });

/* harmony import */ var _lib_save__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/save */ "../core/src/lib/save.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "save", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_7__["save"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_7__["saveSync"]; });

/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isAsyncIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isFetchResponse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isReadableStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isWritableStream"]; });

/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./javascript-utils/binary-utils */ "../core/src/javascript-utils/binary-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["isArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["isBlob"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["toArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blobToArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["blobToArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDataView", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["toDataView"]; });

/* harmony import */ var _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./javascript-utils/memory-copy-utils */ "../core/src/javascript-utils/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__["copyArrayBuffer"]; });

/* harmony import */ var _javascript_utils_flatten_to_typed_array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./javascript-utils/flatten-to-typed-array */ "../core/src/javascript-utils/flatten-to-typed-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flattenToTypedArray", function() { return _javascript_utils_flatten_to_typed_array__WEBPACK_IMPORTED_MODULE_11__["flattenToTypedArray"]; });

/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./javascript-utils/text-encoding */ "../core/src/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextDecoder", function() { return _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__["TextDecoder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextEncoder", function() { return _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__["TextEncoder"]; });

/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./javascript-utils/stream-utils */ "../core/src/javascript-utils/stream-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_13__["getStreamIterator"]; });

/* harmony import */ var _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./javascript-utils/async-iterator-utils */ "../core/src/javascript-utils/async-iterator-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["concatenateAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["lineAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["textDecoderAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["numberedLineAsyncIterator"]; });

/* harmony import */ var _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./worker-utils/create-worker */ "../core/src/worker-utils/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/globals */ "../core/src/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["document"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/assert */ "../core/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../core/src/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_18__["getMeshSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["createReadStream"]; });

// FILE READING AND WRITING




// FILE PARSING AND ENCODING


// LOADING (READING + PARSING)



// ENCODING AND SAVING



// "JAVASCRIPT" UTILS








// ITERATOR UTILS




// WORKER UTILS


// CORE UTILS



// MESH CATEGORY UTILS


// DEPRECATED





function parseFile(...args) {
  console.warn('parse() deprecated, use parse()'); // eslint-disable-line
  return Object(_lib_parse__WEBPACK_IMPORTED_MODULE_4__["parse"])(...args);
}

function parseFileSync(...args) {
  console.warn('parseSync() deprecated, use parseSync()'); // eslint-disable-line
  return Object(_lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseSync"])(...args);
}

function loadFile(...args) {
  console.warn('loadFile() deprecated, use load()'); // eslint-disable-line
  return Object(_lib_load__WEBPACK_IMPORTED_MODULE_5__["load"])(...args);
}


/***/ }),

/***/ "../core/src/javascript-utils/async-iterator-utils.js":
/*!************************************************************!*\
  !*** ../core/src/javascript-utils/async-iterator-utils.js ***!
  \************************************************************/
/*! exports provided: forEach, concatenateAsyncIterator, textDecoderAsyncIterator, textEncoderAsyncIterator, lineAsyncIterator, numberedLineAsyncIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return concatenateAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return textDecoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textEncoderAsyncIterator", function() { return textEncoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return lineAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return numberedLineAsyncIterator; });
/* harmony import */ var _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/memory-copy-utils */ "../core/src/javascript-utils/memory-copy-utils.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../javascript-utils/text-encoding */ "../core/src/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_1__);



// GENERAL UTILITIES

// Iterate over async iterator, without resetting iterator if end is not reached
// - forEach does not reset iterator if exiting loop prematurely
//   so that iteration can continue in a second loop
// - It is recommended to use a standard for await as last loop to ensure
//   iterator gets properly reset
// TODO - optimize using sync iteration if argument is an Iterable?
async function forEach(iterator, visitor) {
  // eslint-disable-next-line
  while (true) {
    const {done, value} = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}

// Concatenates all data chunks yielded by an async iterator
async function concatenateAsyncIterator(asyncIterator) {
  let arrayBuffer = new ArrayBuffer();
  let string = '';
  for await (const chunk of asyncIterator) {
    if (typeof chunk === 'string') {
      string += chunk;
    } else {
      arrayBuffer = Object(_javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["concatenateArrayBuffers"])(arrayBuffer, chunk);
    }
  }
  return arrayBuffer || string;
}

// ITERATOR GENERATORS

// TextDecoder iterators
// TextDecoder will keep any partial undecoded bytes between calls to `decode`

async function* textDecoderAsyncIterator(arrayBufferIterator, options) {
  const textDecoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_1__["TextDecoder"](options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string'
      ? arrayBuffer
      : textDecoder.decode(arrayBuffer, {stream: true});
  }
}

// TextEncoder iterator
// TODO - this is not useful unless min chunk size is given
// TextEncoder will keep any partial undecoded bytes between calls to `encode`
// If iterator does not yield strings, assume arrayBuffer and return unencoded

async function* textEncoderAsyncIterator(textIterator, options) {
  const textEncoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_1__["TextEncoder"]();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}

// Input: async iterable over strings
// Returns: an async iterable over lines
// See http://2ality.com/2018/04/async-iter-nodejs.html

async function* lineAsyncIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      // line includes the EOL
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}

/**
 * Parameter: async iterable of lines
 * Result: async iterable of numbered lines
 */
// See http://2ality.com/2018/04/async-iter-nodejs.html
// eslint-disable-next-line no-shadow
async function* numberedLineAsyncIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {counter, line};
    counter++;
  }
}


/***/ }),

/***/ "../core/src/javascript-utils/binary-utils.js":
/*!****************************************************!*\
  !*** ../core/src/javascript-utils/binary-utils.js ***!
  \****************************************************/
/*! exports provided: isArrayBuffer, isBlob, isBuffer, toArrayBuffer, blobToArrayBuffer, toDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return isArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return isBlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return isBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blobToArrayBuffer", function() { return blobToArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDataView", function() { return toDataView; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _text_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text-encoding */ "../core/src/javascript-utils/text-encoding.js");
/* harmony import */ var _text_encoding__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_text_encoding__WEBPACK_IMPORTED_MODULE_1__);
/* global FileReader, Blob, ArrayBuffer, Buffer */



const isArrayBuffer = x => x && x instanceof ArrayBuffer;
const isBlob = x => x && typeof Blob !== 'undefined' && x instanceof Blob;
const isBuffer = x => x && x instanceof Buffer;

function toArrayBuffer(data) {
  if (isArrayBuffer(data)) {
    return data;
  }

  // TODO - per docs we should just be able to call buffer.buffer, but there are issues
  if (isBuffer(data)) {
    const typedArray = new Uint8Array(data);
    return typedArray.buffer;
  }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new _text_encoding__WEBPACK_IMPORTED_MODULE_1__["TextEncoder"]().encode(text);
    return uint8Array.buffer;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

function blobToArrayBuffer(blob) {
  return new Promise((resolve, reject) => {
    let arrayBuffer;
    const fileReader = new FileReader();
    fileReader.onload = event => {
      arrayBuffer = event.target.result;
    };
    fileReader.onloadend = event => resolve(arrayBuffer);
    fileReader.onerror = reject;
    fileReader.readAsArrayBuffer(blob);
  });
}

function toDataView(buffer) {
  return new DataView(toArrayBuffer(buffer));
}


/***/ }),

/***/ "../core/src/javascript-utils/flatten-to-typed-array.js":
/*!**************************************************************!*\
  !*** ../core/src/javascript-utils/flatten-to-typed-array.js ***!
  \**************************************************************/
/*! exports provided: flattenToTypedArray, flatten, countVertices, flattenVertices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenToTypedArray", function() { return flattenToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countVertices", function() { return countVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenVertices", function() { return flattenVertices; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function flattenToTypedArray(nestedArray, ArrayType = Float32Array) {
  if (nestedArray.length === 0) {
    return new Float32Array(0);
  }

  if (!checkVertices(nestedArray)) {
    return null;
  }

  const count = countVertices(nestedArray);

  const typedArray = new ArrayType(count);
  flattenVerticesInPlace(nestedArray, typedArray);
  return typedArray;
}

/**
 * Flattens a nested array into a single level array,
 * or a single value into an array with one value
 * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
 * @example flatten(1) => [1]
 * @param {Array} array The array to flatten.
 * @param {Function} filter= - Optional predicate called on each `value` to
 *   determine if it should be included (pushed onto) the resulting array.
 * @param {Function} map= - Optional transform applied to each array elements.
 * @param {Array} result=[] - Optional array to push value into
 * @return {Array} Returns the new flattened array (new array or `result` if provided)
 */
function flatten(array, {filter = () => true, map = x => x, result = []} = {}) {
  // Wrap single object in array
  if (!Array.isArray(array)) {
    return filter(array) ? [map(array)] : [];
  }
  // Deep flatten and filter the array
  return flattenArray(array, filter, map, result);
}

// Deep flattens an array. Helper to `flatten`, see its parameters
function flattenArray(array, filter, map, result) {
  let index = -1;
  while (++index < array.length) {
    const value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, map, result);
    } else if (filter(value)) {
      result.push(map(value));
    }
  }
  return result;
}

function countVertices(nestedArray, dimensions = 3) {
  let nestedCount = 0;
  let localCount = 0;
  let index = -1;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      nestedCount += countVertices(value);
    } else {
      localCount++;
    }
  }
  return nestedCount + (nestedCount === 0 && localCount < dimensions ? dimensions : localCount);
}

// Flattens nested array of vertices, padding third coordinate as needed
function flattenVertices(nestedArray, {result = [], dimensions = 3} = {}) {
  let index = -1;
  let vertexLength = 0;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, {result, dimensions});
    } else {
      // eslint-disable-next-line
      if (vertexLength < dimensions) {
        result.push(value);
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }
  return result;
}

function checkVertices(nestedArray, predicate = Number.isFinite) {
  let index = -1;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (!checkVertices(value, predicate)) {
        return false;
      }
    } else if (!predicate(value)) {
      return false;
    }
  }
  return true;
}

function flattenVerticesInPlace(nestedArray, result, dimensions = 3) {
  flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, 0);
  return result;
}

// Flattens nested array of vertices, padding third coordinate as needed
function flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, insert) {
  let index = -1;
  let vertexLength = 0;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      insert = flattenVerticesInPlaceRecursive(value, result, dimensions, insert);
    } else {
      // eslint-disable-next-line
      if (vertexLength < dimensions) {
        result[insert++] = value;
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result[insert++] = 0;
  }
  return insert;
}


/***/ }),

/***/ "../core/src/javascript-utils/is-type.js":
/*!***********************************************!*\
  !*** ../core/src/javascript-utils/is-type.js ***!
  \***********************************************/
/*! exports provided: isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isWritableDOMStream, isReadableDOMStream, isWritableNodeStream, isReadableNodeStream, isReadableStream, isWritableStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return isAsyncIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return isIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return isFetchResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableDOMStream", function() { return isWritableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableDOMStream", function() { return isReadableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableNodeStream", function() { return isWritableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableNodeStream", function() { return isReadableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return isReadableStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return isWritableStream; });
const isBoolean = x => typeof x === 'boolean';
const isFunction = x => typeof x === 'function';
const isObject = x => x !== null && typeof x === 'object';

const isPromise = x => isObject(x) && isFunction(x.then);

const isIterable = x => x && typeof x[Symbol.iterator] === 'function';

const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';

const isIterator = x => isObject(x) && 'done' in x && 'value' in x;

const isFetchResponse = x =>
  (typeof window !== 'undefined' && x instanceof window.Response) ||
  (x.arrayBuffer && x.json && x.body);

const isWritableDOMStream = x => {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

const isReadableDOMStream = x => {
  return (
    isObject(x) &&
    isFunction(x.tee) &&
    isFunction(x.cancel) &&
    isFunction(x.pipeTo) &&
    isFunction(x.getReader)
  );
};

const isWritableNodeStream = x => {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

const isReadableNodeStream = x => {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);

const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);


/***/ }),

/***/ "../core/src/javascript-utils/memory-copy-utils.js":
/*!*********************************************************!*\
  !*** ../core/src/javascript-utils/memory-copy-utils.js ***!
  \*********************************************************/
/*! exports provided: padTo4Bytes, copyArrayBuffer, copyToArray, concatenateArrayBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
function padTo4Bytes(byteLength) {
  return (byteLength + 3) & ~3;
}

/* Creates a new Uint8Array based on two different ArrayBuffers
 * @private
 * @param {ArrayBuffers} buffer1 The first buffer.
 * @param {ArrayBuffers} buffer2 The second buffer.
 * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
 */
function copyArrayBuffer(
  targetBuffer,
  sourceBuffer,
  byteOffset,
  byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

/**
 * Copy from source to target at the targetOffset
 *
 * @param {ArrayBuffer|TypedArray} source - The data to copy
 * @param {TypedArray} target - The destination to copy data into
 * @param {Number} targetOffset - The start offset into target to place the copied data
 *
 * @return {Number} Returns the new offset taking into account proper padding
 */
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    // Pack buffer onto the big target array
    //
    // 'source.data.buffer' could be a view onto a larger buffer.
    // We MUST use this constructor to ensure the byteOffset and byteLength is
    // set to correct values from 'source.data' and not the underlying
    // buffer for target.set() to work properly.
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  // Pack buffer onto the big target array
  target.set(sourceArray, targetOffset);

  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}

function concatenateArrayBuffers(source1, source2) {
  const sourceArray1 = source1 instanceof ArrayBuffer ? new Uint8Array(source1) : source1;
  const sourceArray2 = source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  const temp = new Uint8Array(sourceArray1.byteLength + sourceArray2.byteLength);
  temp.set(sourceArray1, 0);
  temp.set(sourceArray2, sourceArray1.byteLength);
  return temp;
}


/***/ }),

/***/ "../core/src/javascript-utils/stream-utils.js":
/*!****************************************************!*\
  !*** ../core/src/javascript-utils/stream-utils.js ***!
  \****************************************************/
/*! exports provided: getStreamIterator, concatenateReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return getStreamIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateReadStream", function() { return concatenateReadStream; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memory-copy-utils */ "../core/src/javascript-utils/memory-copy-utils.js");



function getStreamIterator(stream) {
  // NODE 10+: stream is an asyncIterator
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return stream;
  }

  // WhatWG: stream is supposed to have a `getIterator` method
  if (typeof stream.getIterator === 'function') {
    return stream.getIterator();
  }

  return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}

// BROWSER IMPLEMENTATION
// See https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate

async function* makeBrowserStreamIterator(stream) {
  // In the brower, we first need to get a lock on the stream
  const reader = stream.getReader();

  try {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      // Read from the stream
      const {done, value} = await reader.read();
      // Exit if we're done
      if (done) {
        return;
      }
      // Else yield the chunk
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}

// NODE <10 IMPLEMENTATION
// See https://github.com/bustle/streaming-iterables, MIT license

async function* makeNodeStreamIterator(stream) {
  // Node createStream will return promises to handle http requests
  stream = await stream;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    const data = stream.read();
    if (data !== null) {
      yield data;
      // eslint-disable-next-line no-continue
      continue;
    }
    if (stream._readableState.ended) {
      return;
    }
    await onceReadable(stream);
  }
}

async function onceReadable(stream) {
  return new Promise(resolve => {
    stream.once('readable', resolve);
  });
}

// TODO - remove? can this be handled via corresponding AsyncIterator function?
function concatenateReadStream(readStream) {
  let arrayBuffer = new ArrayBuffer();
  let string = '';

  return new Promise((resolve, reject) => {
    readStream.data(chunk => {
      if (typeof chunk === 'string') {
        string += chunk;
      } else {
        arrayBuffer = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_1__["concatenateArrayBuffers"])(arrayBuffer, chunk);
      }
    });
    readStream.on('error', error => reject(error));

    readStream.on('end', () => {
      if (readStream.complete) {
        resolve(arrayBuffer || string);
      } else {
        reject('The connection was terminated while the message was still being sent');
      }
    });
  });
}


/***/ }),

/***/ "../core/src/javascript-utils/text-encoding.js":
/*!*****************************************************!*\
  !*** ../core/src/javascript-utils/text-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* global TextEncoder,TextDecoder */
if (typeof TextDecoder === 'undefined') {
  module.exports = {};
} else {
  module.exports = {TextEncoder, TextDecoder};
}


/***/ }),

/***/ "../core/src/lib/encode.js":
/*!*********************************!*\
  !*** ../core/src/lib/encode.js ***!
  \*********************************/
/*! exports provided: encode, encodeSync, encodeInBatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return encodeSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return encodeInBatches; });
function encode(data, writer, options, url) {
  if (writer.encode) {
    return writer.encode(data, options);
  }
  if (writer.encodeSync) {
    return Promise.resolve(writer.encodeSync(data, options));
  }
  // TODO - Use encodeToBatches?
  throw new Error('Writer could not encode data');
}

function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error('Writer could not synchronously encode data');
}

function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    return writer.encodeInBatches(data, options);
  }
  // TODO -fall back to atomic encode?
  throw new Error('Writer could not encode data in batches');
}


/***/ }),

/***/ "../core/src/lib/fetch/fetch-file-browser.js":
/*!***************************************************!*\
  !*** ../core/src/lib/fetch/fetch-file-browser.js ***!
  \***************************************************/
/*! exports provided: fetchFile, readFileSync, createReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
/* global fetch */


const DEFAULT_OPTIONS = {
  dataType: 'arrayBuffer',
  // TODO - this was mostly set to true to make test cases work
  nothrow: true
};

const isDataURL = url => url.startsWith('data:');
// const isFileURL = url => typeof File !== 'undefined' && url instanceof File;

// Returns a promise that resolves to a response object
async function fetchFile(url, options) {
  return await fetch(url, options);

  // TODO - SUPPORT reading from `File` objects
  // if (typeof File !== 'undefined' && uri instanceof File) {
  //   readFileObject(uri, options);
  // }
}

// In a few cases (data URIs, files under Node) "files" can be read synchronously
function readFileSync(uri, options = {}) {
  options = getReadFileOptions(options);

  if (isDataURL(uri)) {
    // TODO - removed until decodeDataUri does not depend on Node.js Buffer
    //   return decodeDataUri(uri);
  }

  if (!options.nothrow) {
    // throw new Error('Cant load URI synchronously');
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }

  return null;
}

// DEPRECATED

// Creates a readable stream to
// * http/http urls
// * data urls
// TODO - does not support opening a stream on a `File` objects
async function createReadStream(url, options) {
  return fetch(url, options).then(res => res.body);
}

// HELPER FUNCTIONS

function getReadFileOptions(options = {}) {
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;
  return options;
}

/**
 * File reader function for the browser
 * @param {File|Blob} file  HTML File or Blob object to read as string
 * @returns {Promise.string}  Resolves to a string containing file contents
/* global File, FileReader
function readFileObject(file, options) {
  return new Promise((resolve, reject) => {
    try {
      const reader = new FileReader();
      reader.onerror = error => reject(new Error(error));
      reader.onabort = () => reject(new Error('Read aborted.'));
      reader.onload = () => resolve(reader.result);
      if (options.dataType !== 'arraybuffer') {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    } catch (error) {
      reject(error);
    }
  });
}
*/

/* Reads raw file data from:
// * http/http urls
// * data urls
// * File/Blob objects
// etc?
async function readFile(uri, options = {}) {
  options = getReadFileOptions(options);

  // NOTE: data URLs are decoded by fetch

  // SUPPORT reading from `File` objects
  if (typeof File !== 'undefined' && uri instanceof File) {
    readFileObject(uri, options);
  }

  // In a web worker, XMLHttpRequest throws invalid URL error if using relative path
  // resolve url relative to original base
  // TODO - merge this into `resolvePath?
  uri = new URL(uri, location.href).href;

  // Browser: Try to load all URLS via fetch, as they can be local requests (e.g. to a dev server)
  const response = await fetch(uri, options);
  return response[options.dataType]();
}
*/


/***/ }),

/***/ "../core/src/lib/fetch/fetch-file.js":
/*!*******************************************!*\
  !*** ../core/src/lib/fetch/fetch-file.js ***!
  \*******************************************/
/*! exports provided: fetchFile, readFileSync, createReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node/fetch/fetch-file-node */ 1);
/* harmony import */ var _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch-file-browser */ "../core/src/lib/fetch/fetch-file-browser.js");
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./file-aliases */ "../core/src/lib/fetch/file-aliases.js");


// fetch-file-node is excluded from build under browser so don't do indivdual imports


// Import individual symbols for browser version to ensure tree-shaking is enabled




// Reads raw file data from:
// * http/http urls
// * data urls
// * File/Blob objects
// etc?
async function fetchFile(url, options) {
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(url);
  const func = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? _fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["fetchFile"] : _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_1__["fetchFile"];
  return func(url, options);
}

// In a few cases (data URIs, node.js) "files" can be read synchronously
function readFileSync(url, options = {}) {
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(url);
  const func = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? _fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["readFileSync"] : _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_1__["readFileSync"];
  return func(url, options);
}

// DEPRECATED

// Returns a promise that resolves to a readable stream
async function createReadStream(url, options) {
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_3__["resolvePath"])(url);
  const func = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? _fetch_file_browser__WEBPACK_IMPORTED_MODULE_2__["createReadStream"] : _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_1__["createReadStream"];
  return func(url, options);
}


/***/ }),

/***/ "../core/src/lib/fetch/file-aliases.js":
/*!*********************************************!*\
  !*** ../core/src/lib/fetch/file-aliases.js ***!
  \*********************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
// Simple file alias mechanisms for tests.

let pathPrefix = '';
const fileAliases = {};

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

// Note: addAliases are not exported at the moment, they are only for loaders.gl testing
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      return filename.replace(alias, replacement);
    }
  }
  filename += pathPrefix;
  return filename;
}


/***/ }),

/***/ "../core/src/lib/fetch/write-file.js":
/*!*******************************************!*\
  !*** ../core/src/lib/fetch/write-file.js ***!
  \*******************************************/
/*! exports provided: writeFile, writeFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return writeFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return writeFileSync; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../core/src/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node/fetch/write-file-node */ 2);
/* harmony import */ var _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__);




function writeFile(filePath, arrayBufferOrString, options) {
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFile"](filePath, arrayBufferOrString, options);
  }
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"](filePath, arrayBufferOrString, options);
  }
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}


/***/ }),

/***/ "../core/src/lib/load.js":
/*!*******************************!*\
  !*** ../core/src/lib/load.js ***!
  \*******************************/
/*! exports provided: loadInBatches, load */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return loadInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony import */ var _fetch_fetch_file__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fetch/fetch-file */ "../core/src/lib/fetch/fetch-file.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/auto-detect-loader */ "../core/src/lib/loader-utils/auto-detect-loader.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse */ "../core/src/lib/parse.js");
/* harmony import */ var _register_loaders__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./register-loaders */ "../core/src/lib/register-loaders.js");







async function loadInBatches(url, loaders, options) {
  const response = await Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_0__["fetchFile"])(url, options);
  return Object(_parse__WEBPACK_IMPORTED_MODULE_3__["parseInBatches"])(response, loaders, options, url);
}

async function load(url, loaders, options) {
  // Signature: load(url, options)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    options = loaders;
    loaders = null;
  }

  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_4__["getRegisteredLoaders"])();
  const loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__["autoDetectLoader"])(url, null, loaders) : loaders;

  // Some loaders can not separate reading and parsing of data (e.g ImageLoader)
  if (loader && loader.loadAndParse) {
    return await loader.loadAndParse(url, options);
  }

  // at this point, data can be binary or text
  const response = await Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_0__["fetchFile"])(url, options);
  return Object(_parse__WEBPACK_IMPORTED_MODULE_3__["parse"])(response, loaders, options, url);
}


/***/ }),

/***/ "../core/src/lib/loader-utils/auto-detect-loader.js":
/*!**********************************************************!*\
  !*** ../core/src/lib/loader-utils/auto-detect-loader.js ***!
  \**********************************************************/
/*! exports provided: autoDetectLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoDetectLoader", function() { return autoDetectLoader; });
/* harmony import */ var _normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");


const EXT_PATTERN = /[^\.]+$/;

// Find a loader that works for extension/text
// Search the loaders array argument for a loader that matches extension or text
function autoDetectLoader(url = '', text, loaders) {
  // Get extension
  // TODO - Would be nice to support http://example.com/file.glb?parameter=1
  // E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname
  const match = url.match(EXT_PATTERN);
  if (match && match[0]) {
    const extension = match[0];
    const loader = findLoaderByExtension(loaders, extension);
    if (loader) {
      return loader;
    }
  }

  const loader = findLoaderByExamingInitialData(loaders, text);
  if (loader) {
    return loader;
  }

  return null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  for (const loader of loaders) {
    Object(_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["normalizeLoader"])(loader);
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}

function findLoaderByExamingInitialData(loaders, text) {
  for (const loader of loaders) {
    if (loader.testText && loader.testText(text)) {
      return loader;
    }
  }
  return null;
}


/***/ }),

/***/ "../core/src/lib/loader-utils/get-data.js":
/*!************************************************!*\
  !*** ../core/src/lib/loader-utils/get-data.js ***!
  \************************************************/
/*! exports provided: getUrlFromData, getSizeFromData, getArrayBufferOrStringFromDataSync, getArrayBufferOrStringFromData, getAsyncIteratorFromData, getIteratorFromData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlFromData", function() { return getUrlFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeFromData", function() { return getSizeFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromDataSync", function() { return getArrayBufferOrStringFromDataSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromData", function() { return getArrayBufferOrStringFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncIteratorFromData", function() { return getAsyncIteratorFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIteratorFromData", function() { return getIteratorFromData; });
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../javascript-utils/is-type */ "../core/src/javascript-utils/is-type.js");
/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../javascript-utils/stream-utils */ "../core/src/javascript-utils/stream-utils.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../javascript-utils/text-encoding */ "../core/src/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_2__);




const ERR_DATA = 'Cannot convert supplied data type';

function getUrlFromData(data) {
  return Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data) ? data.url : null;
}

function getSizeFromData(data) {
  return Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data) ? data.headers.get('Content-Length') : null;
}
function getArrayBufferOrStringFromDataSync(data, loader) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    const arrayBuffer = data.buffer || data;
    if (loader.text && !loader.binary) {
      const textDecoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_2__["TextDecoder"]('utf8');
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

// Convert async iterator to a promise
async function getArrayBufferOrStringFromData(data, loader) {
  // Resolve any promise
  data = await data;

  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data)) {
    return loader.binary ? await data.arrayBuffer() : data.text();
  }

  // if (isIterable(data) || isAsyncIterable(data)) {
  // }

  // Assume arrayBuffer iterator - attempt to concatenate
  // return concatenateAsyncIterator(data);

  throw new Error(ERR_DATA);
}

async function getAsyncIteratorFromData(data, loader) {
  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterator"])(data)) {
    return data;
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isFetchResponse"])(data)) {
    return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__["getStreamIterator"])(data.body);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isReadableStream"])(data)) {
    return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_1__["getStreamIterator"])(data);
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isAsyncIterable"])(data)) {
    return data[Symbol.asyncIterator]();
  }

  return getIteratorFromData(data, loader);
}

async function getIteratorFromData(data, loader) {
  // generate an iterator that emits a single chunk
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return (function* oneChunk() {
      yield data.buffer || data;
    })();
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterator"])(data)) {
    return data;
  }

  if (Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_0__["isIterable"])(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}


/***/ }),

/***/ "../core/src/lib/loader-utils/normalize-loader.js":
/*!********************************************************!*\
  !*** ../core/src/lib/loader-utils/normalize-loader.js ***!
  \********************************************************/
/*! exports provided: isLoaderObject, normalizeLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLoaderObject", function() { return isLoaderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeLoader", function() { return normalizeLoader; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/assert */ "../core/src/utils/assert.js");


function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  const hasParser =
    loader.parseTextSync ||
    loader.parseSync ||
    loader.parse ||
    loader.loadAndParse ||
    loader.parseStream || // TODO Replace with parseInBatches
    loader.parseInBatches ||
    // loader.parseInBatchesSync || // Optimization only, parseInBatches needed
    loader.worker;

  return hasParser;
}

function normalizeLoader(loader) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(isLoaderObject(loader));

  // NORMALIZE [LOADER, OPTIONS] => LOADER

  // If [loader, options], create a new loaders object with options merged in
  let options;
  if (Array.isArray(loader)) {
    loader = loader[0];
    options = loader[1];
    loader = {
      ...loader,
      options: {...loader.options, options}
    };
  }

  // NORMALIZE LOADER.EXTENSIONS

  // Remove `extension`` prop, replace with `extensions``
  if (loader.extension) {
    loader.extensions = loader.extensions || [loader.extension];
    delete loader.extension;
  }

  // Ensure loader.extensions is an array
  if (!Array.isArray(loader.extensions)) {
    loader.extensions = [loader.extensions];
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);

  // NORMALIZE text and binary flags

  // Ensure at least one of text/binary flags are properly set
  if (loader.parseTextSync) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}


/***/ }),

/***/ "../core/src/lib/loader-utils/null-log.js":
/*!************************************************!*\
  !*** ../core/src/lib/loader-utils/null-log.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NullLog; });
class NullLog {
  log() {}
  info() {}
  warn() {}
  error() {}
}


/***/ }),

/***/ "../core/src/lib/parse-with-loader.js":
/*!********************************************!*\
  !*** ../core/src/lib/parse-with-loader.js ***!
  \********************************************/
/*! exports provided: parseWithLoader, parseWithLoaderSync, parseWithLoaderInBatches, parseWithLoaderInBatchesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoader", function() { return parseWithLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoaderSync", function() { return parseWithLoaderSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoaderInBatches", function() { return parseWithLoaderInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoaderInBatchesSync", function() { return parseWithLoaderInBatchesSync; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../core/src/utils/assert.js");
/* harmony import */ var _parse_with_worker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-with-worker */ "../core/src/lib/parse-with-worker.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/get-data */ "../core/src/lib/loader-utils/get-data.js");




// TODO: support progress and abort
// TODO: support moving loading to worker
// TODO - should accept loader.parseAsyncIterator and concatenate.
async function parseWithLoader(data, loader, options = {}, url) {
  url = url || Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getUrlFromData"])(data);
  data = await Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getArrayBufferOrStringFromData"])(data, loader);

  // First check for synchronous text parser, wrap results in promises
  if (loader.parseTextSync && typeof data === 'string') {
    options.dataType = 'text';
    return loader.parseTextSync(data, options, url, loader);
  }

  // Now check for synchronous binary data parser, wrap results in promises
  if (loader.parseSync) {
    return loader.parseSync(data, options, url, loader);
  }

  // Check for asynchronous parser
  if (loader.parse) {
    return await loader.parse(data, options, url, loader);
  }

  if (loader.worker) {
    return await Object(_parse_with_worker__WEBPACK_IMPORTED_MODULE_1__["default"])(loader.worker, data, options);
  }

  // TBD - If asynchronous parser not available, return null
  // => This loader does not work on loaded data and only supports `loadAndParseAsync`
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator
function parseWithLoaderSync(data, loader, options = {}, url) {
  data = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getArrayBufferOrStringFromDataSync"])(data, loader);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options, url, loader);
  }

  if (loader.parseSync) {
    return loader.parseSync(data, options, url, loader);
  }

  // TBD - If synchronous parser not available, return null
  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);
  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

async function parseWithLoaderInBatches(data, loader, options = {}, url) {
  // Create async iterator adapter for data, and concatenate result
  if (loader.parseInBatches) {
    const inputIterator = await Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getAsyncIteratorFromData"])(data);
    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);
    return outputIterator;
  }

  // TODO - update after test cases have been fixed
  return null;
}

async function parseWithLoaderInBatchesSync(data, loader, options = {}, url) {
  // Create async iterator adapter for data, and concatenate result
  if (loader.parseInBatchesSync) {
    const inputIterator = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_2__["getIteratorFromData"])(data);
    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);
    return outputIterator;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}


/***/ }),

/***/ "../core/src/lib/parse-with-worker.js":
/*!********************************************!*\
  !*** ../core/src/lib/parse-with-worker.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseWithWorker; });
/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/binary-utils */ "../core/src/javascript-utils/binary-utils.js");


const workerCache = new Map();

/* global Worker, Blob, URL */
function getWorker(workerSource) {
  let workerURL = workerCache.get(workerSource);
  if (!workerURL) {
    const blob = new Blob([workerSource], {type: 'application/javascript'});
    workerURL = URL.createObjectURL(blob);
    workerCache.set(workerSource, workerURL);
  }
  return new Worker(workerURL);
}

function parseWithWorker(workerSource, data, options) {
  const worker = getWorker(workerSource);

  options = removeNontransferableOptions(options);

  const parse = (rawData, opts) =>
    new Promise((resolve, reject) => {
      worker.onmessage = evt => {
        switch (evt.data.type) {
          case 'done':
            resolve(evt.data.result);
            worker.terminate();
            break;

          case 'error':
            reject(new Error(evt.data.message));
            break;

          default:
        }
      };

      const arraybuffer = Object(_javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"])(rawData);
      worker.postMessage({arraybuffer, opts}, [arraybuffer]);
    });

  return data ? parse(data, options) : parse;
}

function removeNontransferableOptions(options) {
  options = Object.assign({}, options);
  // log object contains functions which cannot be transferred
  // TODO - decide how to handle logging on workers
  if (options.log !== null) {
    delete options.log;
  }
  return options;
}


/***/ }),

/***/ "../core/src/lib/parse.js":
/*!********************************!*\
  !*** ../core/src/lib/parse.js ***!
  \********************************/
/*! exports provided: parse, parseSync, parseInBatches, parseInBatchesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return parseSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return parseInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return parseInBatchesSync; });
/* harmony import */ var _loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/auto-detect-loader */ "../core/src/lib/loader-utils/auto-detect-loader.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_null_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/null-log */ "../core/src/lib/loader-utils/null-log.js");
/* harmony import */ var _register_loaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./register-loaders */ "../core/src/lib/register-loaders.js");
/* harmony import */ var _parse_with_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse-with-loader */ "../core/src/lib/parse-with-loader.js");






async function parse(data, loaders, options, url) {
  // Signature: parse(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_3__["getRegisteredLoaders"])();
  const loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_0__["autoDetectLoader"])(url, data, loaders) : loaders;
  if (!loader) {
    // no loader available
    // TODO: throw error?
    return null;
  }

  Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);

  // Normalize options
  options = mergeLoaderAndUserOptions(options, loader);

  return await Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_4__["parseWithLoader"])(data, loader, options, url);
}

function parseSync(data, loaders, options, url) {
  // Signature: parseSync(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Choose loader and normalize it
  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_3__["getRegisteredLoaders"])();
  const loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_0__["autoDetectLoader"])(url, data, loaders) : loaders;
  Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);

  // Normalize options
  options = mergeLoaderAndUserOptions(options, loader);

  return Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_4__["parseWithLoaderSync"])(data, loader, options, url);
}

async function parseInBatches(data, loaders, options, url) {
  // Signature: parseInBatches(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Choose loader and normalize it
  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_3__["getRegisteredLoaders"])();
  const loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_0__["autoDetectLoader"])(url, null, loaders) : loaders;
  Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);

  // Normalize options
  options = mergeLoaderAndUserOptions(options, loader);

  return Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_4__["parseWithLoaderInBatches"])(data, loader, options, url);
}

async function parseInBatchesSync(data, loaders, options, url) {
  // Signature: parseInBatchesSync(data, options, url)
  // Uses registered loaders
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  // Choose loader and normalize it
  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_3__["getRegisteredLoaders"])();
  const loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_0__["autoDetectLoader"])(url, null, loaders) : loaders;
  Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_1__["normalizeLoader"])(loader);

  // Normalize options
  options = mergeLoaderAndUserOptions(options, loader);

  return Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_4__["parseWithLoaderInBatches"])(data, loader, options, url);
}

function mergeLoaderAndUserOptions(options, loader) {
  // TODO - explain why this optionb is needed for parsing
  options = Object.assign({}, loader.DEFAULT_OPTIONS, loader.options, options, {
    dataType: 'arraybuffer'
  });

  // LOGGING

  // options.log can be set to `null` to defeat logging
  if (options.log === null) {
    options.log = new _loader_utils_null_log__WEBPACK_IMPORTED_MODULE_2__["default"]();
  }
  // log defaults to console
  if (!('log' in options)) {
    /* global console */
    options.log = console;
  }

  return options;
}


/***/ }),

/***/ "../core/src/lib/register-loaders.js":
/*!*******************************************!*\
  !*** ../core/src/lib/register-loaders.js ***!
  \*******************************************/
/*! exports provided: registerLoaders, getRegisteredLoaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return registerLoaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegisteredLoaders", function() { return getRegisteredLoaders; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../core/src/lib/loader-utils/normalize-loader.js");


const registeredLoaders = {};

function registerLoaders(loaders) {
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  for (const loader of loaders) {
    Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["normalizeLoader"])(loader);
    for (const extension of loader.extensions) {
      registeredLoaders[extension] = loader;
    }
  }
}

function getRegisteredLoaders() {
  return Object.values(registeredLoaders);
}


/***/ }),

/***/ "../core/src/lib/save.js":
/*!*******************************!*\
  !*** ../core/src/lib/save.js ***!
  \*******************************/
/*! exports provided: save, saveSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return saveSync; });
/* harmony import */ var _encode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode */ "../core/src/lib/encode.js");
/* harmony import */ var _fetch_write_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch/write-file */ "../core/src/lib/fetch/write-file.js");



function save(data, url, writer) {
  const encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encode"])(data, writer, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFile"])(url, encodedData);
}

function saveSync(data, url, writer) {
  const encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encodeSync"])(data, writer, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"])(url, encodedData);
}


/***/ }),

/***/ "../core/src/utils/assert.js":
/*!***********************************!*\
  !*** ../core/src/utils/assert.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../core/src/utils/globals.js":
/*!************************************!*\
  !*** ../core/src/utils/globals.js ***!
  \************************************/
/*! exports provided: isBrowser, self, window, global, document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* global process, window, global, document */
const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

/* global self, window, global, document */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../core/src/worker-utils/create-worker.js":
/*!*************************************************!*\
  !*** ../core/src/worker-utils/create-worker.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-transfer-list */ "../core/src/worker-utils/get-transfer-list.js");
/* global TextDecoder, self */


// Set up a WebWorkerGlobalScope to talk with the main thread
function createWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  self.onmessage = evt => {
    const {arraybuffer, opts} = evt.data;
    try {
      let data;
      let parser;
      if (loader.parseSync) {
        data = arraybuffer;
        parser = loader.parseSync;
      } else if (loader.parseTextSync) {
        const textDecoder = new TextDecoder();
        data = textDecoder.decode(arraybuffer);
        parser = loader.parseTextSync;
      } else {
        throw new Error(`Could not load data with ${loader.name} loader`);
      }

      const result = parser(data, opts);
      const transferList = Object(_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["default"])(result);

      self.postMessage({type: 'done', result}, transferList);
    } catch (error) {
      self.postMessage({type: 'error', message: error.message});
    }
  };
}


/***/ }),

/***/ "../core/src/worker-utils/get-transfer-list.js":
/*!*****************************************************!*\
  !*** ../core/src/worker-utils/get-transfer-list.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getTransferList; });
// Returns an array of Transferrable objects that can be used with
// postMessage: https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
function getTransferList(object, recursive = true, transfers) {
  // Make sure that items in the transfer list is unique
  const transfersSet = transfers || new Set();

  if (!object) {
    // ignore
  } else if (object instanceof ArrayBuffer) {
    transfersSet.add(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    // Typed array
    transfersSet.add(object.buffer);
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  // If transfers is defined, is internal recursive call
  // Otherwise it's called by the user
  return transfers === undefined ? Array.from(transfersSet) : null;
}


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");

const _global = typeof window === 'undefined' ? global : window;
_global.loaders = _global.loaders || {};

module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/image-loader.js":
/*!*****************************!*\
  !*** ./src/image-loader.js ***!
  \*****************************/
/*! exports provided: default, ImageBitmapLoader, HTMLImageLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return HTMLImageLoader; });
/* harmony import */ var _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-image */ "./src/lib/parse-image.js");


// Loads a platform-specific image type that can be used as input data to WebGL textures
/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extension: [],
  parse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["canParseImage"] && _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["parseImage"],
  loadAndParse: !_lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["canParseImage"] && _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["loadImage"]
});

// EXPERIMENTAL

// Specifically loads an ImageBitmap (works on newer browsers, on both main and worker threads)
const ImageBitmapLoader = {
  parse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["parseToImageBitmap"]
};

// Specifically loads an HTMLImage (works on all browsers' main thread but not on worker threads)
const HTMLImageLoader = {
  loadAndParse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["loadToHTMLImage"]
};


/***/ }),

/***/ "./src/image-writer.js":
/*!*****************************!*\
  !*** ./src/image-writer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-image */ "./src/lib/encode-image.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extensions: ['jpeg'],
  encode: _lib_encode_image__WEBPACK_IMPORTED_MODULE_0__["encodeImage"],
  DEFAULT_OPTIONS: {
    type: 'png'
  }
});


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ImageLoader, HTMLImageLoader, ImageBitmapLoader, ImageWriter, loadImage, isImage, getImageMetadata, decodeImage, getImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _image_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-loader */ "./src/image-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["HTMLImageLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["ImageBitmapLoader"]; });

/* harmony import */ var _image_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image-writer */ "./src/image-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return _image_writer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_parse_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/parse-image */ "./src/lib/parse-image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _lib_parse_image__WEBPACK_IMPORTED_MODULE_2__["loadImage"]; });

/* harmony import */ var _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/get-image-metadata */ "./src/lib/get-image-metadata.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["isImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageMetadata", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageMetadata"]; });

/* harmony import */ var _lib_image_utils_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/image-utils-browser */ "./src/lib/image-utils-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodeImage", function() { return _lib_image_utils_browser__WEBPACK_IMPORTED_MODULE_4__["decodeImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageSize"]; });






// UTILS


// Experimental


// Deprecated



/***/ }),

/***/ "./src/lib/encode-image.js":
/*!*********************************!*\
  !*** ./src/lib/encode-image.js ***!
  \*********************************/
/*! exports provided: encodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImage", function() { return encodeImage; });
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/core */ "../core/src/index.js");
/* harmony import */ var _node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/encode-image-node */ 3);
/* harmony import */ var _node_encode_image_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__);
// Image loading/saving for browser
/* global document, HTMLCanvasElement, Image */




/*
 * Returns data bytes representing a compressed image in PNG or JPG format,
 * This data can be saved using file system (f) methods or
 * used in a request.
 * @param {Image}  image - Image or Canvas
 * @param {String} opt.type='png' - png, jpg or image/png, image/jpg are valid
 * @param {String} opt.dataURI= - Whether to include a data URI header
 */
function encodeImage(image, type) {
  if (_node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__["encodeImageNode"]) {
    return Object(_node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__["encodeImageNode"])(image, type);
  }

  if (image instanceof HTMLCanvasElement) {
    const canvas = image;
    return canvas.toDataURL(type);
  }

  Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__["assert"])(image instanceof Image, 'getImageData accepts image or canvas');
  const canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext('2d').drawImage(image, 0, 0);

  // Get raw image data
  const data = canvas.toDataURL(type || 'png').replace(/^data:image\/(png|jpg);base64,/, '');
  return Promise.resolve(data);
}


/***/ }),

/***/ "./src/lib/get-image-metadata.js":
/*!***************************************!*\
  !*** ./src/lib/get-image-metadata.js ***!
  \***************************************/
/*! exports provided: isImage, getImageMetadata, getImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return isImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageMetadata", function() { return getImageMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return getImageSize; });
/* harmony import */ var _node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer-to-array-buffer */ 4);
/* harmony import */ var _node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_0__);
// Attributions
// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng

// Quarantine references to Buffer to prevent bundler from adding big polyfills


const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;

const mimeTypeMap = new Map([
  ['image/png', getPngSize],
  ['image/jpeg', getJpegSize],
  ['image/gif', getGifSize],
  ['image/bmp', getBmpSize]
]);

const ERR_INVALID_TYPE = `Invalid MIME type. Supported MIME types are: ${Array.from(
  mimeTypeMap.keys()
).join(', ')}`;

/**
 * Sniffs the contents of a file to attempt to deduce the image type and extract image type.
 * Supported image types are PNG, JPEG, GIF and BMP.
 */
function isImage(arrayBuffer) {
  const result = guessImageMetadata(arrayBuffer);
  return result ? result.mimeType : false;
}

/**
 * Sniffs the contents of a file to attempt to deduce the image type and size.
 * Supported image types are PNG, JPEG, GIF and BMP.
 * @param {ArrayBuffer} arrayBuffer
 * @param {string} [mimeType]
 */
function getImageMetadata(arrayBuffer, mimeType = null) {
  // Looking for only a specific MIME type.
  if (mimeType) {
    const handler = mimeTypeMap.get(mimeType);
    if (!handler) {
      throw new Error(ERR_INVALID_TYPE);
    }

    const result = handler(arrayBuffer);
    if (!result) {
      throw new Error(`invalid image data for type: ${mimeType}`);
    }
    return result;
  }

  const result = guessImageMetadata(arrayBuffer, mimeType);
  if (!result) {
    // Seems not :(
    throw new Error(ERR_INVALID_TYPE);
  }
  return result;
}

function guessImageMetadata(arrayBuffer, mimeType) {
  // Loop through each file type and see if they work.
  for (const [supportedMimeType, handler] of mimeTypeMap.entries()) {
    const result = handler(arrayBuffer);
    if (result) {
      result.mimeType = supportedMimeType;
      return result;
    }
  }

  return null;
}

/**
 * Extract size from a binary PNG file
 * @param {Buffer} contents
 */
function getPngSize(arrayBuffer) {
  const dataView = toDataView(arrayBuffer);

  // Check file contains the first 4 bytes of the PNG signature.
  if (dataView.byteLength < 24 || dataView.getUint32(0, BIG_ENDIAN) !== 0x89504e47) {
    return null;
  }

  return {
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

/**
 * Extract size from a binary GIF file
 * @param {Buffer} contents
 * TODO: GIF is not this simple
 */
function getGifSize(arrayBuffer) {
  const dataView = toDataView(arrayBuffer);

  // Check first 4 bytes of the GIF signature ("GIF8").
  if (dataView.byteLength < 10 || dataView.getUint32(0, BIG_ENDIAN) !== 0x47494638) {
    return null;
  }

  // GIF is little endian.
  return {
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

/**
 * @param {Buffer} contents
 * TODO: BMP is not this simple
 */
function getBmpSize(arrayBuffer) {
  const dataView = toDataView(arrayBuffer);

  // Check magic number is valid (first 2 characters should be "BM").
  if (dataView.getUint16(0, BIG_ENDIAN) !== 0x424d) {
    return null;
  }

  // BMP is little endian.
  return {
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

/**
 * Extract size from a binary JPEG file
 * @param {Buffer} contents
 */
function getJpegSize(arrayBuffer) {
  const dataView = toDataView(arrayBuffer);

  // Check file contains the JPEG "start of image" (SOI) marker.
  if (dataView.byteLength < 2 || dataView.getUint16(0, BIG_ENDIAN) !== 0xffd8) {
    return null;
  }

  const {tableMarkers, sofMarkers} = getJpegMarkers();

  // Exclude the two byte SOI marker.
  let i = 2;
  while (i < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);

    // The frame that contains the width and height of the JPEG image.
    if (sofMarkers.has(marker)) {
      return {
        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines
        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line
      };
    }

    // Miscellaneous tables/data preceding the frame header.
    if (!tableMarkers.has(marker)) {
      return null;
    }

    // Length includes size of length parameter but not the two byte header.
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  // Tables/misc header markers.
  // DQT, DHT, DAC, DRI, COM, APP_n
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  // SOF markers and DHP marker.
  // These markers are after tables/misc data.
  const sofMarkers = new Set([
    0xffc0,
    0xffc1,
    0xffc2,
    0xffc3,
    0xffc5,
    0xffc6,
    0xffc7,
    0xffc9,
    0xffca,
    0xffcb,
    0xffcd,
    0xffce,
    0xffcf,
    0xffde
  ]);

  return {tableMarkers, sofMarkers};
}

function toDataView(data) {
  if (_node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_0__["bufferToArrayBuffer"]) {
    data = Object(_node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_0__["bufferToArrayBuffer"])(data);
  }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return new DataView(data.buffer || data);
  }

  throw new Error('toDataView');
}

// DEPRECEATED

function getImageSize(arrayBuffer, mimeType = null) {
  return getImageMetadata(arrayBuffer);
}


/***/ }),

/***/ "./src/lib/image-utils-browser.js":
/*!****************************************!*\
  !*** ./src/lib/image-utils-browser.js ***!
  \****************************************/
/*! exports provided: decodeImage, getImagePixelData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeImage", function() { return decodeImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImagePixelData", function() { return getImagePixelData; });
// TODO - currently only work in browser, great if could work on all platform image types
/* global document */

// Unpacks compressed image data into an HTML image
function decodeImage(arrayBufferOrView, {mimeType = 'image/jpeg'}) {
  /* global window, Blob, Image */
  const blob = new Blob([arrayBufferOrView], {type: mimeType});
  const urlCreator = window.URL || window.webkitURL;
  const imageUrl = urlCreator.createObjectURL(blob);

  return new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => resolve(image);
    image.onerror = reject;
    image.src = imageUrl;
    return image;
  });
}

// Get (uncompressed) image pixel data
function getImagePixelData(image, width = null, height = null) {
  width = width || image.width;
  height = height || image.height;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0, width, height);
  return ctx.getImageData(0, 0, width, height);
}


/***/ }),

/***/ "./src/lib/parse-image.js":
/*!********************************!*\
  !*** ./src/lib/parse-image.js ***!
  \********************************/
/*! exports provided: canParseImage, parseImage, loadImage, parseToImageBitmap, loadToHTMLImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParseImage", function() { return canParseImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseImage", function() { return parseImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseToImageBitmap", function() { return parseToImageBitmap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadToHTMLImage", function() { return loadToHTMLImage; });
/* harmony import */ var _node_parse_image_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/parse-image-node */ 0);
/* harmony import */ var _node_parse_image_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_parse_image_node__WEBPACK_IMPORTED_MODULE_0__);
/* global Image, Blob, createImageBitmap, btoa, fetch */


const canParseImage = _node_parse_image_node__WEBPACK_IMPORTED_MODULE_0__["parseImageNode"] || typeof ImageBitmap !== 'undefined';

// Parse to platform defined type (ndarray on node, ImageBitmap on browser)
function parseImage(arrayBuffer, options) {
  if (_node_parse_image_node__WEBPACK_IMPORTED_MODULE_0__["parseImageNode"]) {
    return Object(_node_parse_image_node__WEBPACK_IMPORTED_MODULE_0__["parseImageNode"])(arrayBuffer, options);
  }

  return parseToImageBitmap(arrayBuffer);
}

// Fallback for older browsers
// TODO - investigate Image.decode()
// https://medium.com/dailyjs/image-loading-with-image-decode-b03652e7d2d2
async function loadImage(url, options) {
  if (typeof Image === 'undefined') {
    const response = await fetch(url, options);
    const arrayBuffer = await response.arrayBuffer();
    return parseImage(arrayBuffer);
  }
  return await loadToHTMLImage(url, options);
}

// Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data
// Supported on worker threads
// Not supported on Edge and Safari
// https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility
function parseToImageBitmap(arrayBuffer) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  const blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}

//
async function loadToHTMLImage(url, options) {
  let src;
  if (/\.svg((\?|#).*)?$/.test(url)) {
    // is SVG
    const response = await fetch(url, options);
    const xml = await response.text();
    // base64 encoding is safer. utf-8 fails in some browsers
    src = `data:image/svg+xml;base64,${btoa(xml)}`;
  } else {
    src = await url;
  }

  return await new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));
      image.crossOrigin = (options && options.crossOrigin) || 'anonymous';
      image.src = src;
    } catch (error) {
      reject(error);
    }
  });
}


/***/ }),

/***/ 0:
/*!******************************************!*\
  !*** ../node/parse-image-node (ignored) ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**************************************************!*\
  !*** ../../node/fetch/fetch-file-node (ignored) ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!**************************************************!*\
  !*** ../../node/fetch/write-file-node (ignored) ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!*******************************************!*\
  !*** ../node/encode-image-node (ignored) ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!************************************************!*\
  !*** ../node/buffer-to-array-buffer (ignored) ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});