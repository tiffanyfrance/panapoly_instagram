import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { TextDecoder, fetchFile } from '@loaders.gl/core';
import GLBParser from '../glb/glb-parser';
import GLTFPostProcessor from './gltf-post-processor';
import { getFullUri } from './gltf-utils';
import { KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION } from './gltf-constants';
import { getGLTFAccessors, getGLTFAccessor } from './gltf-attribute-utils';
const DEFAULT_OPTIONS = {
  fetchLinkedResources: true,
  fetch: fetchFile,
  decompress: false,
  DracoLoader: null,
  postProcess: true,
  createImages: false,
  log: console
};
export default class GLTFParser {
  parse(gltf) {
    var _this = this,
        _arguments = arguments;

    return _asyncToGenerator(function* () {
      let options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
      options = Object.assign({}, DEFAULT_OPTIONS, options);

      _this.parseSync(gltf, _objectSpread({}, options, {
        postProcess: false,
        decompress: false
      }));

      if (options.fetchLinkedResources) {
        yield _this._loadLinkedAssets(options);
      }

      if (options.decompress) {
        _this._decompressMeshes(options);
      }

      if (options.postProcess) {
        const postProcessor = new GLTFPostProcessor();
        postProcessor.postProcess(_this.gltf, _this.glbParser, options);
      }

      return _this.gltf;
    })();
  }

  parseSync(gltf) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    options = Object.assign({}, DEFAULT_OPTIONS, options);

    if (gltf instanceof ArrayBuffer && !GLBParser.isGLB(gltf, options)) {
      const textDecoder = new TextDecoder();
      gltf = textDecoder.decode(gltf);
    }

    if (typeof gltf === 'string') {
      gltf = JSON.parse(gltf);
    }

    if (gltf instanceof ArrayBuffer) {
      this.glbParser = new GLBParser();
      this.gltf = this.glbParser.parseSync(gltf).json;
      this.json = this.gltf;
    } else {
      this.glbParser = null;
      this.gltf = gltf;
      this.json = gltf;
    }

    if (options.decompress) {
      this._decompressMeshes(options);
    }

    if (options.postProcess) {
      const postProcessor = new GLTFPostProcessor();
      postProcessor.postProcess(this.gltf, this.glbParser, options);
    }

    return this.gltf;
  }

  getApplicationData(key) {
    const data = this.json[key];
    return data;
  }

  getExtraData(key) {
    const extras = this.json.extras || {};
    return extras[key];
  }

  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find(name => name === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] || true : null;
  }

  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }

  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }

  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }

  getScene(index) {
    return this._get('scenes', index);
  }

  getNode(index) {
    return this._get('nodes', index);
  }

  getSkin(index) {
    return this._get('skins', index);
  }

  getMesh(index) {
    return this._get('meshes', index);
  }

  getMaterial(index) {
    return this._get('materials', index);
  }

  getAccessor(index) {
    return this._get('accessors', index);
  }

  getCamera(index) {
    return null;
  }

  getTexture(index) {
    return this._get('textures', index);
  }

  getSampler(index) {
    return this._get('samplers', index);
  }

  getImage(index) {
    return this._get('images', index);
  }

  getBufferView(index) {
    return this._get('bufferViews', index);
  }

  getBuffer(index) {
    return this._get('buffers', index);
  }

  _get(array, index) {
    if (typeof index === 'object') {
      return index;
    }

    const object = this.gltf[array] && this.gltf[array][index];

    if (!object) {
      console.warn("glTF file error: Could not find ".concat(array, "[").concat(index, "]"));
    }

    return object;
  }

  _loadLinkedAssets(options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      return yield Promise.all(_this2.gltf.buffers.map(buffer => _this2._loadBuffer(buffer, options)));
    })();
  }

  _loadBuffer(buffer, options) {
    return _asyncToGenerator(function* () {
      if (buffer.uri) {
        const fetch = options.fetch || window.fetch;
        const uri = getFullUri(buffer.uri, options.uri);
        const response = yield fetch(uri);
        const arrayBuffer = yield response.arrayBuffer();
        buffer.data = arrayBuffer;
        buffer.uri = null;
      }
    })();
  }

  _decompressMeshes(options) {
    if (!options.DracoLoader || !options.decompress) {
      return;
    }

    for (const mesh of this.gltf.meshes || []) {
      for (const primitive of mesh.primitives) {
        this._decompressKhronosDracoPrimitive(primitive, options);

        this._decompressUberDracoPrimitive(primitive, options);

        if (!primitive.attributes || Object.keys(primitive.attributes).length === 0) {
          throw new Error('Empty glTF primitive: decompression failure?');
        }
      }
    }

    this._removeExtension(KHR_DRACO_MESH_COMPRESSION);

    this._removeExtension(UBER_POINT_CLOUD_EXTENSION);
  }

  _decompressKhronosDracoPrimitive(primitive, options) {
    const compressedMesh = primitive.extensions && primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

    if (!compressedMesh) {
      return;
    }

    delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

    const buffer = this._getBufferViewArray(compressedMesh.bufferView);

    const decodedData = options.DracoLoader.parseSync(buffer);
    primitive.attributes = getGLTFAccessors(decodedData.attributes);

    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
  }

  _decompressUberDracoPrimitive(primitive, options) {
    const compressedMesh = primitive.extensions && primitive.extensions[UBER_POINT_CLOUD_EXTENSION];

    if (!compressedMesh) {
      return;
    }

    if (primitive.mode !== 0) {
      throw new Error(UBER_POINT_CLOUD_EXTENSION);
    }

    delete primitive.extensions[UBER_POINT_CLOUD_EXTENSION];

    const buffer = this._getBufferViewArray(compressedMesh.bufferView);

    const decodedData = options.DracoLoader.parseSync(buffer);
    primitive.attributes = decodedData.attributes;
  }

  _getBufferViewArray(bufferViewIndex) {
    const bufferView = this.gltf.bufferViews[bufferViewIndex];

    if (this.glbParser) {
      return this.glbParser.getBufferView(bufferView);
    }

    const buffer = this.gltf.buffers[bufferView.buffer].data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(buffer, byteOffset, bufferView.byteLength);
  }

  _removeExtension(extensionName) {
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }

    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }

    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
  }

  _removeStringFromArray(array, string) {
    let found = true;

    while (found) {
      const index = array.indexOf(string);

      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }

}
//# sourceMappingURL=gltf-parser.js.map