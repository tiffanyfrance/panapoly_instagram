import { TextDecoder, padTo4Bytes, assert } from '@loaders.gl/core';
const MAGIC_glTF = 0x676c5446;
const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;
const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;
const LE = true;
const BE = false;

function getMagicString(dataView) {
  return "".concat(String.fromCharCode(dataView.getUint8(0))).concat(String.fromCharCode(dataView.getUint8(1))).concat(String.fromCharCode(dataView.getUint8(2))).concat(String.fromCharCode(dataView.getUint8(3)));
}

export function parseGLBSync(glb, arrayBuffer) {
  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const dataView = new DataView(arrayBuffer);
  glb.byteOffset = byteOffset;
  glb.magic = dataView.getUint32(byteOffset + 0, BE);
  glb.version = dataView.getUint32(byteOffset + 4, LE);
  glb.byteLength = dataView.getUint32(byteOffset + 8, LE);
  glb.type = getMagicString(dataView);
  const _options$magic = options.magic,
        magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;
  const isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;

  if (!isMagicValid) {
    console.warn("Invalid GLB magic string ".concat(glb.type));
  }

  assert(glb.version === 2, "Invalid GLB version ".concat(glb.version, ". Only .glb v2 supported"));
  assert(glb.byteLength > 20);
  glb.jsonChunkLength = dataView.getUint32(byteOffset + 12, LE);
  glb.jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE);
  const isJSONChunk = glb.jsonChunkFormat === GLB_CHUNK_TYPE_JSON || glb.jsonChunkFormat === 0;
  assert(isJSONChunk, "JSON chunk format ".concat(glb.jsonChunkFormat));
  glb.jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;
  const jsonChunk = new Uint8Array(arrayBuffer, byteOffset + glb.jsonChunkByteOffset, glb.jsonChunkLength);
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  const binChunkStart = glb.jsonChunkByteOffset + padTo4Bytes(glb.jsonChunkLength);
  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;
  glb.binChunkByteOffset = 0;
  glb.binChunkLength = 0;

  if (glb.hasBinChunk) {
    glb.binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);
    glb.binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);
    const isBinChunk = glb.binChunkFormat === GLB_CHUNK_TYPE_BIN || glb.binChunkFormat === 1;
    assert(isBinChunk, "BIN chunk format ".concat(glb.binChunkFormat));
    glb.binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;
  }

  return byteOffset + glb.byteLength;
}
//# sourceMappingURL=parse-glb.js.map