import { padTo4Bytes, copyArrayBuffer, copyToArray, TextEncoder } from '@loaders.gl/core';
import { isImage } from '@loaders.gl/images';
import { getAccessorTypeFromSize, getComponentTypeFromArray } from './gltf-type-utils';
import packBinaryJson from '../packed-json/pack-binary-json';
const MAGIC_glTF = 0x46546c67;
const MAGIC_JSON = 0x4e4f534a;
const MAGIC_BIN = 0x004e4942;
const LE = true;
const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;
export default class GLBBuilder {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.byteLength = 0;
    this.json = {
      buffers: [{
        byteLength: 0
      }],
      bufferViews: [],
      accessors: [],
      images: [],
      meshes: []
    };
    this.sourceBuffers = [];
    this.log = options.log || console;
  }

  getByteLength() {
    return this.byteLength;
  }

  isImage(imageData) {
    return isImage(imageData);
  }

  encodeSync() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.encodeAsGLB(options);
  }

  encodeAsGLB() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this._createGLBBuffer(options);
  }

  addApplicationData(key, data) {
    let packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const jsonData = packOptions.packTypedArrays ? packBinaryJson(data, this, packOptions) : data;
    this.json[key] = jsonData;
    return this;
  }

  addBuffer(sourceBuffer) {
    let accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      size: 3
    };
    const bufferViewIndex = this.addBufferView(sourceBuffer);
    const accessorDefaults = {
      size: accessor.size,
      componentType: getComponentTypeFromArray(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size)
    };
    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }

  addBufferView(buffer) {
    const byteLength = buffer.byteLength || buffer.length;
    this.json.bufferViews.push({
      buffer: 0,
      byteOffset: this.byteLength,
      byteLength
    });
    this.byteLength += padTo4Bytes(byteLength);
    this.sourceBuffers.push(buffer);
    return this.json.bufferViews.length - 1;
  }

  addAccessor(bufferViewIndex, accessor) {
    this.json.accessors.push({
      bufferView: bufferViewIndex,
      type: getAccessorTypeFromSize(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count
    });
    return this.json.accessors.length - 1;
  }

  _pack() {
    this._packBinaryChunk();

    return {
      arrayBuffer: this.arrayBuffer,
      json: this.json
    };
  }

  _packBinaryChunk() {
    if (this.arrayBuffer) {
      return;
    }

    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);
    let dstByteOffset = 0;

    for (let i = 0; i < this.sourceBuffers.length; i++) {
      const sourceBuffer = this.sourceBuffers[i];
      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
    }

    this.json.buffers[0].byteLength = totalByteLength;
    this.arrayBuffer = arrayBuffer;
    this.sourceBuffers = [];
  }

  _createGLBBuffer() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._packBinaryChunk();

    const binChunk = this.arrayBuffer;

    if (options.magic) {
      console.warn('Custom glTF magic number no longer supported');
    }

    const jsonChunkOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;

    const jsonChunk = this._convertObjectToJsonChunk(this.json);

    const jsonChunkLength = padTo4Bytes(jsonChunk.byteLength);
    const binChunkOffset = jsonChunkLength + jsonChunkOffset;
    const fileLength = binChunkOffset + GLB_CHUNK_HEADER_SIZE + padTo4Bytes(binChunk.byteLength);
    const glbArrayBuffer = new ArrayBuffer(fileLength);
    const dataView = new DataView(glbArrayBuffer);
    dataView.setUint32(0, MAGIC_glTF, LE);
    dataView.setUint32(4, 2, LE);
    dataView.setUint32(8, fileLength, LE);
    dataView.setUint32(12, jsonChunk.byteLength, LE);
    dataView.setUint32(16, MAGIC_JSON, LE);
    copyArrayBuffer(glbArrayBuffer, jsonChunk, jsonChunkOffset);

    for (let i = 0; i < jsonChunkLength - jsonChunk.byteLength; ++i) {
      dataView.setUint8(jsonChunkOffset + jsonChunk.byteLength + i, 0x20);
    }

    const binChunkLengthPadded = padTo4Bytes(binChunk.byteLength);
    dataView.setUint32(binChunkOffset + 0, binChunkLengthPadded, LE);
    dataView.setUint32(binChunkOffset + 4, MAGIC_BIN, LE);
    copyArrayBuffer(glbArrayBuffer, binChunk, binChunkOffset + GLB_CHUNK_HEADER_SIZE);

    for (let i = 0; i < binChunkLengthPadded - binChunk.byteLength; ++i) {
      dataView.setUint8(binChunkOffset + GLB_CHUNK_HEADER_SIZE + binChunk.byteLength + i, 0);
    }

    return glbArrayBuffer;
  }

  _getInternalCounts() {
    return {
      buffers: this.json.buffers.length,
      bufferViews: this.json.bufferViews.length,
      accessors: this.json.accessors.length,
      images: this.json.images.length
    };
  }

  _convertObjectToJsonChunk(json) {
    const jsonChunkString = JSON.stringify(json);
    const textEncoder = new TextEncoder('utf8');
    return textEncoder.encode(jsonChunkString);
  }

}
//# sourceMappingURL=glb-builder.js.map