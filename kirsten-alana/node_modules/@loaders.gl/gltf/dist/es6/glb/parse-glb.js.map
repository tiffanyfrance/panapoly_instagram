{"version":3,"sources":["../../../src/glb/parse-glb.js"],"names":["TextDecoder","padTo4Bytes","assert","MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","LE","BE","getMagicString","dataView","String","fromCharCode","getUint8","parseGLBSync","glb","arrayBuffer","byteOffset","options","DataView","magic","getUint32","version","byteLength","type","isMagicValid","console","warn","jsonChunkLength","jsonChunkFormat","isJSONChunk","jsonChunkByteOffset","jsonChunk","Uint8Array","textDecoder","jsonText","decode","json","JSON","parse","binChunkStart","hasBinChunk","binChunkByteOffset","binChunkLength","binChunkFormat","isBinChunk"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\nimport {TextDecoder, padTo4Bytes, assert} from '@loaders.gl/core';\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\n\nconst LE = true; // Binary GLTF is little endian.\nconst BE = false; // Magic needs to be written as BE\n\nfunction getMagicString(dataView) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(0))}\\\n${String.fromCharCode(dataView.getUint8(1))}\\\n${String.fromCharCode(dataView.getUint8(2))}\\\n${String.fromCharCode(dataView.getUint8(3))}`;\n}\n\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n/*\nReturns {\n  // Header\n  type: String,\n  magic: number,\n  version: number,\n  byteLength: number,\n  byteOffset: number,\n  // JSON Chunk\n  json: any,\n  jsonChunkFormat: number,\n  jsonChunkByteOffset: number,\n  jsonChunkLength: number,\n  // BIN Chunk\n  hasBinChunk: boolean,\n  binChunkFormat: number,\n  binChunkByteOffset: number,\n  binChunkLength: number\n}\n*/\nexport function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  glb.byteOffset = byteOffset; // Byte offset into the initial arrayBuffer\n\n  // GLB Header\n  glb.magic = dataView.getUint32(byteOffset + 0, BE); // Magic number (the ASCII string 'glTF').\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  glb.byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file\n\n  glb.type = getMagicString(dataView);\n\n  // TODO - switch type checks to use strings\n  const {magic = MAGIC_glTF} = options;\n  const isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;\n  if (!isMagicValid) {\n    console.warn(`Invalid GLB magic string ${glb.type}`); // eslint-disable-line\n  }\n\n  assert(glb.version === 2, `Invalid GLB version ${glb.version}. Only .glb v2 supported`);\n  assert(glb.byteLength > 20);\n\n  // Parse the JSON chunk\n\n  glb.jsonChunkLength = dataView.getUint32(byteOffset + 12, LE); // Byte length of json chunk\n  glb.jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE); // Chunk format as uint32\n\n  // Check JSON Chunk format (0 = Back compat)\n  const isJSONChunk = glb.jsonChunkFormat === GLB_CHUNK_TYPE_JSON || glb.jsonChunkFormat === 0;\n  assert(isJSONChunk, `JSON chunk format ${glb.jsonChunkFormat}`);\n\n  // Create a \"view\" of the binary encoded JSON data\n  glb.jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes\n  const jsonChunk = new Uint8Array(\n    arrayBuffer,\n    byteOffset + glb.jsonChunkByteOffset,\n    glb.jsonChunkLength\n  );\n\n  // Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  const binChunkStart = glb.jsonChunkByteOffset + padTo4Bytes(glb.jsonChunkLength);\n\n  // Parse and check BIN chunk header\n  // Note: BIN chunk can be optional\n  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;\n  glb.binChunkByteOffset = 0;\n  glb.binChunkLength = 0;\n\n  if (glb.hasBinChunk) {\n    glb.binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);\n    glb.binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);\n    const isBinChunk = glb.binChunkFormat === GLB_CHUNK_TYPE_BIN || glb.binChunkFormat === 1; // Back compat\n    assert(isBinChunk, `BIN chunk format ${glb.binChunkFormat}`);\n\n    glb.binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;\n  }\n\n  return byteOffset + glb.byteLength;\n}\n"],"file":"parse-glb.js"}