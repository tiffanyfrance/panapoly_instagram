import { assert } from '@loaders.gl/core';
import { parseGLBSync } from './parse-glb';
import unpackGLBBuffers from './unpack-glb-buffers';
import unpackBinaryJson from '../packed-json/unpack-binary-json';
import { ATTRIBUTE_TYPE_TO_COMPONENTS, ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY } from './gltf-type-utils';
const MAGIC_glTF = 0x676c5446;
export default class GLBParser {
  static isGLB(arrayBuffer) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const _options$magic = options.magic,
          magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;
    const dataView = new DataView(arrayBuffer);
    const magic1 = dataView.getUint32(0, false);
    return magic1 === magic || magic1 === MAGIC_glTF;
  }

  parse(arrayBuffer) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this.parseSync(arrayBuffer, options);
  }

  parseSync(arrayBuffer) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.glbArrayBuffer = arrayBuffer;
    this.binaryByteOffset = null;
    this.packedJson = null;
    this.json = null;

    if (this.json === null && this.binaryByteOffset === null) {
      const byteOffset = 0;
      parseGLBSync(this, this.glbArrayBuffer, byteOffset, options);
      this.binaryByteOffset = this.binChunkByteOffset;
      this.packedJson = this.json;
      this.unpackedBuffers = unpackGLBBuffers(this.glbArrayBuffer, this.json, this.binaryByteOffset);
      this.json = unpackBinaryJson(this.json, this.unpackedBuffers);
    }

    return this;
  }

  getApplicationData(key) {
    return this.json[key];
  }

  getJSON() {
    return this.json;
  }

  getArrayBuffer() {
    return this.glbArrayBuffer;
  }

  getBinaryByteOffset() {
    return this.binaryByteOffset;
  }

  getBufferView(glTFBufferView) {
    const byteOffset = (glTFBufferView.byteOffset || 0) + this.binaryByteOffset;
    return new Uint8Array(this.glbArrayBuffer, byteOffset, glTFBufferView.byteLength);
  }

  getBuffer(glTFAccessor) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[glTFAccessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[glTFAccessor.type];
    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[glTFAccessor.componentType];
    const length = glTFAccessor.count * components;
    const byteLength = glTFAccessor.count * components * bytesPerComponent;
    const glTFBufferView = this.json.bufferViews[glTFAccessor.bufferView];
    assert(byteLength >= 0 && glTFAccessor.byteOffset + byteLength <= glTFBufferView.byteLength);
    const byteOffset = glTFBufferView.byteOffset + this.binaryByteOffset + glTFAccessor.byteOffset;
    return new ArrayType(this.glbArrayBuffer, byteOffset, length);
  }

  getImageData(glTFImage) {
    return {
      typedArray: this.getBufferView(glTFImage.bufferView),
      mimeType: glTFImage.mimeType || 'image/jpeg'
    };
  }

  getImage(glTFImage) {
    const arrayBufferView = this.getBufferView(glTFImage.bufferView);
    const mimeType = glTFImage.mimeType || 'image/jpeg';
    const blob = new Blob([arrayBufferView], {
      type: mimeType
    });
    const urlCreator = self.URL || self.webkitURL;
    const imageUrl = urlCreator.createObjectURL(blob);
    const img = new Image();
    img.src = imageUrl;
    return img;
  }

  getImageAsync(glTFImage) {
    return new Promise(resolve => {
      const arrayBufferView = this.getBufferView(glTFImage.bufferView);
      const mimeType = glTFImage.mimeType || 'image/jpeg';
      const blob = new Blob([arrayBufferView], {
        type: mimeType
      });
      const urlCreator = self.URL || self.webkitURL;
      const imageUrl = urlCreator.createObjectURL(blob);
      const img = new Image();

      img.onload = () => resolve(img);

      img.src = imageUrl;
    });
  }

}
//# sourceMappingURL=glb-parser.js.map