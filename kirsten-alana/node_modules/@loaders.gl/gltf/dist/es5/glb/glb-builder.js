"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _core = require("@loaders.gl/core");

var _images = require("@loaders.gl/images");

var _gltfTypeUtils = require("./gltf-type-utils");

var _packBinaryJson = _interopRequireDefault(require("../packed-json/pack-binary-json"));

var MAGIC_glTF = 0x46546c67;
var MAGIC_JSON = 0x4e4f534a;
var MAGIC_BIN = 0x004e4942;
var LE = true;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;

var GLBBuilder = function () {
  function GLBBuilder() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, GLBBuilder);
    this.byteLength = 0;
    this.json = {
      buffers: [{
        byteLength: 0
      }],
      bufferViews: [],
      accessors: [],
      images: [],
      meshes: []
    };
    this.sourceBuffers = [];
    this.log = options.log || console;
  }

  (0, _createClass2["default"])(GLBBuilder, [{
    key: "getByteLength",
    value: function getByteLength() {
      return this.byteLength;
    }
  }, {
    key: "isImage",
    value: function isImage(imageData) {
      return (0, _images.isImage)(imageData);
    }
  }, {
    key: "encodeSync",
    value: function encodeSync() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.encodeAsGLB(options);
    }
  }, {
    key: "encodeAsGLB",
    value: function encodeAsGLB() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._createGLBBuffer(options);
    }
  }, {
    key: "addApplicationData",
    value: function addApplicationData(key, data) {
      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var jsonData = packOptions.packTypedArrays ? (0, _packBinaryJson["default"])(data, this, packOptions) : data;
      this.json[key] = jsonData;
      return this;
    }
  }, {
    key: "addBuffer",
    value: function addBuffer(sourceBuffer) {
      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        size: 3
      };
      var bufferViewIndex = this.addBufferView(sourceBuffer);
      var accessorDefaults = {
        size: accessor.size,
        componentType: (0, _gltfTypeUtils.getComponentTypeFromArray)(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size)
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
  }, {
    key: "addBufferView",
    value: function addBufferView(buffer) {
      var byteLength = buffer.byteLength || buffer.length;
      this.json.bufferViews.push({
        buffer: 0,
        byteOffset: this.byteLength,
        byteLength: byteLength
      });
      this.byteLength += (0, _core.padTo4Bytes)(byteLength);
      this.sourceBuffers.push(buffer);
      return this.json.bufferViews.length - 1;
    }
  }, {
    key: "addAccessor",
    value: function addAccessor(bufferViewIndex, accessor) {
      this.json.accessors.push({
        bufferView: bufferViewIndex,
        type: (0, _gltfTypeUtils.getAccessorTypeFromSize)(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count
      });
      return this.json.accessors.length - 1;
    }
  }, {
    key: "_pack",
    value: function _pack() {
      this._packBinaryChunk();

      return {
        arrayBuffer: this.arrayBuffer,
        json: this.json
      };
    }
  }, {
    key: "_packBinaryChunk",
    value: function _packBinaryChunk() {
      if (this.arrayBuffer) {
        return;
      }

      var totalByteLength = this.byteLength;
      var arrayBuffer = new ArrayBuffer(totalByteLength);
      var targetArray = new Uint8Array(arrayBuffer);
      var dstByteOffset = 0;

      for (var i = 0; i < this.sourceBuffers.length; i++) {
        var sourceBuffer = this.sourceBuffers[i];
        dstByteOffset = (0, _core.copyToArray)(sourceBuffer, targetArray, dstByteOffset);
      }

      this.json.buffers[0].byteLength = totalByteLength;
      this.arrayBuffer = arrayBuffer;
      this.sourceBuffers = [];
    }
  }, {
    key: "_createGLBBuffer",
    value: function _createGLBBuffer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._packBinaryChunk();

      var binChunk = this.arrayBuffer;

      if (options.magic) {
        console.warn('Custom glTF magic number no longer supported');
      }

      var jsonChunkOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;

      var jsonChunk = this._convertObjectToJsonChunk(this.json);

      var jsonChunkLength = (0, _core.padTo4Bytes)(jsonChunk.byteLength);
      var binChunkOffset = jsonChunkLength + jsonChunkOffset;
      var fileLength = binChunkOffset + GLB_CHUNK_HEADER_SIZE + (0, _core.padTo4Bytes)(binChunk.byteLength);
      var glbArrayBuffer = new ArrayBuffer(fileLength);
      var dataView = new DataView(glbArrayBuffer);
      dataView.setUint32(0, MAGIC_glTF, LE);
      dataView.setUint32(4, 2, LE);
      dataView.setUint32(8, fileLength, LE);
      dataView.setUint32(12, jsonChunk.byteLength, LE);
      dataView.setUint32(16, MAGIC_JSON, LE);
      (0, _core.copyArrayBuffer)(glbArrayBuffer, jsonChunk, jsonChunkOffset);

      for (var i = 0; i < jsonChunkLength - jsonChunk.byteLength; ++i) {
        dataView.setUint8(jsonChunkOffset + jsonChunk.byteLength + i, 0x20);
      }

      var binChunkLengthPadded = (0, _core.padTo4Bytes)(binChunk.byteLength);
      dataView.setUint32(binChunkOffset + 0, binChunkLengthPadded, LE);
      dataView.setUint32(binChunkOffset + 4, MAGIC_BIN, LE);
      (0, _core.copyArrayBuffer)(glbArrayBuffer, binChunk, binChunkOffset + GLB_CHUNK_HEADER_SIZE);

      for (var _i = 0; _i < binChunkLengthPadded - binChunk.byteLength; ++_i) {
        dataView.setUint8(binChunkOffset + GLB_CHUNK_HEADER_SIZE + binChunk.byteLength + _i, 0);
      }

      return glbArrayBuffer;
    }
  }, {
    key: "_getInternalCounts",
    value: function _getInternalCounts() {
      return {
        buffers: this.json.buffers.length,
        bufferViews: this.json.bufferViews.length,
        accessors: this.json.accessors.length,
        images: this.json.images.length
      };
    }
  }, {
    key: "_convertObjectToJsonChunk",
    value: function _convertObjectToJsonChunk(json) {
      var jsonChunkString = JSON.stringify(json);
      var textEncoder = new _core.TextEncoder('utf8');
      return textEncoder.encode(jsonChunkString);
    }
  }]);
  return GLBBuilder;
}();

exports["default"] = GLBBuilder;
//# sourceMappingURL=glb-builder.js.map