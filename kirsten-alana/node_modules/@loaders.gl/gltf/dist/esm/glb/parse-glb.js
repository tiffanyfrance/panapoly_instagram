import { TextDecoder, padTo4Bytes, assert } from '@loaders.gl/core';
var MAGIC_glTF = 0x676c5446;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
var GLB_CHUNK_TYPE_BIN = 0x004e4942;
var LE = true;
var BE = false;

function getMagicString(dataView) {
  return "".concat(String.fromCharCode(dataView.getUint8(0))).concat(String.fromCharCode(dataView.getUint8(1))).concat(String.fromCharCode(dataView.getUint8(2))).concat(String.fromCharCode(dataView.getUint8(3)));
}

export function parseGLBSync(glb, arrayBuffer) {
  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var dataView = new DataView(arrayBuffer);
  glb.byteOffset = byteOffset;
  glb.magic = dataView.getUint32(byteOffset + 0, BE);
  glb.version = dataView.getUint32(byteOffset + 4, LE);
  glb.byteLength = dataView.getUint32(byteOffset + 8, LE);
  glb.type = getMagicString(dataView);
  var _options$magic = options.magic,
      magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;
  var isMagicValid = glb.magic === MAGIC_glTF || glb.magic === magic;

  if (!isMagicValid) {
    console.warn("Invalid GLB magic string ".concat(glb.type));
  }

  assert(glb.version === 2, "Invalid GLB version ".concat(glb.version, ". Only .glb v2 supported"));
  assert(glb.byteLength > 20);
  glb.jsonChunkLength = dataView.getUint32(byteOffset + 12, LE);
  glb.jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE);
  var isJSONChunk = glb.jsonChunkFormat === GLB_CHUNK_TYPE_JSON || glb.jsonChunkFormat === 0;
  assert(isJSONChunk, "JSON chunk format ".concat(glb.jsonChunkFormat));
  glb.jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE;
  var jsonChunk = new Uint8Array(arrayBuffer, byteOffset + glb.jsonChunkByteOffset, glb.jsonChunkLength);
  var textDecoder = new TextDecoder('utf8');
  var jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  var binChunkStart = glb.jsonChunkByteOffset + padTo4Bytes(glb.jsonChunkLength);
  glb.hasBinChunk = binChunkStart + 8 <= glb.byteLength;
  glb.binChunkByteOffset = 0;
  glb.binChunkLength = 0;

  if (glb.hasBinChunk) {
    glb.binChunkLength = dataView.getUint32(byteOffset + binChunkStart + 0, LE);
    glb.binChunkFormat = dataView.getUint32(byteOffset + binChunkStart + 4, LE);
    var isBinChunk = glb.binChunkFormat === GLB_CHUNK_TYPE_BIN || glb.binChunkFormat === 1;
    assert(isBinChunk, "BIN chunk format ".concat(glb.binChunkFormat));
    glb.binChunkByteOffset = binChunkStart + GLB_CHUNK_HEADER_SIZE;
  }

  return byteOffset + glb.byteLength;
}
//# sourceMappingURL=parse-glb.js.map