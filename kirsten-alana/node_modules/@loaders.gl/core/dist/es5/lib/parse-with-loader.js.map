{"version":3,"sources":["../../../src/lib/parse-with-loader.js"],"names":["parseWithLoader","data","loader","options","url","parseTextSync","dataType","parseSync","parse","worker","parseWithLoaderSync","parseWithLoaderInBatches","parseInBatches","inputIterator","outputIterator","parseWithLoaderInBatchesSync","parseInBatchesSync"],"mappings":";;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;SAYsBA,e;;;;;qFAAf,iBAA+BC,IAA/B,EAAqCC,MAArC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6CC,YAAAA,OAA7C,2DAAuD,EAAvD;AAA2DC,YAAAA,GAA3D;AACLA,YAAAA,GAAG,GAAGA,GAAG,IAAI,6BAAeH,IAAf,CAAb;AADK;AAAA,mBAEQ,6CAA+BA,IAA/B,EAAqCC,MAArC,CAFR;;AAAA;AAELD,YAAAA,IAFK;;AAAA,kBAKDC,MAAM,CAACG,aAAP,IAAwB,OAAOJ,IAAP,KAAgB,QALvC;AAAA;AAAA;AAAA;;AAMHE,YAAAA,OAAO,CAACG,QAAR,GAAmB,MAAnB;AANG,6CAOIJ,MAAM,CAACG,aAAP,CAAqBJ,IAArB,EAA2BE,OAA3B,EAAoCC,GAApC,EAAyCF,MAAzC,CAPJ;;AAAA;AAAA,iBAWDA,MAAM,CAACK,SAXN;AAAA;AAAA;AAAA;;AAAA,6CAYIL,MAAM,CAACK,SAAP,CAAiBN,IAAjB,EAAuBE,OAAvB,EAAgCC,GAAhC,EAAqCF,MAArC,CAZJ;;AAAA;AAAA,iBAgBDA,MAAM,CAACM,KAhBN;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAiBUN,MAAM,CAACM,KAAP,CAAaP,IAAb,EAAmBE,OAAnB,EAA4BC,GAA5B,EAAiCF,MAAjC,CAjBV;;AAAA;AAAA;;AAAA;AAAA,iBAoBDA,MAAM,CAACO,MApBN;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAqBU,iCAAgBP,MAAM,CAACO,MAAvB,EAA+BR,IAA/B,EAAqCE,OAArC,CArBV;;AAAA;AAAA;;AAAA;AAAA,6CA0BE,wBAAO,KAAP,CA1BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA8BA,SAASO,mBAAT,CAA6BT,IAA7B,EAAmCC,MAAnC,EAA8D;AAAA,MAAnBC,OAAmB,uEAAT,EAAS;AAAA,MAALC,GAAK;AACnEH,EAAAA,IAAI,GAAG,iDAAmCA,IAAnC,EAAyCC,MAAzC,CAAP;;AAEA,MAAIA,MAAM,CAACG,aAAP,IAAwB,OAAOJ,IAAP,KAAgB,QAA5C,EAAsD;AACpD,WAAOC,MAAM,CAACG,aAAP,CAAqBJ,IAArB,EAA2BE,OAA3B,EAAoCC,GAApC,EAAyCF,MAAzC,CAAP;AACD;;AAED,MAAIA,MAAM,CAACK,SAAX,EAAsB;AACpB,WAAOL,MAAM,CAACK,SAAP,CAAiBN,IAAjB,EAAuBE,OAAvB,EAAgCC,GAAhC,EAAqCF,MAArC,CAAP;AACD;;AAID,SAAO,wBAAO,KAAP,CAAP;AACD;;SAEqBS,wB;;;;;8FAAf,kBAAwCV,IAAxC,EAA8CC,MAA9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsDC,YAAAA,OAAtD,8DAAgE,EAAhE;AAAoEC,YAAAA,GAApE;;AAAA,iBAEDF,MAAM,CAACU,cAFN;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAGyB,uCAAyBX,IAAzB,CAHzB;;AAAA;AAGGY,YAAAA,aAHH;AAIGC,YAAAA,cAJH,GAIoBZ,MAAM,CAACU,cAAP,CAAsBC,aAAtB,EAAqCV,OAArC,EAA8CC,GAA9C,EAAmDF,MAAnD,CAJpB;AAAA,8CAKIY,cALJ;;AAAA;AAAA,8CASE,IATF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAYeC,4B;;;;;kGAAf,kBAA4Cd,IAA5C,EAAkDC,MAAlD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0DC,YAAAA,OAA1D,8DAAoE,EAApE;AAAwEC,YAAAA,GAAxE;;AAAA,iBAEDF,MAAM,CAACc,kBAFN;AAAA;AAAA;AAAA;;AAGGH,YAAAA,aAHH,GAGmB,kCAAoBZ,IAApB,CAHnB;AAIGa,YAAAA,cAJH,GAIoBZ,MAAM,CAACc,kBAAP,CAA0BH,aAA1B,EAAyCV,OAAzC,EAAkDC,GAAlD,EAAuDF,MAAvD,EAA+DE,GAA/D,CAJpB;AAAA,8CAKIU,cALJ;;AAAA;AAAA,8CAQE,wBAAO,KAAP,CARF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import assert from '../utils/assert';\nimport parseWithWorker from './parse-with-worker';\nimport {\n  getArrayBufferOrStringFromDataSync,\n  getArrayBufferOrStringFromData,\n  getAsyncIteratorFromData,\n  getIteratorFromData,\n  // getLengthFromData,\n  getUrlFromData\n} from './loader-utils/get-data';\n\n// TODO: support progress and abort\n// TODO: support moving loading to worker\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nexport async function parseWithLoader(data, loader, options = {}, url) {\n  url = url || getUrlFromData(data);\n  data = await getArrayBufferOrStringFromData(data, loader);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  // Now check for synchronous binary data parser, wrap results in promises\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parse) {\n    return await loader.parse(data, options, url, loader);\n  }\n\n  if (loader.worker) {\n    return await parseWithWorker(loader.worker, data, options);\n  }\n\n  // TBD - If asynchronous parser not available, return null\n  // => This loader does not work on loaded data and only supports `loadAndParseAsync`\n  return assert(false);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nexport function parseWithLoaderSync(data, loader, options = {}, url) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);\n  return assert(false);\n}\n\nexport async function parseWithLoaderInBatches(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);\n    return outputIterator;\n  }\n\n  // TODO - update after test cases have been fixed\n  return null;\n}\n\nexport async function parseWithLoaderInBatchesSync(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatchesSync) {\n    const inputIterator = getIteratorFromData(data);\n    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);\n    return outputIterator;\n  }\n\n  return assert(false);\n}\n"],"file":"parse-with-loader.js"}