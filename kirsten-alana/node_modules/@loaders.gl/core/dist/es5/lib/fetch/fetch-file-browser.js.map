{"version":3,"sources":["../../../../src/lib/fetch/fetch-file-browser.js"],"names":["DEFAULT_OPTIONS","dataType","nothrow","isDataURL","url","startsWith","fetchFile","options","fetch","readFileSync","uri","getReadFileOptions","createReadStream","then","res","body","Object","assign","responseType"],"mappings":";;;;;;;;;;;;;;;AACA;;AAEA,IAAMA,eAAe,GAAG;AACtBC,EAAAA,QAAQ,EAAE,aADY;AAGtBC,EAAAA,OAAO,EAAE;AAHa,CAAxB;;AAMA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,GAAG;AAAA,SAAIA,GAAG,CAACC,UAAJ,CAAe,OAAf,CAAJ;AAAA,CAArB;;SAIsBC,S;;;;;+EAAf,iBAAyBF,GAAzB,EAA8BG,OAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACQC,KAAK,CAACJ,GAAD,EAAMG,OAAN,CADb;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAUA,SAASE,YAAT,CAAsBC,GAAtB,EAAyC;AAAA,MAAdH,OAAc,uEAAJ,EAAI;AAC9CA,EAAAA,OAAO,GAAGI,kBAAkB,CAACJ,OAAD,CAA5B;;AAEA,MAAIJ,SAAS,CAACO,GAAD,CAAb,EAAoB,CAGnB;;AAED,MAAI,CAACH,OAAO,CAACL,OAAb,EAAsB;AAEpB,4BAAO,KAAP;AACD;;AAED,SAAO,IAAP;AACD;;SAQqBU,gB;;;;;sFAAf,kBAAgCR,GAAhC,EAAqCG,OAArC;AAAA;AAAA;AAAA;AAAA;AAAA,8CACEC,KAAK,CAACJ,GAAD,EAAMG,OAAN,CAAL,CAAoBM,IAApB,CAAyB,UAAAC,GAAG;AAAA,qBAAIA,GAAG,CAACC,IAAR;AAAA,aAA5B,CADF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAMP,SAASJ,kBAAT,GAA0C;AAAA,MAAdJ,OAAc,uEAAJ,EAAI;AACxCA,EAAAA,OAAO,GAAGS,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBjB,eAAlB,EAAmCO,OAAnC,CAAV;AACAA,EAAAA,OAAO,CAACW,YAAR,GAAuBX,OAAO,CAACW,YAAR,IAAwBX,OAAO,CAACN,QAAvD;AACA,SAAOM,OAAP;AACD","sourcesContent":["/* global fetch */\nimport assert from '../../utils/assert';\n\nconst DEFAULT_OPTIONS = {\n  dataType: 'arrayBuffer',\n  // TODO - this was mostly set to true to make test cases work\n  nothrow: true\n};\n\nconst isDataURL = url => url.startsWith('data:');\n// const isFileURL = url => typeof File !== 'undefined' && url instanceof File;\n\n// Returns a promise that resolves to a response object\nexport async function fetchFile(url, options) {\n  return await fetch(url, options);\n\n  // TODO - SUPPORT reading from `File` objects\n  // if (typeof File !== 'undefined' && uri instanceof File) {\n  //   readFileObject(uri, options);\n  // }\n}\n\n// In a few cases (data URIs, files under Node) \"files\" can be read synchronously\nexport function readFileSync(uri, options = {}) {\n  options = getReadFileOptions(options);\n\n  if (isDataURL(uri)) {\n    // TODO - removed until decodeDataUri does not depend on Node.js Buffer\n    //   return decodeDataUri(uri);\n  }\n\n  if (!options.nothrow) {\n    // throw new Error('Cant load URI synchronously');\n    assert(false);\n  }\n\n  return null;\n}\n\n// DEPRECATED\n\n// Creates a readable stream to\n// * http/http urls\n// * data urls\n// TODO - does not support opening a stream on a `File` objects\nexport async function createReadStream(url, options) {\n  return fetch(url, options).then(res => res.body);\n}\n\n// HELPER FUNCTIONS\n\nfunction getReadFileOptions(options = {}) {\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  options.responseType = options.responseType || options.dataType;\n  return options;\n}\n\n/**\n * File reader function for the browser\n * @param {File|Blob} file  HTML File or Blob object to read as string\n * @returns {Promise.string}  Resolves to a string containing file contents\n/* global File, FileReader\nfunction readFileObject(file, options) {\n  return new Promise((resolve, reject) => {\n    try {\n      const reader = new FileReader();\n      reader.onerror = error => reject(new Error(error));\n      reader.onabort = () => reject(new Error('Read aborted.'));\n      reader.onload = () => resolve(reader.result);\n      if (options.dataType !== 'arraybuffer') {\n        reader.readAsText(file);\n      } else {\n        reader.readAsArrayBuffer(file);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n*/\n\n/* Reads raw file data from:\n// * http/http urls\n// * data urls\n// * File/Blob objects\n// etc?\nasync function readFile(uri, options = {}) {\n  options = getReadFileOptions(options);\n\n  // NOTE: data URLs are decoded by fetch\n\n  // SUPPORT reading from `File` objects\n  if (typeof File !== 'undefined' && uri instanceof File) {\n    readFileObject(uri, options);\n  }\n\n  // In a web worker, XMLHttpRequest throws invalid URL error if using relative path\n  // resolve url relative to original base\n  // TODO - merge this into `resolvePath?\n  uri = new URL(uri, location.href).href;\n\n  // Browser: Try to load all URLS via fetch, as they can be local requests (e.g. to a dev server)\n  const response = await fetch(uri, options);\n  return response[options.dataType]();\n}\n*/\n"],"file":"fetch-file-browser.js"}