{"version":3,"sources":["../../../src/javascript-utils/binary-utils.js"],"names":["assert","TextEncoder","isArrayBuffer","x","ArrayBuffer","isBlob","Blob","isBuffer","Buffer","toArrayBuffer","data","typedArray","Uint8Array","buffer","isView","text","uint8Array","encode","blobToArrayBuffer","blob","Promise","resolve","reject","arrayBuffer","fileReader","FileReader","onload","event","target","result","onloadend","onerror","readAsArrayBuffer","toDataView","DataView"],"mappings":"AACA,OAAOA,MAAP,MAAmB,iBAAnB;AACA,SAAQC,WAAR,QAA0B,iBAA1B;AAEA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,CAAC;AAAA,SAAIA,CAAC,IAAIA,CAAC,YAAYC,WAAtB;AAAA,CAAvB;AACP,OAAO,IAAMC,MAAM,GAAG,SAATA,MAAS,CAAAF,CAAC;AAAA,SAAIA,CAAC,IAAI,OAAOG,IAAP,KAAgB,WAArB,IAAoCH,CAAC,YAAYG,IAArD;AAAA,CAAhB;AACP,OAAO,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAJ,CAAC;AAAA,SAAIA,CAAC,IAAIA,CAAC,YAAYK,MAAtB;AAAA,CAAlB;AAEP,OAAO,SAASC,aAAT,CAAuBC,IAAvB,EAA6B;AAClC,MAAIR,aAAa,CAACQ,IAAD,CAAjB,EAAyB;AACvB,WAAOA,IAAP;AACD;;AAGD,MAAIH,QAAQ,CAACG,IAAD,CAAZ,EAAoB;AAClB,QAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAeF,IAAf,CAAnB;AACA,WAAOC,UAAU,CAACE,MAAlB;AACD;;AAGD,MAAIT,WAAW,CAACU,MAAZ,CAAmBJ,IAAnB,CAAJ,EAA8B;AAC5B,WAAOA,IAAI,CAACG,MAAZ;AACD;;AAED,MAAI,OAAOH,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAMK,IAAI,GAAGL,IAAb;AACA,QAAMM,UAAU,GAAG,IAAIf,WAAJ,GAAkBgB,MAAlB,CAAyBF,IAAzB,CAAnB;AACA,WAAOC,UAAU,CAACH,MAAlB;AACD;;AAED,SAAOb,MAAM,CAAC,KAAD,CAAb;AACD;AAED,OAAO,SAASkB,iBAAT,CAA2BC,IAA3B,EAAiC;AACtC,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,QAAIC,WAAJ;AACA,QAAMC,UAAU,GAAG,IAAIC,UAAJ,EAAnB;;AACAD,IAAAA,UAAU,CAACE,MAAX,GAAoB,UAAAC,KAAK,EAAI;AAC3BJ,MAAAA,WAAW,GAAGI,KAAK,CAACC,MAAN,CAAaC,MAA3B;AACD,KAFD;;AAGAL,IAAAA,UAAU,CAACM,SAAX,GAAuB,UAAAH,KAAK;AAAA,aAAIN,OAAO,CAACE,WAAD,CAAX;AAAA,KAA5B;;AACAC,IAAAA,UAAU,CAACO,OAAX,GAAqBT,MAArB;AACAE,IAAAA,UAAU,CAACQ,iBAAX,CAA6Bb,IAA7B;AACD,GATM,CAAP;AAUD;AAED,OAAO,SAASc,UAAT,CAAoBpB,MAApB,EAA4B;AACjC,SAAO,IAAIqB,QAAJ,CAAazB,aAAa,CAACI,MAAD,CAA1B,CAAP;AACD","sourcesContent":["/* global FileReader, Blob, ArrayBuffer, Buffer */\nimport assert from '../utils/assert';\nimport {TextEncoder} from './text-encoding';\n\nexport const isArrayBuffer = x => x && x instanceof ArrayBuffer;\nexport const isBlob = x => x && typeof Blob !== 'undefined' && x instanceof Blob;\nexport const isBuffer = x => x && x instanceof Buffer;\n\nexport function toArrayBuffer(data) {\n  if (isArrayBuffer(data)) {\n    return data;\n  }\n\n  // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n  if (isBuffer(data)) {\n    const typedArray = new Uint8Array(data);\n    return typedArray.buffer;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  return assert(false);\n}\n\nexport function blobToArrayBuffer(blob) {\n  return new Promise((resolve, reject) => {\n    let arrayBuffer;\n    const fileReader = new FileReader();\n    fileReader.onload = event => {\n      arrayBuffer = event.target.result;\n    };\n    fileReader.onloadend = event => resolve(arrayBuffer);\n    fileReader.onerror = reject;\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n\nexport function toDataView(buffer) {\n  return new DataView(toArrayBuffer(buffer));\n}\n"],"file":"binary-utils.js"}