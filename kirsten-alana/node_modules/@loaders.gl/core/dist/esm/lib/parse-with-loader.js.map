{"version":3,"sources":["../../../src/lib/parse-with-loader.js"],"names":["assert","parseWithWorker","getArrayBufferOrStringFromDataSync","getArrayBufferOrStringFromData","getAsyncIteratorFromData","getIteratorFromData","getUrlFromData","parseWithLoader","data","loader","options","url","parseTextSync","dataType","parseSync","parse","worker","parseWithLoaderSync","parseWithLoaderInBatches","parseInBatches","inputIterator","outputIterator","parseWithLoaderInBatchesSync","parseInBatchesSync"],"mappings":"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","sourcesContent":["import assert from '../utils/assert';\nimport parseWithWorker from './parse-with-worker';\nimport {\n  getArrayBufferOrStringFromDataSync,\n  getArrayBufferOrStringFromData,\n  getAsyncIteratorFromData,\n  getIteratorFromData,\n  // getLengthFromData,\n  getUrlFromData\n} from './loader-utils/get-data';\n\n// TODO: support progress and abort\n// TODO: support moving loading to worker\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nexport async function parseWithLoader(data, loader, options = {}, url) {\n  url = url || getUrlFromData(data);\n  data = await getArrayBufferOrStringFromData(data, loader);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  // Now check for synchronous binary data parser, wrap results in promises\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parse) {\n    return await loader.parse(data, options, url, loader);\n  }\n\n  if (loader.worker) {\n    return await parseWithWorker(loader.worker, data, options);\n  }\n\n  // TBD - If asynchronous parser not available, return null\n  // => This loader does not work on loaded data and only supports `loadAndParseAsync`\n  return assert(false);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nexport function parseWithLoaderSync(data, loader, options = {}, url) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);\n  return assert(false);\n}\n\nexport async function parseWithLoaderInBatches(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);\n    return outputIterator;\n  }\n\n  // TODO - update after test cases have been fixed\n  return null;\n}\n\nexport async function parseWithLoaderInBatchesSync(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatchesSync) {\n    const inputIterator = getIteratorFromData(data);\n    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);\n    return outputIterator;\n  }\n\n  return assert(false);\n}\n"],"file":"parse-with-loader.js"}