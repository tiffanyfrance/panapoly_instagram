{"version":3,"sources":["../../../src/lib/parse-with-worker.js"],"names":["toArrayBuffer","workerCache","Map","getWorker","workerSource","workerURL","get","blob","Blob","type","URL","createObjectURL","set","Worker","parseWithWorker","data","options","worker","removeNontransferableOptions","parse","rawData","opts","Promise","resolve","reject","onmessage","evt","result","terminate","Error","message","arraybuffer","postMessage","Object","assign","log"],"mappings":"AAAA,SAAQA,aAAR,QAA4B,kCAA5B;AAEA,MAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;;AAGA,SAASC,SAAT,CAAmBC,YAAnB,EAAiC;AAC/B,MAAIC,SAAS,GAAGJ,WAAW,CAACK,GAAZ,CAAgBF,YAAhB,CAAhB;;AACA,MAAI,CAACC,SAAL,EAAgB;AACd,UAAME,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACJ,YAAD,CAAT,EAAyB;AAACK,MAAAA,IAAI,EAAE;AAAP,KAAzB,CAAb;AACAJ,IAAAA,SAAS,GAAGK,GAAG,CAACC,eAAJ,CAAoBJ,IAApB,CAAZ;AACAN,IAAAA,WAAW,CAACW,GAAZ,CAAgBR,YAAhB,EAA8BC,SAA9B;AACD;;AACD,SAAO,IAAIQ,MAAJ,CAAWR,SAAX,CAAP;AACD;;AAED,eAAe,SAASS,eAAT,CAAyBV,YAAzB,EAAuCW,IAAvC,EAA6CC,OAA7C,EAAsD;AACnE,QAAMC,MAAM,GAAGd,SAAS,CAACC,YAAD,CAAxB;AAEAY,EAAAA,OAAO,GAAGE,4BAA4B,CAACF,OAAD,CAAtC;;AAEA,QAAMG,KAAK,GAAG,CAACC,OAAD,EAAUC,IAAV,KACZ,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/BP,IAAAA,MAAM,CAACQ,SAAP,GAAmBC,GAAG,IAAI;AACxB,cAAQA,GAAG,CAACX,IAAJ,CAASN,IAAjB;AACE,aAAK,MAAL;AACEc,UAAAA,OAAO,CAACG,GAAG,CAACX,IAAJ,CAASY,MAAV,CAAP;AACAV,UAAAA,MAAM,CAACW,SAAP;AACA;;AAEF,aAAK,OAAL;AACEJ,UAAAA,MAAM,CAAC,IAAIK,KAAJ,CAAUH,GAAG,CAACX,IAAJ,CAASe,OAAnB,CAAD,CAAN;AACA;;AAEF;AAVF;AAYD,KAbD;;AAeA,UAAMC,WAAW,GAAG/B,aAAa,CAACoB,OAAD,CAAjC;AACAH,IAAAA,MAAM,CAACe,WAAP,CAAmB;AAACD,MAAAA,WAAD;AAAcV,MAAAA;AAAd,KAAnB,EAAwC,CAACU,WAAD,CAAxC;AACD,GAlBD,CADF;;AAqBA,SAAOhB,IAAI,GAAGI,KAAK,CAACJ,IAAD,EAAOC,OAAP,CAAR,GAA0BG,KAArC;AACD;;AAED,SAASD,4BAAT,CAAsCF,OAAtC,EAA+C;AAC7CA,EAAAA,OAAO,GAAGiB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBlB,OAAlB,CAAV;;AAGA,MAAIA,OAAO,CAACmB,GAAR,KAAgB,IAApB,EAA0B;AACxB,WAAOnB,OAAO,CAACmB,GAAf;AACD;;AACD,SAAOnB,OAAP;AACD","sourcesContent":["import {toArrayBuffer} from '../javascript-utils/binary-utils';\n\nconst workerCache = new Map();\n\n/* global Worker, Blob, URL */\nfunction getWorker(workerSource) {\n  let workerURL = workerCache.get(workerSource);\n  if (!workerURL) {\n    const blob = new Blob([workerSource], {type: 'application/javascript'});\n    workerURL = URL.createObjectURL(blob);\n    workerCache.set(workerSource, workerURL);\n  }\n  return new Worker(workerURL);\n}\n\nexport default function parseWithWorker(workerSource, data, options) {\n  const worker = getWorker(workerSource);\n\n  options = removeNontransferableOptions(options);\n\n  const parse = (rawData, opts) =>\n    new Promise((resolve, reject) => {\n      worker.onmessage = evt => {\n        switch (evt.data.type) {\n          case 'done':\n            resolve(evt.data.result);\n            worker.terminate();\n            break;\n\n          case 'error':\n            reject(new Error(evt.data.message));\n            break;\n\n          default:\n        }\n      };\n\n      const arraybuffer = toArrayBuffer(rawData);\n      worker.postMessage({arraybuffer, opts}, [arraybuffer]);\n    });\n\n  return data ? parse(data, options) : parse;\n}\n\nfunction removeNontransferableOptions(options) {\n  options = Object.assign({}, options);\n  // log object contains functions which cannot be transferred\n  // TODO - decide how to handle logging on workers\n  if (options.log !== null) {\n    delete options.log;\n  }\n  return options;\n}\n"],"file":"parse-with-worker.js"}