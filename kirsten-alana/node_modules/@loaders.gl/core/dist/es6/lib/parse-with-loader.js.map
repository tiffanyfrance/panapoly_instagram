{"version":3,"sources":["../../../src/lib/parse-with-loader.js"],"names":["assert","parseWithWorker","getArrayBufferOrStringFromDataSync","getArrayBufferOrStringFromData","getAsyncIteratorFromData","getIteratorFromData","getUrlFromData","parseWithLoader","data","loader","options","url","parseTextSync","dataType","parseSync","parse","worker","parseWithLoaderSync","parseWithLoaderInBatches","parseInBatches","inputIterator","outputIterator","parseWithLoaderInBatchesSync","parseInBatchesSync"],"mappings":"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","sourcesContent":["import assert from '../utils/assert';\nimport parseWithWorker from './parse-with-worker';\nimport {\n  getArrayBufferOrStringFromDataSync,\n  getArrayBufferOrStringFromData,\n  getAsyncIteratorFromData,\n  getIteratorFromData,\n  // getLengthFromData,\n  getUrlFromData\n} from './loader-utils/get-data';\n\n// TODO: support progress and abort\n// TODO: support moving loading to worker\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nexport async function parseWithLoader(data, loader, options = {}, url) {\n  url = url || getUrlFromData(data);\n  data = await getArrayBufferOrStringFromData(data, loader);\n\n  // First check for synchronous text parser, wrap results in promises\n  if (loader.parseTextSync && typeof data === 'string') {\n    options.dataType = 'text';\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  // Now check for synchronous binary data parser, wrap results in promises\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // Check for asynchronous parser\n  if (loader.parse) {\n    return await loader.parse(data, options, url, loader);\n  }\n\n  if (loader.worker) {\n    return await parseWithWorker(loader.worker, data, options);\n  }\n\n  // TBD - If asynchronous parser not available, return null\n  // => This loader does not work on loaded data and only supports `loadAndParseAsync`\n  return assert(false);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nexport function parseWithLoaderSync(data, loader, options = {}, url) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, url, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, url, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  // new Error(`Could not parse ${url || 'data'} using ${loader.name} loader`);\n  return assert(false);\n}\n\nexport async function parseWithLoaderInBatches(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const outputIterator = loader.parseInBatches(inputIterator, options, url, loader);\n    return outputIterator;\n  }\n\n  // TODO - update after test cases have been fixed\n  return null;\n}\n\nexport async function parseWithLoaderInBatchesSync(data, loader, options = {}, url) {\n  // Create async iterator adapter for data, and concatenate result\n  if (loader.parseInBatchesSync) {\n    const inputIterator = getIteratorFromData(data);\n    const outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);\n    return outputIterator;\n  }\n\n  return assert(false);\n}\n"],"file":"parse-with-loader.js"}