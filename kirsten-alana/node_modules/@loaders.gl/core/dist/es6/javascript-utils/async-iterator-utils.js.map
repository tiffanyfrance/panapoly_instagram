{"version":3,"sources":["../../../src/javascript-utils/async-iterator-utils.js"],"names":["concatenateArrayBuffers","TextDecoder","TextEncoder","forEach","iterator","visitor","next","done","value","return","cancel","concatenateAsyncIterator","asyncIterator","arrayBuffer","ArrayBuffer","string","chunk","textDecoderAsyncIterator","arrayBufferIterator","options","textDecoder","decode","stream","textEncoderAsyncIterator","textIterator","textEncoder","text","encode","lineAsyncIterator","previous","textChunk","eolIndex","indexOf","line","slice","length","numberedLineAsyncIterator","lineIterator","counter"],"mappings":"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","sourcesContent":["import {concatenateArrayBuffers} from '../javascript-utils/memory-copy-utils';\nimport {TextDecoder, TextEncoder} from '../javascript-utils/text-encoding';\n\n// GENERAL UTILITIES\n\n// Iterate over async iterator, without resetting iterator if end is not reached\n// - forEach does not reset iterator if exiting loop prematurely\n//   so that iteration can continue in a second loop\n// - It is recommended to use a standard for await as last loop to ensure\n//   iterator gets properly reset\n// TODO - optimize using sync iteration if argument is an Iterable?\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Concatenates all data chunks yielded by an async iterator\nexport async function concatenateAsyncIterator(asyncIterator) {\n  let arrayBuffer = new ArrayBuffer();\n  let string = '';\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      string += chunk;\n    } else {\n      arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n    }\n  }\n  return arrayBuffer || string;\n}\n\n// ITERATOR GENERATORS\n\n// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\nexport async function* textDecoderAsyncIterator(arrayBufferIterator, options) {\n  const textDecoder = new TextDecoder(options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* textEncoderAsyncIterator(textIterator, options) {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n// Input: async iterable over strings\n// Returns: an async iterable over lines\n// See http://2ality.com/2018/04/async-iter-nodejs.html\n\nexport async function* lineAsyncIterator(textIterator) {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * Parameter: async iterable of lines\n * Result: async iterable of numbered lines\n */\n// See http://2ality.com/2018/04/async-iter-nodejs.html\n// eslint-disable-next-line no-shadow\nexport async function* numberedLineAsyncIterator(lineIterator) {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n"],"file":"async-iterator-utils.js"}