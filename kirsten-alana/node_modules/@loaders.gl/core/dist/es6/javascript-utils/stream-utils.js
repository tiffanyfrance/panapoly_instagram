import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _awaitAsyncGenerator from "@babel/runtime/helpers/esm/awaitAsyncGenerator";
import _wrapAsyncGenerator from "@babel/runtime/helpers/esm/wrapAsyncGenerator";
import { isBrowser } from '../utils/globals';
import { concatenateArrayBuffers } from './memory-copy-utils';
export function getStreamIterator(stream) {
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return stream;
  }

  if (typeof stream.getIterator === 'function') {
    return stream.getIterator();
  }

  return isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}

function makeBrowserStreamIterator(_x) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = _wrapAsyncGenerator(function* (stream) {
    const reader = stream.getReader();

    try {
      while (true) {
        const _ref = yield _awaitAsyncGenerator(reader.read()),
              done = _ref.done,
              value = _ref.value;

        if (done) {
          return;
        }

        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  });
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x2) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = _wrapAsyncGenerator(function* (stream) {
    stream = yield _awaitAsyncGenerator(stream);

    while (true) {
      const data = stream.read();

      if (data !== null) {
        yield data;
        continue;
      }

      if (stream._readableState.ended) {
        return;
      }

      yield _awaitAsyncGenerator(onceReadable(stream));
    }
  });
  return _makeNodeStreamIterator.apply(this, arguments);
}

function onceReadable(_x3) {
  return _onceReadable.apply(this, arguments);
}

function _onceReadable() {
  _onceReadable = _asyncToGenerator(function* (stream) {
    return new Promise(resolve => {
      stream.once('readable', resolve);
    });
  });
  return _onceReadable.apply(this, arguments);
}

export function concatenateReadStream(readStream) {
  let arrayBuffer = new ArrayBuffer();
  let string = '';
  return new Promise((resolve, reject) => {
    readStream.data(chunk => {
      if (typeof chunk === 'string') {
        string += chunk;
      } else {
        arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);
      }
    });
    readStream.on('error', error => reject(error));
    readStream.on('end', () => {
      if (readStream.complete) {
        resolve(arrayBuffer || string);
      } else {
        reject('The connection was terminated while the message was still being sent');
      }
    });
  });
}
//# sourceMappingURL=stream-utils.js.map